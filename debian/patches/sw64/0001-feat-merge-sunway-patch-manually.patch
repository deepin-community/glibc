From aa47b8d4aaea3dad0ca7a9676c22676dbc341e9e Mon Sep 17 00:00:00 2001
From: Changwei Miao <miaochangwei@uniontech.com>
Date: Mon, 28 Oct 2024 20:40:33 +0800
Subject: [PATCH 1/6] feat: merge sunway patch manually.

This patched is checked from wxiat/glibc-2.38:7d8642803e with
extra modifications below.

- delete sw_glibc_version.h
- restore configure
- restore conform/linknamespace.py
- restore csu/version.c
- restore gen-locales.mk
- correct vdso symbol name.
---
 elf/elf.h                                     |   79 +
 elf/tst-glibcelf.py                           |    1 +
 posix/tst-glob_lstat_compat.c                 |    2 +-
 scripts/glibcelf.py                           |   10 +
 sysdeps/sw_64/Implies                         |    5 +
 sysdeps/sw_64/Makefile                        |   70 +
 sysdeps/sw_64/Subdirs                         |    1 +
 sysdeps/sw_64/Versions                        |   23 +
 sysdeps/sw_64/__longjmp.S                     |   64 +
 sysdeps/sw_64/_mcount.S                       |  105 +
 sysdeps/sw_64/add_n.S                         |  118 +
 sysdeps/sw_64/addmul_1.S                      |   90 +
 sysdeps/sw_64/atomic-machine.h                |  617 ++++
 sysdeps/sw_64/bits/endianness.h               |   11 +
 sysdeps/sw_64/bits/link.h                     |   68 +
 sysdeps/sw_64/bits/mathdef.h                  |   44 +
 sysdeps/sw_64/bits/setjmp.h                   |   61 +
 sysdeps/sw_64/bsd-_setjmp.S                   |    1 +
 sysdeps/sw_64/bsd-setjmp.S                    |    1 +
 sysdeps/sw_64/bzero.S                         |  110 +
 sysdeps/sw_64/configure                       |    8 +
 sysdeps/sw_64/configure.ac                    |    7 +
 sysdeps/sw_64/crti.S                          |  101 +
 sysdeps/sw_64/crtn.S                          |   49 +
 sysdeps/sw_64/div.S                           |   84 +
 sysdeps/sw_64/div_libc.h                      |  170 +
 sysdeps/sw_64/divl.S                          |   98 +
 sysdeps/sw_64/divlu.S                         |    4 +
 sysdeps/sw_64/divq.S                          |  295 ++
 sysdeps/sw_64/divqu.S                         |  301 ++
 sysdeps/sw_64/dl-dtprocnum.h                  |    3 +
 sysdeps/sw_64/dl-machine.h                    |  506 +++
 sysdeps/sw_64/dl-procinfo.c                   |   67 +
 sysdeps/sw_64/dl-procinfo.h                   |   60 +
 sysdeps/sw_64/dl-sysdep.h                     |   23 +
 sysdeps/sw_64/dl-tls.h                        |   27 +
 sysdeps/sw_64/dl-trampoline.S                 |  540 +++
 sysdeps/sw_64/e_sqrtl.c                       |   47 +
 sysdeps/sw_64/elf-initfini.h                  |   20 +
 sysdeps/sw_64/ffs.S                           |   91 +
 sysdeps/sw_64/ffsll.S                         |    1 +
 sysdeps/sw_64/fpu/Versions                    |   23 +
 sysdeps/sw_64/fpu/bits/fenv.h                 |  141 +
 sysdeps/sw_64/fpu/cabsf.c                     |   41 +
 sysdeps/sw_64/fpu/cargf.c                     |   41 +
 sysdeps/sw_64/fpu/cfloat-compat.h             |   60 +
 sysdeps/sw_64/fpu/cimagf.c                    |   40 +
 sysdeps/sw_64/fpu/conjf.c                     |   42 +
 sysdeps/sw_64/fpu/crealf.c                    |   40 +
 sysdeps/sw_64/fpu/e_sqrt.c                    |   26 +
 sysdeps/sw_64/fpu/e_sqrtf.c                   |    8 +
 sysdeps/sw_64/fpu/fclrexcpt.c                 |   47 +
 sysdeps/sw_64/fpu/fedisblxcpt.c               |   35 +
 sysdeps/sw_64/fpu/feenablxcpt.c               |   35 +
 sysdeps/sw_64/fpu/fegetenv.c                  |   51 +
 sysdeps/sw_64/fpu/fegetexcept.c               |   30 +
 sysdeps/sw_64/fpu/fegetmode.c                 |   37 +
 sysdeps/sw_64/fpu/fegetround.c                |   37 +
 sysdeps/sw_64/fpu/feholdexcpt.c               |   35 +
 sysdeps/sw_64/fpu/fenv_libc.h                 |   39 +
 sysdeps/sw_64/fpu/fesetenv.c                  |   63 +
 sysdeps/sw_64/fpu/fesetexcept.c               |   31 +
 sysdeps/sw_64/fpu/fesetmode.c                 |   52 +
 sysdeps/sw_64/fpu/fesetround.c                |   52 +
 sysdeps/sw_64/fpu/feupdateenv.c               |   50 +
 sysdeps/sw_64/fpu/fgetexcptflg.c              |   43 +
 sysdeps/sw_64/fpu/fpu_control.h               |  105 +
 sysdeps/sw_64/fpu/fsetexcptflg.c              |   46 +
 sysdeps/sw_64/fpu/ftestexcept.c               |   32 +
 sysdeps/sw_64/fpu/get-rounding-mode.h         |   39 +
 sysdeps/sw_64/fpu/libm-test-ulps              | 1826 ++++++++++
 sysdeps/sw_64/fpu/libm-test-ulps-name         |    1 +
 sysdeps/sw_64/fpu/math-barriers.h             |   28 +
 sysdeps/sw_64/fpu/math-use-builtins-sqrt.h    |    9 +
 sysdeps/sw_64/fpu/s_cacosf.c                  |   57 +
 sysdeps/sw_64/fpu/s_cacoshf.c                 |   56 +
 sysdeps/sw_64/fpu/s_casinf.c                  |   54 +
 sysdeps/sw_64/fpu/s_casinhf.c                 |   54 +
 sysdeps/sw_64/fpu/s_catanf.c                  |   54 +
 sysdeps/sw_64/fpu/s_catanhf.c                 |   54 +
 sysdeps/sw_64/fpu/s_ccosf.c                   |   54 +
 sysdeps/sw_64/fpu/s_ccoshf.c                  |   54 +
 sysdeps/sw_64/fpu/s_cexpf.c                   |   54 +
 sysdeps/sw_64/fpu/s_clog10f.c                 |   66 +
 sysdeps/sw_64/fpu/s_clogf.c                   |   54 +
 sysdeps/sw_64/fpu/s_copysign.c                |   33 +
 sysdeps/sw_64/fpu/s_copysignf.c               |   29 +
 sysdeps/sw_64/fpu/s_cpowf.c                   |   54 +
 sysdeps/sw_64/fpu/s_cprojf.c                  |   54 +
 sysdeps/sw_64/fpu/s_csinf.c                   |   54 +
 sysdeps/sw_64/fpu/s_csinhf.c                  |   54 +
 sysdeps/sw_64/fpu/s_csqrtf.c                  |   54 +
 sysdeps/sw_64/fpu/s_ctanf.c                   |   54 +
 sysdeps/sw_64/fpu/s_ctanhf.c                  |   54 +
 sysdeps/sw_64/fpu/s_fabs.c                    |   29 +
 sysdeps/sw_64/fpu/s_fabsf.c                   |   28 +
 sysdeps/sw_64/fpu/s_fma.c                     |    2 +
 sysdeps/sw_64/fpu/s_isnan.c                   |   59 +
 sysdeps/sw_64/fpu/s_isnanf.c                  |    1 +
 sysdeps/sw_64/fpu/s_llrint.c                  |    1 +
 sysdeps/sw_64/fpu/s_llrintf.c                 |    1 +
 sysdeps/sw_64/fpu/s_llround.c                 |    1 +
 sysdeps/sw_64/fpu/s_llroundf.c                |    1 +
 sysdeps/sw_64/fpu/s_lrint.c                   |   46 +
 sysdeps/sw_64/fpu/s_lrintf.c                  |   47 +
 sysdeps/sw_64/fpu/s_lround.c                  |   47 +
 sysdeps/sw_64/fpu/s_lroundf.c                 |   74 +
 sysdeps/sw_64/fpu/s_rint.c                    |   59 +
 sysdeps/sw_64/fpu/s_rintf.c                   |   66 +
 sysdeps/sw_64/fpu/ulps                        | 1826 ++++++++++
 sysdeps/sw_64/gccframe.h                      |   21 +
 sysdeps/sw_64/hp-timing.h                     |   46 +
 sysdeps/sw_64/htonl.S                         |   43 +
 sysdeps/sw_64/htons.S                         |   39 +
 sysdeps/sw_64/include/_sw7mc_math_def.h       |  413 +++
 sysdeps/sw_64/include/_sw7mc_regdef.h         |   45 +
 sysdeps/sw_64/include/test_numdouble.h        |  101 +
 sysdeps/sw_64/include/test_numfloat.h         |   99 +
 sysdeps/sw_64/jmpbuf-offsets.h                |   35 +
 sysdeps/sw_64/jmpbuf-unwind.h                 |   46 +
 sysdeps/sw_64/ldiv.S                          |  222 ++
 sysdeps/sw_64/ldsodefs.h                      |   42 +
 sysdeps/sw_64/libc-tls.c                      |   32 +
 sysdeps/sw_64/lldiv.S                         |    1 +
 sysdeps/sw_64/local-soft-fp.h                 |   55 +
 sysdeps/sw_64/lshift.S                        |  107 +
 sysdeps/sw_64/machine-gmon.h                  |   25 +
 sysdeps/sw_64/memchr.c                        |  177 +
 sysdeps/sw_64/memset.S                        |  223 ++
 sysdeps/sw_64/memusage.h                      |   20 +
 sysdeps/sw_64/mul_1.S                         |   83 +
 sysdeps/sw_64/nptl/bits/struct_rwlock.h       |   43 +
 sysdeps/sw_64/nptl/pthread-offsets.h          |    3 +
 sysdeps/sw_64/nptl/pthread_spin_lock.S        |   77 +
 sysdeps/sw_64/nptl/pthread_spin_trylock.S     |   76 +
 sysdeps/sw_64/nptl/pthreaddef.h               |   31 +
 sysdeps/sw_64/nptl/tls.h                      |  114 +
 sysdeps/sw_64/nscd-types.h                    |   21 +
 sysdeps/sw_64/ots_add.c                       |   38 +
 sysdeps/sw_64/ots_cmp.c                       |   63 +
 sysdeps/sw_64/ots_cmpe.c                      |   77 +
 sysdeps/sw_64/ots_cvtqux.c                    |   39 +
 sysdeps/sw_64/ots_cvtqx.c                     |   38 +
 sysdeps/sw_64/ots_cvttx.c                     |   47 +
 sysdeps/sw_64/ots_cvtxq.c                     |   41 +
 sysdeps/sw_64/ots_cvtxt.c                     |   43 +
 sysdeps/sw_64/ots_div.c                       |   38 +
 sysdeps/sw_64/ots_mul.c                       |   38 +
 sysdeps/sw_64/ots_nintxq.c                    |   51 +
 sysdeps/sw_64/ots_sub.c                       |   38 +
 sysdeps/sw_64/preconfigure                    |    3 +
 sysdeps/sw_64/rawmemchr.S                     |   89 +
 sysdeps/sw_64/reml.S                          |   93 +
 sysdeps/sw_64/remlu.S                         |    4 +
 sysdeps/sw_64/remq.S                          |  283 ++
 sysdeps/sw_64/remqu.S                         |  340 ++
 sysdeps/sw_64/rshift.S                        |  105 +
 sysdeps/sw_64/setjmp.S                        |  121 +
 sysdeps/sw_64/sfp-machine.h                   |   99 +
 sysdeps/sw_64/sotruss-lib.c                   |   50 +
 sysdeps/sw_64/stackinfo.h                     |   33 +
 sysdeps/sw_64/start.S                         |  108 +
 sysdeps/sw_64/stpcpy.S                        |   55 +
 sysdeps/sw_64/stpncpy.S                       |  106 +
 sysdeps/sw_64/strcat.S                        |   71 +
 sysdeps/sw_64/strchr.S                        |   94 +
 sysdeps/sw_64/strcmp.S                        |  194 +
 sysdeps/sw_64/strcpy.S                        |   41 +
 sysdeps/sw_64/strlen.S                        |   76 +
 sysdeps/sw_64/strncat.S                       |   94 +
 sysdeps/sw_64/strncmp.S                       |  277 ++
 sysdeps/sw_64/strncpy.S                       |   87 +
 sysdeps/sw_64/strrchr.S                       |  110 +
 sysdeps/sw_64/stxcpy.S                        |  294 ++
 sysdeps/sw_64/stxncpy.S                       |  352 ++
 sysdeps/sw_64/sub_n.S                         |  118 +
 sysdeps/sw_64/submul_1.S                      |   90 +
 sysdeps/sw_64/sw6a/Implies                    |    1 +
 sysdeps/sw_64/sw6a/add_n.S                    |  146 +
 sysdeps/sw_64/sw6a/addmul_1.S                 |  477 +++
 sysdeps/sw_64/sw6a/lshift.S                   |  172 +
 sysdeps/sw_64/sw6a/memcpy.S                   |  840 +++++
 sysdeps/sw_64/sw6a/memset.S                   |  453 +++
 sysdeps/sw_64/sw6a/rshift.S                   |  170 +
 sysdeps/sw_64/sw6a/stxcpy.S                   |  314 ++
 sysdeps/sw_64/sw6a/stxncpy.S                  |  392 +++
 sysdeps/sw_64/sw6a/sub_n.S                    |  147 +
 sysdeps/sw_64/sw6b/Implies                    |    1 +
 sysdeps/sw_64/sw6b/add_n.S                    |  146 +
 sysdeps/sw_64/sw6b/addmul_1.S                 |  477 +++
 sysdeps/sw_64/sw6b/lshift.S                   |  172 +
 sysdeps/sw_64/sw6b/memcpy.S                   |  416 +++
 sysdeps/sw_64/sw6b/memset.S                   |  311 ++
 sysdeps/sw_64/sw6b/rshift.S                   |  170 +
 sysdeps/sw_64/sw6b/stxcpy.S                   |  314 ++
 sysdeps/sw_64/sw6b/stxncpy.S                  |  392 +++
 sysdeps/sw_64/sw6b/sub_n.S                    |  147 +
 sysdeps/sw_64/sw8a/Implies                    |    1 +
 sysdeps/sw_64/sw8a/add_n.S                    |  146 +
 sysdeps/sw_64/sw8a/addmul_1.S                 |  477 +++
 sysdeps/sw_64/sw8a/atomic-machine.h           |  374 ++
 sysdeps/sw_64/sw8a/lshift.S                   |  172 +
 sysdeps/sw_64/sw8a/memcpy.S                   |  323 ++
 sysdeps/sw_64/sw8a/memmove.S                  | 1120 ++++++
 sysdeps/sw_64/sw8a/memset.S                   |  332 ++
 sysdeps/sw_64/sw8a/nptl/Makefile              |   20 +
 sysdeps/sw_64/sw8a/nptl/bits/struct_rwlock.h  |   43 +
 sysdeps/sw_64/sw8a/nptl/pthread-offsets.h     |    3 +
 sysdeps/sw_64/sw8a/nptl/pthread_spin_lock.S   |   43 +
 .../sw_64/sw8a/nptl/pthread_spin_trylock.S    |   44 +
 sysdeps/sw_64/sw8a/nptl/pthreaddef.h          |   31 +
 sysdeps/sw_64/sw8a/nptl/tcb-offsets.sym       |   13 +
 sysdeps/sw_64/sw8a/nptl/tls.h                 |  112 +
 sysdeps/sw_64/sw8a/rshift.S                   |  170 +
 sysdeps/sw_64/sw8a/strcat.S                   |  306 ++
 sysdeps/sw_64/sw8a/strchr.S                   |  245 ++
 sysdeps/sw_64/sw8a/strcmp.S                   |  369 ++
 sysdeps/sw_64/sw8a/strlen.S                   |  112 +
 sysdeps/sw_64/sw8a/strncat.S                  |  412 +++
 sysdeps/sw_64/sw8a/strncmp.S                  |  694 ++++
 sysdeps/sw_64/sw8a/stxcpy.S                   |  314 ++
 sysdeps/sw_64/sw8a/stxncpy.S                  |  392 +++
 sysdeps/sw_64/sw8a/sub_n.S                    |  147 +
 sysdeps/sw_64/tininess.h                      |    1 +
 sysdeps/sw_64/tls-macros.h                    |   25 +
 sysdeps/sw_64/tst-audit.h                     |   24 +
 sysdeps/sw_64/tst-file-align.h                |   20 +
 sysdeps/sw_64/udiv_qrnnd.S                    |  159 +
 sysdeps/sw_64/unwind-arch.h                   |   28 +
 sysdeps/unix/sw_64/Makefile                   |    4 +
 sysdeps/unix/sw_64/pipe.S                     |   31 +
 sysdeps/unix/sw_64/rt-sysdep.S                |    1 +
 sysdeps/unix/sw_64/sysdep.S                   |   65 +
 sysdeps/unix/sysv/linux/sw_64/Implies         |    6 +
 sysdeps/unix/sysv/linux/sw_64/Makefile        |   36 +
 sysdeps/unix/sysv/linux/sw_64/Versions        |  105 +
 .../unix/sysv/linux/sw_64/____longjmp_chk.S   |  149 +
 sysdeps/unix/sysv/linux/sw_64/a.out.h         |  197 ++
 sysdeps/unix/sysv/linux/sw_64/adjtime.c       |   22 +
 sysdeps/unix/sysv/linux/sw_64/adjtimex.c      |   22 +
 sysdeps/unix/sysv/linux/sw_64/aio_cancel.c    |   35 +
 sysdeps/unix/sysv/linux/sw_64/arch-syscall.h  |  376 ++
 sysdeps/unix/sysv/linux/sw_64/bits/a.out.h    |    9 +
 sysdeps/unix/sysv/linux/sw_64/bits/dirent.h   |   57 +
 sysdeps/unix/sysv/linux/sw_64/bits/elfclass.h |   14 +
 sysdeps/unix/sysv/linux/sw_64/bits/epoll.h    |   27 +
 sysdeps/unix/sysv/linux/sw_64/bits/errno.h    |   53 +
 sysdeps/unix/sysv/linux/sw_64/bits/eventfd.h  |   31 +
 sysdeps/unix/sysv/linux/sw_64/bits/fcntl.h    |   87 +
 sysdeps/unix/sysv/linux/sw_64/bits/inotify.h  |   29 +
 sysdeps/unix/sysv/linux/sw_64/bits/ioctls.h   |   36 +
 sysdeps/unix/sysv/linux/sw_64/bits/mman.h     |   66 +
 sysdeps/unix/sysv/linux/sw_64/bits/netdb.h    |   38 +
 .../sysv/linux/sw_64/bits/procfs-prregset.h   |   25 +
 sysdeps/unix/sysv/linux/sw_64/bits/procfs.h   |   38 +
 .../sysv/linux/sw_64/bits/pthread_stack_min.h |   20 +
 sysdeps/unix/sysv/linux/sw_64/bits/resource.h |  223 ++
 .../unix/sysv/linux/sw_64/bits/sigaction.h    |   80 +
 sysdeps/unix/sysv/linux/sw_64/bits/signalfd.h |   29 +
 .../unix/sysv/linux/sw_64/bits/signum-arch.h  |   67 +
 sysdeps/unix/sysv/linux/sw_64/bits/sigstack.h |   32 +
 .../sysv/linux/sw_64/bits/socket-constants.h  |   50 +
 .../unix/sysv/linux/sw_64/bits/socket_type.h  |   55 +
 sysdeps/unix/sysv/linux/sw_64/bits/statfs.h   |   64 +
 .../unix/sysv/linux/sw_64/bits/struct_stat.h  |  119 +
 .../unix/sysv/linux/sw_64/bits/termios-baud.h |   46 +
 .../unix/sysv/linux/sw_64/bits/termios-c_cc.h |   40 +
 .../sysv/linux/sw_64/bits/termios-c_cflag.h   |   38 +
 .../sysv/linux/sw_64/bits/termios-c_iflag.h   |   38 +
 .../sysv/linux/sw_64/bits/termios-c_lflag.h   |   42 +
 .../sysv/linux/sw_64/bits/termios-c_oflag.h   |   66 +
 .../sysv/linux/sw_64/bits/termios-struct.h    |   37 +
 sysdeps/unix/sysv/linux/sw_64/bits/timerfd.h  |   29 +
 .../unix/sysv/linux/sw_64/bits/typesizes.h    |   83 +
 sysdeps/unix/sysv/linux/sw_64/bits/wordsize.h |   19 +
 sysdeps/unix/sysv/linux/sw_64/brk_call.h      |   27 +
 sysdeps/unix/sysv/linux/sw_64/c++-types.data  |   67 +
 sysdeps/unix/sysv/linux/sw_64/clone.S         |  117 +
 sysdeps/unix/sysv/linux/sw_64/configure       |    5 +
 sysdeps/unix/sysv/linux/sw_64/configure.ac    |    5 +
 sysdeps/unix/sysv/linux/sw_64/dl-auxv.h       |   40 +
 sysdeps/unix/sysv/linux/sw_64/dl-support.c    |    2 +
 sysdeps/unix/sysv/linux/sw_64/dl-sysdep.c     |    5 +
 .../unix/sysv/linux/sw_64/errlist-compat.c    |   43 +
 sysdeps/unix/sysv/linux/sw_64/fpu/Implies     |    2 +
 sysdeps/unix/sysv/linux/sw_64/fraiseexcpt.S   |   58 +
 sysdeps/unix/sysv/linux/sw_64/fstatfs.c       |   30 +
 sysdeps/unix/sysv/linux/sw_64/fxstat64.c      |   45 +
 sysdeps/unix/sysv/linux/sw_64/fxstatat64.c    |   32 +
 sysdeps/unix/sysv/linux/sw_64/getclktck.c     |    2 +
 sysdeps/unix/sysv/linux/sw_64/getcontext.S    |  440 +++
 sysdeps/unix/sysv/linux/sw_64/getdents.c      |   13 +
 sysdeps/unix/sysv/linux/sw_64/getdents64.c    |   10 +
 sysdeps/unix/sysv/linux/sw_64/getegid.S       |   26 +
 sysdeps/unix/sysv/linux/sw_64/geteuid.S       |   26 +
 sysdeps/unix/sysv/linux/sw_64/gethostname.c   |   45 +
 sysdeps/unix/sysv/linux/sw_64/getppid.S       |   26 +
 sysdeps/unix/sysv/linux/sw_64/getrlimit64.c   |   56 +
 sysdeps/unix/sysv/linux/sw_64/gettimeofday.c  |   26 +
 .../unix/sysv/linux/sw_64/glob-lstat-compat.c |    2 +
 sysdeps/unix/sysv/linux/sw_64/globfree.c      |   37 +
 .../sysv/linux/sw_64/ieee_get_fp_control.S    |   50 +
 .../sysv/linux/sw_64/ieee_set_fp_control.S    |   46 +
 sysdeps/unix/sysv/linux/sw_64/ioperm.c        |  877 +++++
 sysdeps/unix/sysv/linux/sw_64/ipc_priv.h      |   21 +
 .../unix/sysv/linux/sw_64/jmp_buf-macros.h    |    6 +
 .../unix/sysv/linux/sw_64/kernel-features.h   |   53 +
 .../sysv/linux/sw_64/kernel_rt_sigframe.h     |   25 +
 .../unix/sysv/linux/sw_64/kernel_sigaction.h  |   11 +
 sysdeps/unix/sysv/linux/sw_64/kernel_stat.h   |   91 +
 .../unix/sysv/linux/sw_64/kernel_sysinfo.h    |    6 +
 .../unix/sysv/linux/sw_64/kernel_termios.h    |   43 +
 sysdeps/unix/sysv/linux/sw_64/ld.abilist      |    9 +
 .../sysv/linux/sw_64/libBrokenLocale.abilist  |    1 +
 sysdeps/unix/sysv/linux/sw_64/libanl.abilist  |    1 +
 sysdeps/unix/sysv/linux/sw_64/libc.abilist    | 3108 +++++++++++++++++
 .../linux/sw_64/libc_malloc_debug.abilist     |   28 +
 .../unix/sysv/linux/sw_64/libcrypt.abilist    |    7 +
 sysdeps/unix/sysv/linux/sw_64/libdl.abilist   |    4 +
 sysdeps/unix/sysv/linux/sw_64/libm.abilist    | 1309 +++++++
 sysdeps/unix/sysv/linux/sw_64/libnsl.abilist  |  121 +
 .../unix/sysv/linux/sw_64/libpthread.abilist  |   17 +
 .../unix/sysv/linux/sw_64/libresolv.abilist   |   67 +
 sysdeps/unix/sysv/linux/sw_64/librt-compat.c  |   24 +
 sysdeps/unix/sysv/linux/sw_64/librt.abilist   |    7 +
 .../sysv/linux/sw_64/libthread_db.abilist     |   40 +
 sysdeps/unix/sysv/linux/sw_64/libutil.abilist |    1 +
 sysdeps/unix/sysv/linux/sw_64/localplt.data   |   33 +
 sysdeps/unix/sysv/linux/sw_64/lxstat64.c      |   46 +
 sysdeps/unix/sysv/linux/sw_64/makecontext.S   |  164 +
 sysdeps/unix/sysv/linux/sw_64/nldbl-abi.h     |    8 +
 sysdeps/unix/sysv/linux/sw_64/oldglob.c       |  101 +
 sysdeps/unix/sysv/linux/sw_64/osf_adjtime.c   |  131 +
 sysdeps/unix/sysv/linux/sw_64/osf_getitimer.c |   44 +
 sysdeps/unix/sysv/linux/sw_64/osf_getrusage.c |   39 +
 .../unix/sysv/linux/sw_64/osf_gettimeofday.c  |   48 +
 sysdeps/unix/sysv/linux/sw_64/osf_setitimer.c |   54 +
 .../unix/sysv/linux/sw_64/osf_settimeofday.c  |   50 +
 sysdeps/unix/sysv/linux/sw_64/osf_utimes.c    |   37 +
 sysdeps/unix/sysv/linux/sw_64/osf_wait4.c     |   41 +
 sysdeps/unix/sysv/linux/sw_64/pipe.S          |    1 +
 sysdeps/unix/sysv/linux/sw_64/pointer_guard.h |   63 +
 sysdeps/unix/sysv/linux/sw_64/register-dump.h |  239 ++
 sysdeps/unix/sysv/linux/sw_64/rt_sigaction.S  |   87 +
 sysdeps/unix/sysv/linux/sw_64/select.c        |   54 +
 sysdeps/unix/sysv/linux/sw_64/setcontext.S    |   34 +
 sysdeps/unix/sysv/linux/sw_64/setfpucw.c      |   61 +
 sysdeps/unix/sysv/linux/sw_64/setrlimit64.c   |   53 +
 sysdeps/unix/sysv/linux/sw_64/settimeofday.c  |   22 +
 sysdeps/unix/sysv/linux/sw_64/shlib-versions  |   14 +
 .../unix/sysv/linux/sw_64/sigcontextinfo.h    |   30 +
 sysdeps/unix/sysv/linux/sw_64/sizes.h         |   23 +
 sysdeps/unix/sysv/linux/sw_64/statfs.c        |   30 +
 .../unix/sysv/linux/sw_64/sw6a/fpu/Implies    |    2 +
 .../unix/sysv/linux/sw_64/sw6b/fpu/Implies    |    2 +
 .../unix/sysv/linux/sw_64/sw8a/fpu/Implies    |    2 +
 sysdeps/unix/sysv/linux/sw_64/sw_64/ptrace.h  |   18 +
 sysdeps/unix/sysv/linux/sw_64/sw_64/regdef.h  |   44 +
 sysdeps/unix/sysv/linux/sw_64/swapcontext.S   |   50 +
 sysdeps/unix/sysv/linux/sw_64/sys/acct.h      |   63 +
 sysdeps/unix/sysv/linux/sw_64/sys/io.h        |   94 +
 sysdeps/unix/sysv/linux/sw_64/sys/ucontext.h  |   98 +
 sysdeps/unix/sysv/linux/sw_64/sys/user.h      |   52 +
 sysdeps/unix/sysv/linux/sw_64/syscall.S       |   70 +
 sysdeps/unix/sysv/linux/sw_64/syscalls.list   |   27 +
 sysdeps/unix/sysv/linux/sw_64/sysconf.c       |  127 +
 sysdeps/unix/sysv/linux/sw_64/sysdep.h        |  364 ++
 .../sysv/linux/sw_64/timer_t_was_int_compat.h |   19 +
 .../sysv/linux/sw_64/ucontext-offsets.sym     |   28 +
 sysdeps/unix/sysv/linux/sw_64/vfork.S         |   45 +
 sysdeps/unix/sysv/linux/sw_64/wait4.c         |   28 +
 sysdeps/unix/sysv/linux/sw_64/wordexp.c       |    1 +
 sysdeps/unix/sysv/linux/sw_64/xstat64.c       |   46 +
 sysdeps/unix/sysv/linux/sw_64/xstatconv.c     |  120 +
 sysdeps/unix/sysv/linux/sw_64/xstatconv.h     |   22 +
 sysdeps/unix/sysv/linux/sw_64/xstatver.h      |   14 +
 sysdeps/unix/sysv/linux/syscall-names.list    |    6 +
 377 files changed, 41759 insertions(+), 1 deletion(-)
 create mode 100644 sysdeps/sw_64/Implies
 create mode 100644 sysdeps/sw_64/Makefile
 create mode 100644 sysdeps/sw_64/Subdirs
 create mode 100644 sysdeps/sw_64/Versions
 create mode 100644 sysdeps/sw_64/__longjmp.S
 create mode 100644 sysdeps/sw_64/_mcount.S
 create mode 100644 sysdeps/sw_64/add_n.S
 create mode 100644 sysdeps/sw_64/addmul_1.S
 create mode 100644 sysdeps/sw_64/atomic-machine.h
 create mode 100644 sysdeps/sw_64/bits/endianness.h
 create mode 100644 sysdeps/sw_64/bits/link.h
 create mode 100644 sysdeps/sw_64/bits/mathdef.h
 create mode 100644 sysdeps/sw_64/bits/setjmp.h
 create mode 100644 sysdeps/sw_64/bsd-_setjmp.S
 create mode 100644 sysdeps/sw_64/bsd-setjmp.S
 create mode 100644 sysdeps/sw_64/bzero.S
 create mode 100644 sysdeps/sw_64/configure
 create mode 100644 sysdeps/sw_64/configure.ac
 create mode 100644 sysdeps/sw_64/crti.S
 create mode 100644 sysdeps/sw_64/crtn.S
 create mode 100644 sysdeps/sw_64/div.S
 create mode 100644 sysdeps/sw_64/div_libc.h
 create mode 100644 sysdeps/sw_64/divl.S
 create mode 100644 sysdeps/sw_64/divlu.S
 create mode 100644 sysdeps/sw_64/divq.S
 create mode 100644 sysdeps/sw_64/divqu.S
 create mode 100644 sysdeps/sw_64/dl-dtprocnum.h
 create mode 100644 sysdeps/sw_64/dl-machine.h
 create mode 100644 sysdeps/sw_64/dl-procinfo.c
 create mode 100644 sysdeps/sw_64/dl-procinfo.h
 create mode 100644 sysdeps/sw_64/dl-sysdep.h
 create mode 100644 sysdeps/sw_64/dl-tls.h
 create mode 100644 sysdeps/sw_64/dl-trampoline.S
 create mode 100644 sysdeps/sw_64/e_sqrtl.c
 create mode 100644 sysdeps/sw_64/elf-initfini.h
 create mode 100644 sysdeps/sw_64/ffs.S
 create mode 100644 sysdeps/sw_64/ffsll.S
 create mode 100644 sysdeps/sw_64/fpu/Versions
 create mode 100644 sysdeps/sw_64/fpu/bits/fenv.h
 create mode 100644 sysdeps/sw_64/fpu/cabsf.c
 create mode 100644 sysdeps/sw_64/fpu/cargf.c
 create mode 100644 sysdeps/sw_64/fpu/cfloat-compat.h
 create mode 100644 sysdeps/sw_64/fpu/cimagf.c
 create mode 100644 sysdeps/sw_64/fpu/conjf.c
 create mode 100644 sysdeps/sw_64/fpu/crealf.c
 create mode 100644 sysdeps/sw_64/fpu/e_sqrt.c
 create mode 100644 sysdeps/sw_64/fpu/e_sqrtf.c
 create mode 100644 sysdeps/sw_64/fpu/fclrexcpt.c
 create mode 100644 sysdeps/sw_64/fpu/fedisblxcpt.c
 create mode 100644 sysdeps/sw_64/fpu/feenablxcpt.c
 create mode 100644 sysdeps/sw_64/fpu/fegetenv.c
 create mode 100644 sysdeps/sw_64/fpu/fegetexcept.c
 create mode 100644 sysdeps/sw_64/fpu/fegetmode.c
 create mode 100644 sysdeps/sw_64/fpu/fegetround.c
 create mode 100644 sysdeps/sw_64/fpu/feholdexcpt.c
 create mode 100644 sysdeps/sw_64/fpu/fenv_libc.h
 create mode 100644 sysdeps/sw_64/fpu/fesetenv.c
 create mode 100644 sysdeps/sw_64/fpu/fesetexcept.c
 create mode 100644 sysdeps/sw_64/fpu/fesetmode.c
 create mode 100644 sysdeps/sw_64/fpu/fesetround.c
 create mode 100644 sysdeps/sw_64/fpu/feupdateenv.c
 create mode 100644 sysdeps/sw_64/fpu/fgetexcptflg.c
 create mode 100644 sysdeps/sw_64/fpu/fpu_control.h
 create mode 100644 sysdeps/sw_64/fpu/fsetexcptflg.c
 create mode 100644 sysdeps/sw_64/fpu/ftestexcept.c
 create mode 100644 sysdeps/sw_64/fpu/get-rounding-mode.h
 create mode 100644 sysdeps/sw_64/fpu/libm-test-ulps
 create mode 100644 sysdeps/sw_64/fpu/libm-test-ulps-name
 create mode 100644 sysdeps/sw_64/fpu/math-barriers.h
 create mode 100644 sysdeps/sw_64/fpu/math-use-builtins-sqrt.h
 create mode 100644 sysdeps/sw_64/fpu/s_cacosf.c
 create mode 100644 sysdeps/sw_64/fpu/s_cacoshf.c
 create mode 100644 sysdeps/sw_64/fpu/s_casinf.c
 create mode 100644 sysdeps/sw_64/fpu/s_casinhf.c
 create mode 100644 sysdeps/sw_64/fpu/s_catanf.c
 create mode 100644 sysdeps/sw_64/fpu/s_catanhf.c
 create mode 100644 sysdeps/sw_64/fpu/s_ccosf.c
 create mode 100644 sysdeps/sw_64/fpu/s_ccoshf.c
 create mode 100644 sysdeps/sw_64/fpu/s_cexpf.c
 create mode 100644 sysdeps/sw_64/fpu/s_clog10f.c
 create mode 100644 sysdeps/sw_64/fpu/s_clogf.c
 create mode 100644 sysdeps/sw_64/fpu/s_copysign.c
 create mode 100644 sysdeps/sw_64/fpu/s_copysignf.c
 create mode 100644 sysdeps/sw_64/fpu/s_cpowf.c
 create mode 100644 sysdeps/sw_64/fpu/s_cprojf.c
 create mode 100644 sysdeps/sw_64/fpu/s_csinf.c
 create mode 100644 sysdeps/sw_64/fpu/s_csinhf.c
 create mode 100644 sysdeps/sw_64/fpu/s_csqrtf.c
 create mode 100644 sysdeps/sw_64/fpu/s_ctanf.c
 create mode 100644 sysdeps/sw_64/fpu/s_ctanhf.c
 create mode 100644 sysdeps/sw_64/fpu/s_fabs.c
 create mode 100644 sysdeps/sw_64/fpu/s_fabsf.c
 create mode 100644 sysdeps/sw_64/fpu/s_fma.c
 create mode 100644 sysdeps/sw_64/fpu/s_isnan.c
 create mode 100644 sysdeps/sw_64/fpu/s_isnanf.c
 create mode 100644 sysdeps/sw_64/fpu/s_llrint.c
 create mode 100644 sysdeps/sw_64/fpu/s_llrintf.c
 create mode 100644 sysdeps/sw_64/fpu/s_llround.c
 create mode 100644 sysdeps/sw_64/fpu/s_llroundf.c
 create mode 100644 sysdeps/sw_64/fpu/s_lrint.c
 create mode 100644 sysdeps/sw_64/fpu/s_lrintf.c
 create mode 100644 sysdeps/sw_64/fpu/s_lround.c
 create mode 100644 sysdeps/sw_64/fpu/s_lroundf.c
 create mode 100644 sysdeps/sw_64/fpu/s_rint.c
 create mode 100644 sysdeps/sw_64/fpu/s_rintf.c
 create mode 100644 sysdeps/sw_64/fpu/ulps
 create mode 100644 sysdeps/sw_64/gccframe.h
 create mode 100644 sysdeps/sw_64/hp-timing.h
 create mode 100644 sysdeps/sw_64/htonl.S
 create mode 100644 sysdeps/sw_64/htons.S
 create mode 100644 sysdeps/sw_64/include/_sw7mc_math_def.h
 create mode 100644 sysdeps/sw_64/include/_sw7mc_regdef.h
 create mode 100644 sysdeps/sw_64/include/test_numdouble.h
 create mode 100644 sysdeps/sw_64/include/test_numfloat.h
 create mode 100644 sysdeps/sw_64/jmpbuf-offsets.h
 create mode 100644 sysdeps/sw_64/jmpbuf-unwind.h
 create mode 100644 sysdeps/sw_64/ldiv.S
 create mode 100644 sysdeps/sw_64/ldsodefs.h
 create mode 100644 sysdeps/sw_64/libc-tls.c
 create mode 100644 sysdeps/sw_64/lldiv.S
 create mode 100644 sysdeps/sw_64/local-soft-fp.h
 create mode 100644 sysdeps/sw_64/lshift.S
 create mode 100644 sysdeps/sw_64/machine-gmon.h
 create mode 100644 sysdeps/sw_64/memchr.c
 create mode 100644 sysdeps/sw_64/memset.S
 create mode 100644 sysdeps/sw_64/memusage.h
 create mode 100644 sysdeps/sw_64/mul_1.S
 create mode 100644 sysdeps/sw_64/nptl/bits/struct_rwlock.h
 create mode 100644 sysdeps/sw_64/nptl/pthread-offsets.h
 create mode 100644 sysdeps/sw_64/nptl/pthread_spin_lock.S
 create mode 100644 sysdeps/sw_64/nptl/pthread_spin_trylock.S
 create mode 100644 sysdeps/sw_64/nptl/pthreaddef.h
 create mode 100644 sysdeps/sw_64/nptl/tls.h
 create mode 100644 sysdeps/sw_64/nscd-types.h
 create mode 100644 sysdeps/sw_64/ots_add.c
 create mode 100644 sysdeps/sw_64/ots_cmp.c
 create mode 100644 sysdeps/sw_64/ots_cmpe.c
 create mode 100644 sysdeps/sw_64/ots_cvtqux.c
 create mode 100644 sysdeps/sw_64/ots_cvtqx.c
 create mode 100644 sysdeps/sw_64/ots_cvttx.c
 create mode 100644 sysdeps/sw_64/ots_cvtxq.c
 create mode 100644 sysdeps/sw_64/ots_cvtxt.c
 create mode 100644 sysdeps/sw_64/ots_div.c
 create mode 100644 sysdeps/sw_64/ots_mul.c
 create mode 100644 sysdeps/sw_64/ots_nintxq.c
 create mode 100644 sysdeps/sw_64/ots_sub.c
 create mode 100644 sysdeps/sw_64/preconfigure
 create mode 100644 sysdeps/sw_64/rawmemchr.S
 create mode 100644 sysdeps/sw_64/reml.S
 create mode 100644 sysdeps/sw_64/remlu.S
 create mode 100644 sysdeps/sw_64/remq.S
 create mode 100644 sysdeps/sw_64/remqu.S
 create mode 100644 sysdeps/sw_64/rshift.S
 create mode 100644 sysdeps/sw_64/setjmp.S
 create mode 100644 sysdeps/sw_64/sfp-machine.h
 create mode 100644 sysdeps/sw_64/sotruss-lib.c
 create mode 100644 sysdeps/sw_64/stackinfo.h
 create mode 100644 sysdeps/sw_64/start.S
 create mode 100644 sysdeps/sw_64/stpcpy.S
 create mode 100644 sysdeps/sw_64/stpncpy.S
 create mode 100644 sysdeps/sw_64/strcat.S
 create mode 100644 sysdeps/sw_64/strchr.S
 create mode 100644 sysdeps/sw_64/strcmp.S
 create mode 100644 sysdeps/sw_64/strcpy.S
 create mode 100644 sysdeps/sw_64/strlen.S
 create mode 100644 sysdeps/sw_64/strncat.S
 create mode 100644 sysdeps/sw_64/strncmp.S
 create mode 100644 sysdeps/sw_64/strncpy.S
 create mode 100644 sysdeps/sw_64/strrchr.S
 create mode 100644 sysdeps/sw_64/stxcpy.S
 create mode 100644 sysdeps/sw_64/stxncpy.S
 create mode 100644 sysdeps/sw_64/sub_n.S
 create mode 100644 sysdeps/sw_64/submul_1.S
 create mode 100644 sysdeps/sw_64/sw6a/Implies
 create mode 100644 sysdeps/sw_64/sw6a/add_n.S
 create mode 100644 sysdeps/sw_64/sw6a/addmul_1.S
 create mode 100644 sysdeps/sw_64/sw6a/lshift.S
 create mode 100644 sysdeps/sw_64/sw6a/memcpy.S
 create mode 100644 sysdeps/sw_64/sw6a/memset.S
 create mode 100644 sysdeps/sw_64/sw6a/rshift.S
 create mode 100644 sysdeps/sw_64/sw6a/stxcpy.S
 create mode 100644 sysdeps/sw_64/sw6a/stxncpy.S
 create mode 100644 sysdeps/sw_64/sw6a/sub_n.S
 create mode 100644 sysdeps/sw_64/sw6b/Implies
 create mode 100644 sysdeps/sw_64/sw6b/add_n.S
 create mode 100644 sysdeps/sw_64/sw6b/addmul_1.S
 create mode 100644 sysdeps/sw_64/sw6b/lshift.S
 create mode 100644 sysdeps/sw_64/sw6b/memcpy.S
 create mode 100644 sysdeps/sw_64/sw6b/memset.S
 create mode 100644 sysdeps/sw_64/sw6b/rshift.S
 create mode 100644 sysdeps/sw_64/sw6b/stxcpy.S
 create mode 100644 sysdeps/sw_64/sw6b/stxncpy.S
 create mode 100644 sysdeps/sw_64/sw6b/sub_n.S
 create mode 100644 sysdeps/sw_64/sw8a/Implies
 create mode 100644 sysdeps/sw_64/sw8a/add_n.S
 create mode 100644 sysdeps/sw_64/sw8a/addmul_1.S
 create mode 100644 sysdeps/sw_64/sw8a/atomic-machine.h
 create mode 100644 sysdeps/sw_64/sw8a/lshift.S
 create mode 100644 sysdeps/sw_64/sw8a/memcpy.S
 create mode 100644 sysdeps/sw_64/sw8a/memmove.S
 create mode 100644 sysdeps/sw_64/sw8a/memset.S
 create mode 100644 sysdeps/sw_64/sw8a/nptl/Makefile
 create mode 100644 sysdeps/sw_64/sw8a/nptl/bits/struct_rwlock.h
 create mode 100644 sysdeps/sw_64/sw8a/nptl/pthread-offsets.h
 create mode 100644 sysdeps/sw_64/sw8a/nptl/pthread_spin_lock.S
 create mode 100644 sysdeps/sw_64/sw8a/nptl/pthread_spin_trylock.S
 create mode 100644 sysdeps/sw_64/sw8a/nptl/pthreaddef.h
 create mode 100644 sysdeps/sw_64/sw8a/nptl/tcb-offsets.sym
 create mode 100644 sysdeps/sw_64/sw8a/nptl/tls.h
 create mode 100644 sysdeps/sw_64/sw8a/rshift.S
 create mode 100644 sysdeps/sw_64/sw8a/strcat.S
 create mode 100644 sysdeps/sw_64/sw8a/strchr.S
 create mode 100644 sysdeps/sw_64/sw8a/strcmp.S
 create mode 100644 sysdeps/sw_64/sw8a/strlen.S
 create mode 100644 sysdeps/sw_64/sw8a/strncat.S
 create mode 100644 sysdeps/sw_64/sw8a/strncmp.S
 create mode 100644 sysdeps/sw_64/sw8a/stxcpy.S
 create mode 100644 sysdeps/sw_64/sw8a/stxncpy.S
 create mode 100644 sysdeps/sw_64/sw8a/sub_n.S
 create mode 100644 sysdeps/sw_64/tininess.h
 create mode 100644 sysdeps/sw_64/tls-macros.h
 create mode 100644 sysdeps/sw_64/tst-audit.h
 create mode 100644 sysdeps/sw_64/tst-file-align.h
 create mode 100644 sysdeps/sw_64/udiv_qrnnd.S
 create mode 100644 sysdeps/sw_64/unwind-arch.h
 create mode 100644 sysdeps/unix/sw_64/Makefile
 create mode 100644 sysdeps/unix/sw_64/pipe.S
 create mode 100644 sysdeps/unix/sw_64/rt-sysdep.S
 create mode 100644 sysdeps/unix/sw_64/sysdep.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/Implies
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/Makefile
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/Versions
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/____longjmp_chk.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/a.out.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/adjtime.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/adjtimex.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/aio_cancel.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/arch-syscall.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/a.out.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/dirent.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/elfclass.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/epoll.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/errno.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/eventfd.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/fcntl.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/inotify.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/ioctls.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/mman.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/netdb.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/procfs-prregset.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/procfs.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/pthread_stack_min.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/resource.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/sigaction.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/signalfd.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/signum-arch.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/sigstack.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/socket-constants.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/socket_type.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/statfs.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/struct_stat.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/termios-baud.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cc.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cflag.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/termios-c_iflag.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/termios-c_lflag.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/termios-c_oflag.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/termios-struct.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/timerfd.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/typesizes.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/bits/wordsize.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/brk_call.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/c++-types.data
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/clone.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/configure
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/configure.ac
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/dl-auxv.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/dl-support.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/dl-sysdep.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/errlist-compat.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/fpu/Implies
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/fraiseexcpt.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/fstatfs.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/fxstat64.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/fxstatat64.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/getclktck.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/getcontext.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/getdents.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/getdents64.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/getegid.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/geteuid.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/gethostname.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/getppid.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/getrlimit64.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/gettimeofday.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/glob-lstat-compat.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/globfree.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/ieee_get_fp_control.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/ieee_set_fp_control.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/ioperm.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/ipc_priv.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/jmp_buf-macros.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/kernel-features.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/kernel_rt_sigframe.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/kernel_sigaction.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/kernel_stat.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/kernel_sysinfo.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/kernel_termios.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/ld.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libBrokenLocale.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libanl.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libc.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libc_malloc_debug.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libcrypt.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libdl.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libm.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libnsl.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libpthread.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libresolv.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/librt-compat.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/librt.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libthread_db.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/libutil.abilist
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/localplt.data
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/lxstat64.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/makecontext.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/nldbl-abi.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/oldglob.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_adjtime.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_getitimer.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_getrusage.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_gettimeofday.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_setitimer.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_settimeofday.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_utimes.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/osf_wait4.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/pipe.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/pointer_guard.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/register-dump.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/rt_sigaction.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/select.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/setcontext.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/setfpucw.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/setrlimit64.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/settimeofday.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/shlib-versions
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sigcontextinfo.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sizes.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/statfs.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sw6a/fpu/Implies
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sw6b/fpu/Implies
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sw8a/fpu/Implies
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sw_64/ptrace.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sw_64/regdef.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/swapcontext.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sys/acct.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sys/io.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sys/ucontext.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sys/user.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/syscall.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/syscalls.list
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sysconf.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/sysdep.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/timer_t_was_int_compat.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/ucontext-offsets.sym
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/vfork.S
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/wait4.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/wordexp.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/xstat64.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/xstatconv.c
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/xstatconv.h
 create mode 100644 sysdeps/unix/sysv/linux/sw_64/xstatver.h

diff --git a/elf/elf.h b/elf/elf.h
index d623bdeb..1c287696 100644
--- a/elf/elf.h
+++ b/elf/elf.h
@@ -196,6 +196,7 @@ typedef struct
 #define EM_RCE		39	/* Motorola RCE */
 #define EM_ARM		40	/* ARM */
 #define EM_FAKE_ALPHA	41	/* Digital Alpha */
+#define EM_FAKE_SW_64   260 /* Digital SW_64 */
 #define EM_SH		42	/* Hitachi SH */
 #define EM_SPARCV9	43	/* SPARC v9 64-bit */
 #define EM_TRICORE	44	/* Siemens Tricore */
@@ -371,6 +372,10 @@ typedef struct
    chances of collision with official or non-GNU unofficial values.  */
 
 #define EM_ALPHA	0x9026
+#define EM_SW_64        0x9916
+
+
+
 
 /* Legal values for e_version (version).  */
 
@@ -2426,6 +2431,80 @@ enum
 /* Legal values for d_tag of Elf64_Dyn.  */
 #define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
 #define DT_ALPHA_NUM		1
+/* SW_64 specific definitions.  */
+
+/* Legal values for e_flags field of Elf64_Ehdr.  */
+
+#define EF_SW_64_32BIT          1       /* All addresses must be < 2GB.  */
+#define EF_SW_64_CANRELAX       2       /* Relocations for relaxing exist.  */
+
+/* Legal values for sh_type field of Elf64_Shdr.  */
+
+/* These two are primerily concerned with ECOFF debugging info.  */
+#define SHT_SW_64_DEBUG         0x70000001
+#define SHT_SW_64_REGINFO       0x70000002
+
+/* Legal values for sh_flags field of Elf64_Shdr.  */
+
+#define SHF_SW_64_GPREL         0x10000000
+
+/* Legal values for st_other field of Elf64_Sym.  */
+#define STO_SW_64_NOPV          0x80    /* No PV required.  */
+#define STO_SW_64_STD_GPLOAD    0x88    /* PV only used for initial ldgp.  */
+
+/* SW_64 relocs.  */
+
+#define R_SW_64_NONE            0       /* No reloc */
+#define R_SW_64_REFLONG         1       /* Direct 32 bit */
+#define R_SW_64_REFQUAD         2       /* Direct 64 bit */
+#define R_SW_64_GPREL32         3       /* GP relative 32 bit */
+#define R_SW_64_LITERAL         4       /* GP relative 16 bit w/optimization */
+#define R_SW_64_LITUSE          5       /* Optimization hint for LITERAL */
+#define R_SW_64_GPDISP          6       /* Add displacement to GP */
+#define R_SW_64_BRADDR          7       /* PC+4 relative 23 bit shifted */
+#define R_SW_64_HINT            8       /* PC+4 relative 16 bit shifted */
+#define R_SW_64_SREL16          9       /* PC relative 16 bit */
+#define R_SW_64_SREL32          10      /* PC relative 32 bit */
+#define R_SW_64_SREL64          11      /* PC relative 64 bit */
+#define R_SW_64_GPRELHIGH       17      /* GP relative 32 bit, high 16 bits */
+#define R_SW_64_GPRELLOW        18      /* GP relative 32 bit, low 16 bits */
+#define R_SW_64_GPREL16         19      /* GP relative 16 bit */
+#define R_SW_64_COPY            24      /* Copy symbol at runtime */
+#define R_SW_64_GLOB_DAT        25      /* Create GOT entry */
+#define R_SW_64_JMP_SLOT        26      /* Create PLT entry */
+#define R_SW_64_RELATIVE        27      /* Adjust by program base */
+#define R_SW_64_TLS_GD_HI       28
+#define R_SW_64_TLSGD           29
+#define R_SW_64_TLS_LDM         30
+#define R_SW_64_DTPMOD64        31
+#define R_SW_64_GOTDTPREL       32
+#define R_SW_64_DTPREL64        33
+#define R_SW_64_DTPRELHI        34
+#define R_SW_64_DTPRELLO        35
+#define R_SW_64_DTPREL16        36
+#define R_SW_64_GOTTPREL        37
+#define R_SW_64_TPREL64         38
+#define R_SW_64_TPRELHI         39
+#define R_SW_64_TPRELLO         40
+#define R_SW_64_TPREL16         41
+/* Keep this the last entry.  */
+#define R_SW_64_NUM             46
+
+/* Magic values of the LITUSE relocation addend.  */
+#define LITUSE_SW_64_ADDR       0
+#define LITUSE_SW_64_BASE       1
+#define LITUSE_SW_64_BYTOFF     2
+#define LITUSE_SW_64_JSR        3
+#define LITUSE_SW_64_TLS_GD     4
+#define LITUSE_SW_64_TLS_LDM    5
+
+/* Legal values for d_tag of Elf64_Dyn.  */
+#define DT_SW_64_PLTRO          (DT_LOPROC + 0)
+#define DT_SW_64_NUM            1
+
+
+
+
 
 /* PowerPC specific declarations */
 
diff --git a/elf/tst-glibcelf.py b/elf/tst-glibcelf.py
index 6142ca28..f078e78c 100644
--- a/elf/tst-glibcelf.py
+++ b/elf/tst-glibcelf.py
@@ -170,6 +170,7 @@ DT_ADDRNUM
 DT_ADDRRNGHI
 DT_ADDRRNGLO
 DT_ALPHA_NUM
+DT_SW_64_NUM
 DT_ENCODING
 DT_EXTRANUM
 DT_HIOS
diff --git a/posix/tst-glob_lstat_compat.c b/posix/tst-glob_lstat_compat.c
index 65599542..4c37be09 100644
--- a/posix/tst-glob_lstat_compat.c
+++ b/posix/tst-glob_lstat_compat.c
@@ -36,7 +36,7 @@ __typeof (glob) glob;
 /* On alpha glob exists in version GLIBC_2_0, GLIBC_2_1, and GLIBC_2_27.
    This test needs to access the version prior to GLIBC_2_27, which is
    GLIBC_2_1 on alpha, GLIBC_2_0 elsewhere.  */
-#ifdef __alpha__
+#if defined __alpha__ || defined  __sw_64__
 compat_symbol_reference (libc, glob, glob, GLIBC_2_1);
 #else
 compat_symbol_reference (libc, glob, glob, GLIBC_2_0);
diff --git a/scripts/glibcelf.py b/scripts/glibcelf.py
index b52e83d6..2c191afa 100644
--- a/scripts/glibcelf.py
+++ b/scripts/glibcelf.py
@@ -304,6 +304,8 @@ class Sht(_TypedConstant):
     prefix = 'SHT_'
 class ShtALPHA(Sht):
     """Supplemental SHT_* constants for EM_ALPHA."""
+class ShtSW_64(Sht):
+    """Supplemental SHT_* constants for EM_SW_64."""
 class ShtARC(Sht):
     """Supplemental SHT_* constants for EM_ARC."""
 class ShtARM(Sht):
@@ -319,6 +321,7 @@ class ShtPARISC(Sht):
 class ShtRISCV(Sht):
     """Supplemental SHT_* constants for EM_RISCV."""
 _register_elf_h(ShtALPHA, prefix='SHT_ALPHA_', parent=Sht)
+_register_elf_h(ShtSW_64, prefix='SHT_SW_64_', parent=Sht)
 _register_elf_h(ShtARC, prefix='SHT_ARC_', parent=Sht)
 _register_elf_h(ShtARM, prefix='SHT_ARM_', parent=Sht)
 _register_elf_h(ShtCSKY, prefix='SHT_CSKY_', parent=Sht)
@@ -354,6 +357,8 @@ class Shf(_FlagConstant):
     prefix = 'SHF_'
 class ShfALPHA(Shf):
     """Supplemental SHF_* constants for EM_ALPHA."""
+class ShfSW_64(Shf):
+    """Supplemental SHF_* constants for EM_SW_64."""
 class ShfARM(Shf):
     """Supplemental SHF_* constants for EM_ARM."""
 class ShfIA_64(Shf):
@@ -363,6 +368,7 @@ class ShfMIPS(Shf):
 class ShfPARISC(Shf):
     """Supplemental SHF_* constants for EM_PARISC."""
 _register_elf_h(ShfALPHA, prefix='SHF_ALPHA_', parent=Shf)
+_register_elf_h(ShfSW_64, prefix='SHF_SW_64_', parent=Shf)
 _register_elf_h(ShfARM, prefix='SHF_ARM_', parent=Shf)
 _register_elf_h(ShfIA_64, prefix='SHF_IA_64_', parent=Shf)
 _register_elf_h(ShfMIPS, prefix='SHF_MIPS_', parent=Shf)
@@ -425,6 +431,8 @@ class DtAARCH64(Dt):
     """Supplemental DT_* constants for EM_AARCH64."""
 class DtALPHA(Dt):
     """Supplemental DT_* constants for EM_ALPHA."""
+class DtSW_64(Dt):
+    """Supplemental DT_* constants for EM_SW_64."""
 class DtALTERA_NIOS2(Dt):
     """Supplemental DT_* constants for EM_ALTERA_NIOS2."""
 class DtIA_64(Dt):
@@ -446,6 +454,7 @@ DT_VALRNGLO DT_VALRNGHI DT_VALNUM
 DT_VERSIONTAGNUM DT_EXTRANUM
 DT_AARCH64_NUM
 DT_ALPHA_NUM
+DT_SW_64_NUM
 DT_IA_64_NUM
 DT_MIPS_NUM
 DT_PPC_NUM
@@ -454,6 +463,7 @@ DT_SPARC_NUM
 '''.strip().split()
 _register_elf_h(DtAARCH64, prefix='DT_AARCH64_', skip=_dt_skip, parent=Dt)
 _register_elf_h(DtALPHA, prefix='DT_ALPHA_', skip=_dt_skip, parent=Dt)
+_register_elf_h(DtSW_64, prefix='DT_SW_64_', skip=_dt_skip, parent=Dt)
 _register_elf_h(DtALTERA_NIOS2, prefix='DT_NIOS2_', skip=_dt_skip, parent=Dt)
 _register_elf_h(DtIA_64, prefix='DT_IA_64_', skip=_dt_skip, parent=Dt)
 _register_elf_h(DtMIPS, prefix='DT_MIPS_', skip=_dt_skip, parent=Dt)
diff --git a/sysdeps/sw_64/Implies b/sysdeps/sw_64/Implies
new file mode 100644
index 00000000..f1566581
--- /dev/null
+++ b/sysdeps/sw_64/Implies
@@ -0,0 +1,5 @@
+wordsize-64
+# Sw_64 uses IEEE 754 single, double and quad precision floating point.
+ieee754/ldbl-128
+ieee754/dbl-64
+ieee754/flt-32
diff --git a/sysdeps/sw_64/Makefile b/sysdeps/sw_64/Makefile
new file mode 100644
index 00000000..657cc08c
--- /dev/null
+++ b/sysdeps/sw_64/Makefile
@@ -0,0 +1,70 @@
+# Copyright (C) 1993-2021 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+# Contributed by Brendan Kehoe (brendan@zen.org).
+
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library.  If not, see
+# <https://www.gnu.org/licenses/>.
+
+ifeq ($(subdir),db2)
+CPPFLAGS += -DHAVE_SPINLOCKS=1 -DHAVE_ASSEM_SW_64=1
+endif
+
+ifeq ($(subdir),debug)
+# Consider making this GCC's default...
+CFLAGS-backtrace.c = -fasynchronous-unwind-tables
+endif
+
+ifeq ($(subdir),gmon)
+sysdep_routines += _mcount
+endif
+
+ifeq ($(subdir),gnulib)
+sysdep_routines += divl divlu divq divqu reml remlu remq remqu
+endif
+
+ifeq ($(subdir),string)
+sysdep_routines += stxcpy stxncpy
+endif
+
+ifeq ($(subdir),elf)
+# The ld.so startup code cannot use literals until it self-relocates.
+CFLAGS-rtld.c = -mbuild-constants
+endif
+
+ifeq ($(subdir),math)
+# The fma routines rely on inexact being raised for correct results.
+CFLAGS-s_fma.c = -mieee-with-inexact
+CFLAGS-s_fmaf.c = -mieee-with-inexact
+# This test tries to check for inexact being raised by arithmetic.
+CFLAGS-test-misc.c += -mieee-with-inexact
+# Avoid "conflicting types for built-in function" warnings
+CFLAGS-s_isnan.c += -fno-builtin-isnanf
+endif
+
+# Build everything with full IEEE math support, and with dynamic rounding;
+# there are a number of math routines that are defined to work with the
+# "current" rounding mode, and it's easiest to set this with all of them.
+sysdep-CFLAGS += -mieee -mfp-rounding-mode=d
+
+#  Software floating-point emulation.
+
+ifeq ($(subdir),soft-fp)
+sysdep_routines += ots_add ots_sub ots_mul ots_div ots_cmp ots_cmpe	\
+	ots_cvtxq ots_cvtqx ots_cvtqux ots_cvttx ots_cvtxt ots_nintxq	\
+	fraiseexcpt
+endif
+
+ifeq ($(subdir),math)
+CPPFLAGS += -I../soft-fp
+endif
diff --git a/sysdeps/sw_64/Subdirs b/sysdeps/sw_64/Subdirs
new file mode 100644
index 00000000..87eadf30
--- /dev/null
+++ b/sysdeps/sw_64/Subdirs
@@ -0,0 +1 @@
+soft-fp
diff --git a/sysdeps/sw_64/Versions b/sysdeps/sw_64/Versions
new file mode 100644
index 00000000..85ac8e80
--- /dev/null
+++ b/sysdeps/sw_64/Versions
@@ -0,0 +1,23 @@
+libc {
+  GLIBC_2.0 {
+    # functions with special/multiple interfaces
+    __divlu; __remlu; __divls; __remls; __divwu; __remwu; __divws;
+    __remws; __divw; __remw; __divl; __reml; __divlu; __remlu;
+  }
+  GLIBC_2.3.4 {
+    _OtsAddX; _OtsSubX; _OtsMulX; _OtsDivX;
+    _OtsEqlX; _OtsNeqX; _OtsLssX; _OtsLeqX; _OtsGtrX; _OtsGeqX;
+    _OtsCvtQX; _OtsCvtQUX; _OtsCvtXQ; _OtsNintXQ;
+    _OtsConvertFloatTX; _OtsConvertFloatXT;
+  }
+}
+libm {
+  GLIBC_2.0 {
+    # used in inline functions.
+    __atan2;
+  }
+  GLIBC_2.18 {
+    # forgotten when the symbols were added to glibc 2.15 for other targets
+    __sqrt_finite; __sqrtf_finite; __sqrtl_finite;
+  }
+}
diff --git a/sysdeps/sw_64/__longjmp.S b/sysdeps/sw_64/__longjmp.S
new file mode 100644
index 00000000..0a82a01b
--- /dev/null
+++ b/sysdeps/sw_64/__longjmp.S
@@ -0,0 +1,64 @@
+/* Copyright (C) 1992-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ASSEMBLY__
+
+#include <sysdep.h>
+#include <pointer_guard.h>
+#include <jmpbuf-offsets.h>
+
+
+ENTRY(__longjmp)
+#ifdef PROF
+	ldgp    gp, 0(pv)
+	.set noat
+	ldi     AT, _mcount
+	call     AT, (AT), _mcount
+	.set at
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	mov     a1, v0
+	ldl     s0, JB_S0*8(a0)
+	ldl     s1, JB_S1*8(a0)
+	ldl     s2, JB_S2*8(a0)
+	ldl     s3, JB_S3*8(a0)
+	ldl     s4, JB_S4*8(a0)
+	ldl     s5, JB_S5*8(a0)
+	ldl     ra, JB_PC*8(a0)
+	ldl     fp, JB_FP*8(a0)
+	ldl     t0, JB_SP*8(a0)
+	fldd     $f2, JB_F2*8(a0)
+	fldd     $f3, JB_F3*8(a0)
+	fldd     $f4, JB_F4*8(a0)
+	fldd     $f5, JB_F5*8(a0)
+	fldd     $f6, JB_F6*8(a0)
+	fldd     $f7, JB_F7*8(a0)
+	fldd     $f8, JB_F8*8(a0)
+	fldd     $f9, JB_F9*8(a0)
+#ifdef PTR_DEMANGLE
+	PTR_DEMANGLE(ra, t1)
+	PTR_DEMANGLE2(t0, t1)
+	PTR_DEMANGLE2(fp, t1)
+#endif
+	seleq  v0, 1, v0, v0
+	mov     t0, sp
+	ret
+
+END(__longjmp)
diff --git a/sysdeps/sw_64/_mcount.S b/sysdeps/sw_64/_mcount.S
new file mode 100644
index 00000000..38b415b1
--- /dev/null
+++ b/sysdeps/sw_64/_mcount.S
@@ -0,0 +1,105 @@
+/* Machine-specific calling sequence for `mcount' profiling function.  sw_64
+   Copyright (C) 1995-2018 Free Software Foundation, Inc.
+   Contributed by David Mosberger (davidm@cs.arizona.edu).
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Assembly stub to invoke _mcount().  Compiler generated code calls
+   this stub after executing a function's prologue and without saving any
+   registers.  It is therefore necessary to preserve a0..a5 as they may
+   contain function arguments.  To work correctly with frame- less
+   functions, it is also necessary to preserve ra.  Finally, division
+   routines are invoked with a special calling convention and the
+   compiler treats those calls as if they were instructions.  In
+   particular, it doesn't save any of the temporary registers (caller
+   saved registers).  It is therefore necessary to preserve all
+   caller-saved registers as well.
+
+   Upon entering _mcount, register $at hoflds the return address and ra
+   hoflds the return address of the function's caller (selfpc and frompc,
+   respectively in gmon.c language...). */
+
+#include <sysdep.h>
+
+	.set	noat
+	.set	noreorder
+
+LEAF(_mcount, 0xb0)
+	subl	 sp, 0xb0, sp
+	.prologue 0
+	stl	 a0, 0x00(sp)
+	mov	 ra, a0		# a0 = caller-pc
+	stl	 a1, 0x08(sp)
+	mov	$at, a1		# a1 = self-pc
+	stl	$at, 0x10(sp)
+
+	stl	 a2, 0x18(sp)
+	stl	 a3, 0x20(sp)
+	stl	 a4, 0x28(sp)
+	stl	 a5, 0x30(sp)
+	stl	 ra, 0x38(sp)
+	stl	 gp, 0x40(sp)
+
+	br	gp, 1f
+1:	ldgp	gp, 0(gp)
+
+	stl	 t0, 0x48(sp)
+	stl	 t1, 0x50(sp)
+	stl	 t2, 0x58(sp)
+	stl	 t3, 0x60(sp)
+	stl	 t4, 0x68(sp)
+	stl	 t5, 0x70(sp)
+	stl	 t6, 0x78(sp)
+
+	stl	 t7, 0x80(sp)
+	stl	 t8, 0x88(sp)
+	stl	 t9, 0x90(sp)
+	stl	t10, 0x98(sp)
+	stl	t11, 0xa0(sp)
+	stl	 v0, 0xa8(sp)
+
+	call	ra, __mcount
+
+	ldl	 a0, 0x00(sp)
+	ldl	 a1, 0x08(sp)
+	ldl	$at, 0x10(sp)	# restore self-pc
+	ldl	 a2, 0x18(sp)
+	ldl	 a3, 0x20(sp)
+	ldl	 a4, 0x28(sp)
+	ldl	 a5, 0x30(sp)
+	ldl	 ra, 0x38(sp)
+	ldl	 gp, 0x40(sp)
+	mov	$at, pv		# make pv point to return address
+	ldl	 t0, 0x48(sp)	# this is important under OSF/1 to
+	ldl	 t1, 0x50(sp)	# ensure that the code that we return
+	ldl	 t2, 0x58(sp)	# can correctly compute its gp
+	ldl	 t3, 0x60(sp)
+	ldl	 t4, 0x68(sp)
+	ldl	 t5, 0x70(sp)
+	ldl	 t6, 0x78(sp)
+	ldl	 t7, 0x80(sp)
+	ldl	 t8, 0x88(sp)
+	ldl	 t9, 0x90(sp)
+	ldl	t10, 0x98(sp)
+	ldl	t11, 0xa0(sp)
+	ldl	 v0, 0xa8(sp)
+
+	addl	sp, 0xb0, sp
+	ret	zero,($at),1
+
+	END(_mcount)
+
+weak_alias (_mcount, mcount)
diff --git a/sysdeps/sw_64/add_n.S b/sysdeps/sw_64/add_n.S
new file mode 100644
index 00000000..81cff568
--- /dev/null
+++ b/sysdeps/sw_64/add_n.S
@@ -0,0 +1,118 @@
+ # Sw_64 __mpn_add_n -- Add two limb vectors of the same length > 0 and
+ # store sum in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_add_n
+	.ent	__mpn_add_n
+__mpn_add_n:
+	.frame	$30,0,$26,0
+
+	ldl	$3,0($17)
+	ldl	$4,0($18)
+
+	subl	$19,1,$19
+	and	$19,4-1,$2	# number of limbs in first loop
+	bis	$31,$31,$0
+	beq	$2,.L0		# if fmuldiple of 4 limbs, skip first loop
+
+	subl	$19,$2,$19
+
+.Loop0:	subl	$2,1,$2
+	ldl	$5,8($17)
+	addl	$4,$0,$4
+	ldl	$6,8($18)
+	cmpult	$4,$0,$1
+	addl	$3,$4,$4
+	cmpult	$4,$3,$0
+	stl	$4,0($16)
+	or	$0,$1,$0
+
+	addl	$17,8,$17
+	addl	$18,8,$18
+	bis	$5,$5,$3
+	bis	$6,$6,$4
+	addl	$16,8,$16
+	bne	$2,.Loop0
+
+.L0:	beq	$19,.Lend
+
+	.align	3
+.Loop:	subl	$19,4,$19
+
+	ldl	$5,8($17)
+	addl	$4,$0,$4
+	ldl	$6,8($18)
+	cmpult	$4,$0,$1
+	addl	$3,$4,$4
+	cmpult	$4,$3,$0
+	stl	$4,0($16)
+	or	$0,$1,$0
+
+	ldl	$3,16($17)
+	addl	$6,$0,$6
+	ldl	$4,16($18)
+	cmpult	$6,$0,$1
+	addl	$5,$6,$6
+	cmpult	$6,$5,$0
+	stl	$6,8($16)
+	or	$0,$1,$0
+
+	ldl	$5,24($17)
+	addl	$4,$0,$4
+	ldl	$6,24($18)
+	cmpult	$4,$0,$1
+	addl	$3,$4,$4
+	cmpult	$4,$3,$0
+	stl	$4,16($16)
+	or	$0,$1,$0
+
+	ldl	$3,32($17)
+	addl	$6,$0,$6
+	ldl	$4,32($18)
+	cmpult	$6,$0,$1
+	addl	$5,$6,$6
+	cmpult	$6,$5,$0
+	stl	$6,24($16)
+	or	$0,$1,$0
+
+	addl	$17,32,$17
+	addl	$18,32,$18
+	addl	$16,32,$16
+	bne	$19,.Loop
+
+.Lend:	addl	$4,$0,$4
+	cmpult	$4,$0,$1
+	addl	$3,$4,$4
+	cmpult	$4,$3,$0
+	stl	$4,0($16)
+	or	$0,$1,$0
+	ret	$31,($26),1
+
+	.end	__mpn_add_n
diff --git a/sysdeps/sw_64/addmul_1.S b/sysdeps/sw_64/addmul_1.S
new file mode 100644
index 00000000..f048960a
--- /dev/null
+++ b/sysdeps/sw_64/addmul_1.S
@@ -0,0 +1,90 @@
+ # Sw_64 1621 __mpn_addmul_1 -- Multiply a limb vector with a limb and add
+ # the result to a second limb vector.
+
+ # Copyright (C) 1992-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # s2_limb	r19
+
+ # This code runs at 42 cycles/limb on EV4 and 18 cycles/limb on EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_addmul_1
+	.ent	__mpn_addmul_1 2
+__mpn_addmul_1:
+	.frame	$30,0,$26
+
+	ldl	$2,0($17)	# $2 = s1_limb
+	addl	$17,8,$17	# s1_ptr++
+	subl	$18,1,$18	# size--
+	mull	$2,$19,$3	# $3 = prod_low
+	ldl	$5,0($16)	# $5 = *res_ptr
+	umulh	$2,$19,$0	# $0 = prod_high
+	beq	$18,.Lend1	# jump if size was == 1
+	ldl	$2,0($17)	# $2 = s1_limb
+	addl	$17,8,$17	# s1_ptr++
+	subl	$18,1,$18	# size--
+	addl	$5,$3,$3
+	cmpult	$3,$5,$4
+	stl	$3,0($16)
+	addl	$16,8,$16	# res_ptr++
+	beq	$18,.Lend2	# jump if size was == 2
+
+	.align	3
+.Loop:	mull	$2,$19,$3	# $3 = prod_low
+	ldl	$5,0($16)	# $5 = *res_ptr
+	addl	$4,$0,$0	# cy_limb = cy_limb + 'cy'
+	subl	$18,1,$18	# size--
+	umulh	$2,$19,$4	# $4 = cy_limb
+	ldl	$2,0($17)	# $2 = s1_limb
+	addl	$17,8,$17	# s1_ptr++
+	addl	$3,$0,$3	# $3 = cy_limb + prod_low
+	cmpult	$3,$0,$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,$3,$3
+	cmpult	$3,$5,$5
+	stl	$3,0($16)
+	addl	$16,8,$16	# res_ptr++
+	addl	$5,$0,$0	# combine carries
+	bne	$18,.Loop
+
+.Lend2:	mull	$2,$19,$3	# $3 = prod_low
+	ldl	$5,0($16)	# $5 = *res_ptr
+	addl	$4,$0,$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,$19,$4	# $4 = cy_limb
+	addl	$3,$0,$3	# $3 = cy_limb + prod_low
+	cmpult	$3,$0,$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,$3,$3
+	cmpult	$3,$5,$5
+	stl	$3,0($16)
+	addl	$5,$0,$0	# combine carries
+	addl	$4,$0,$0	# cy_limb = prod_high + cy
+	ret	$31,($26),1
+.Lend1:	addl	$5,$3,$3
+	cmpult	$3,$5,$5
+	stl	$3,0($16)
+	addl	$0,$5,$0
+	ret	$31,($26),1
+
+	.end	__mpn_addmul_1
diff --git a/sysdeps/sw_64/atomic-machine.h b/sysdeps/sw_64/atomic-machine.h
new file mode 100644
index 00000000..6a62301e
--- /dev/null
+++ b/sysdeps/sw_64/atomic-machine.h
@@ -0,0 +1,617 @@
+/* Copyright (C) 2003-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int16_t atomic16_t;
+typedef uint16_t uatomic16_t;
+typedef int_fast16_t atomic_fast16_t;
+typedef uint_fast16_t uatomic_fast16_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+#define __HAVE_64B_ATOMICS 1
+#define USE_ATOMIC_COMPILER_BUILTINS 0
+
+/* XXX Is this actually correct?  */
+#define ATOMIC_EXCHANGE_USES_CAS 1
+
+
+# define __MB		"	memb\n"   //HUANGLM20161018
+
+/* Compare and exchange.  For all of the "xxx" routines, we expect a
+   "__prev" and a "__cmp" variable to be provided by the enclosing scope,
+   in which values are returned.  */
+//delete memb after the rd_f by XWB20170510
+#define __arch_compare_and_exchange_xxx_8_int(mem, new, old, mb1, mb2)  \
+({                                                                      \
+  unsigned long __tmp, __snew, __addr64;                                \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       bic  %[__addr8],7,%[__addr64]\n"                        \
+        "       ins0b   %[__new],%[__addr8],%[__snew]\n"                \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       ext0b   %[__tmp],%[__addr8],%[__prev]\n"                \
+        "       cmpeq   %[__prev],%[__old],%[__cmp]\n"                  \
+        "       wr_f    %[__cmp]\n"                                     \
+        "       mask0b   %[__tmp],%[__addr8],%[__tmp]\n"                \
+        "       or      %[__snew],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       rd_f    %[__tmp]\n"                             	\
+        "       beq     %[__cmp],2f\n"                                  \
+        "       beq     %[__tmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__snew] "=&r" (__snew),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr8] "r" (mem),                                          \
+          [__old] "Ir" ((uint64_t)(uint8_t)(uint64_t)(old)),            \
+          [__new] "r" (new)                                             \
+        : "memory");                                                    \
+})
+/*
+#define __arch_compare_and_exchange_xxx_8_int(mem, new, old, mb1, mb2)	\
+({									\
+  unsigned long __tmp, __snew, __addr64;				\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"	bic	%[__addr8],7,%[__addr64]\n"			\
+	"	insbl	%[__new],%[__addr8],%[__snew]\n"		\
+	"1:	ldq_l	%[__tmp],0(%[__addr64])\n"			\
+	"	extbl	%[__tmp],%[__addr8],%[__prev]\n"		\
+	"	cmpeq	%[__prev],%[__old],%[__cmp]\n"			\
+	"	beq	%[__cmp],2f\n"					\
+	"	mskbl	%[__tmp],%[__addr8],%[__tmp]\n"			\
+	"	or	%[__snew],%[__tmp],%[__tmp]\n"			\
+	"	stq_c	%[__tmp],0(%[__addr64])\n"			\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	"2:"								\
+	: [__prev] "=&r" (__prev),					\
+	  [__snew] "=&r" (__snew),					\
+	  [__tmp] "=&r" (__tmp),					\
+	  [__cmp] "=&r" (__cmp),					\
+	  [__addr64] "=&r" (__addr64)					\
+	: [__addr8] "r" (mem),						\
+	  [__old] "Ir" ((uint64_t)(uint8_t)(uint64_t)(old)),		\
+	  [__new] "r" (new)						\
+	: "memory");							\
+})
+*/
+
+#define __arch_compare_and_exchange_xxx_16_int(mem, new, old, mb1, mb2) \
+({                                                                      \
+  unsigned long __tmp, __snew, __addr64;                                \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       bic  %[__addr16],7,%[__addr64]\n"                    	\
+        "       ins1b   %[__new],%[__addr16],%[__snew]\n"               \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       ext1b   %[__tmp],%[__addr16],%[__prev]\n"               \
+        "       cmpeq   %[__prev],%[__old],%[__cmp]\n"                  \
+        "       wr_f    %[__cmp]\n"                                     \
+        "       mask1b   %[__tmp],%[__addr16],%[__tmp]\n"               \
+        "       or      %[__snew],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       rd_f    %[__tmp]\n"                             	\
+        "       beq     %[__cmp],2f\n"                                  \
+        "       beq     %[__tmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__snew] "=&r" (__snew),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr16] "r" (mem),                                         \
+          [__old] "Ir" ((uint64_t)(uint16_t)(uint64_t)(old)),           \
+          [__new] "r" (new)                                             \
+        : "memory");                                                    \
+})
+/*
+#define __arch_compare_and_exchange_xxx_16_int(mem, new, old, mb1, mb2) \
+({									\
+  unsigned long __tmp, __snew, __addr64;				\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"	bic	%[__addr16],7,%[__addr64]\n"			\
+	"	inswl	%[__new],%[__addr16],%[__snew]\n"		\
+	"1:	ldq_l	%[__tmp],0(%[__addr64])\n"			\
+	"	extwl	%[__tmp],%[__addr16],%[__prev]\n"		\
+	"	cmpeq	%[__prev],%[__old],%[__cmp]\n"			\
+	"	beq	%[__cmp],2f\n"					\
+	"	mskwl	%[__tmp],%[__addr16],%[__tmp]\n"		\
+	"	or	%[__snew],%[__tmp],%[__tmp]\n"			\
+	"	stq_c	%[__tmp],0(%[__addr64])\n"			\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	"2:"								\
+	: [__prev] "=&r" (__prev),					\
+	  [__snew] "=&r" (__snew),					\
+	  [__tmp] "=&r" (__tmp),					\
+	  [__cmp] "=&r" (__cmp),					\
+	  [__addr64] "=&r" (__addr64)					\
+	: [__addr16] "r" (mem),						\
+	  [__old] "Ir" ((uint64_t)(uint16_t)(uint64_t)(old)),		\
+	  [__new] "r" (new)						\
+	: "memory");							\
+})*/
+/* HUANGLM20161018  */
+#define __arch_compare_and_exchange_xxx_32_int(mem, new, old, mb1, mb2) \
+({									\
+  unsigned long  __addr,__tmp;                                          \
+__asm__ __volatile__ (                                                  \
+                mb1                                                     \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldw    %[__prev],0(%[__addr])\n"                       \
+        "       cmpeq   %[__prev],%[__old],%[__tmp]\n"                  \
+        "       wr_f    %[__tmp]\n"                                     \
+        "       mov     %[__new],%[__cmp]\n"                            \
+        "       lstw    %[__cmp],0(%[__addr])\n"                        \
+        "       rd_f    %[__cmp]\n"                             	\
+        "       beq     %[__tmp],2f\n"                                  \
+        "       beq     %[__cmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__old] "Ir" ((uint64_t)(atomic32_t)(uint64_t)(old)),         \
+          [__new] "Ir" (new)                                            \
+        : "memory");                                                    \
+})
+/*
+#define __arch_compare_and_exchange_xxx_32_int(mem, new, old, mb1, mb2) \
+({									\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"1:	ldl_l	%[__prev],%[__mem]\n"				\
+	"	cmpeq	%[__prev],%[__old],%[__cmp]\n"			\
+	"	beq	%[__cmp],2f\n"					\
+	"	mov	%[__new],%[__cmp]\n"				\
+	"	stl_c	%[__cmp],%[__mem]\n"				\
+	"	beq	%[__cmp],1b\n"					\
+		mb2							\
+	"2:"								\
+	: [__prev] "=&r" (__prev),					\
+	  [__cmp] "=&r" (__cmp)						\
+	: [__mem] "m" (*(mem)),						\
+	  [__old] "Ir" ((uint64_t)(atomic32_t)(uint64_t)(old)),		\
+	  [__new] "Ir" (new)						\
+	: "memory");							\
+})                                                                      \ 
+*/
+
+#define __arch_compare_and_exchange_xxx_64_int(mem, new, old, mb1, mb2) \
+({                                                                      \
+  unsigned long  __addr,__tmp;                                          \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldl    %[__prev],0(%[__addr])\n"                       \
+        "       cmpeq   %[__prev],%[__old],%[__tmp]\n"                  \
+        "       wr_f    %[__tmp]\n"                                     \
+        "       mov     %[__new],%[__cmp]\n"                            \
+        "       lstl    %[__cmp],0(%[__addr])\n"                        \
+        "       rd_f    %[__cmp]\n"                             	\
+        "       beq     %[__tmp],2f\n"                                  \
+        "       beq     %[__cmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__old] "Ir" ((uint64_t)(old)),                               \
+          [__new] "Ir" (new)                                            \
+        : "memory");                                                    \
+})
+/*
+#define __arch_compare_and_exchange_xxx_64_int(mem, new, old, mb1, mb2) \
+({									\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"1:	ldq_l	%[__prev],%[__mem]\n"				\
+	"	cmpeq	%[__prev],%[__old],%[__cmp]\n"			\
+	"	beq	%[__cmp],2f\n"					\
+	"	mov	%[__new],%[__cmp]\n"				\
+	"	stq_c	%[__cmp],%[__mem]\n"				\
+	"	beq	%[__cmp],1b\n"					\
+		mb2							\
+	"2:"								\
+	: [__prev] "=&r" (__prev),					\
+	  [__cmp] "=&r" (__cmp)						\
+	: [__mem] "m" (*(mem)),						\
+	  [__old] "Ir" ((uint64_t)(old)),				\
+	  [__new] "Ir" (new)						\
+	: "memory");							\
+})
+*/
+/* For all "bool" routines, we return FALSE if exchange succesful.  */
+
+#define __arch_compare_and_exchange_bool_8_int(mem, new, old, mb1, mb2)	\
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_8_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+#define __arch_compare_and_exchange_bool_16_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_16_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+#define __arch_compare_and_exchange_bool_32_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_32_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+#define __arch_compare_and_exchange_bool_64_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_64_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+/* For all "val" routines, return the old value whether exchange
+   successful or not.  */
+
+#define __arch_compare_and_exchange_val_8_int(mem, new, old, mb1, mb2)	\
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_8_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+#define __arch_compare_and_exchange_val_16_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_16_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+#define __arch_compare_and_exchange_val_32_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_32_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+#define __arch_compare_and_exchange_val_64_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_64_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+/* Compare and exchange with "acquire" semantics, ie barrier after.  */
+
+#define atomic_compare_and_exchange_bool_acq(mem, new, old)	\
+  __atomic_bool_bysize (__arch_compare_and_exchange_bool, int,	\
+		        mem, new, old, "", __MB)
+
+#define atomic_compare_and_exchange_val_acq(mem, new, old)	\
+  __atomic_val_bysize (__arch_compare_and_exchange_val, int,	\
+		       mem, new, old, "", __MB)
+
+/* Compare and exchange with "release" semantics, ie barrier before.  */
+
+#define atomic_compare_and_exchange_val_rel(mem, new, old)	\
+  __atomic_val_bysize (__arch_compare_and_exchange_val, int,	\
+		       mem, new, old, __MB, "")
+
+
+/* Atomically store value and return the previous value.  */
+
+#define __arch_exchange_8_int(mem, value, mb1, mb2)                     \
+({                                                                      \
+  unsigned long __tmp, __addr64, __sval,__tmp1; __typeof(*mem) __ret;   \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       bic  %[__addr8],7,%[__addr64]\n"                     	\
+        "       ins0b   %[__value],%[__addr8],%[__sval]\n"              \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       ldi     %[__tmp1],1\n"                  		\
+        "       wr_f    %[__tmp1]\n"                                    \
+        "       ext0b   %[__tmp],%[__addr8],%[__ret]\n"                 \
+        "       mask0b   %[__tmp],%[__addr8],%[__tmp]\n"                \
+        "       or      %[__sval],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       rd_f    %[__tmp]\n"                            	 	\
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__sval] "=&r" (__sval),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__tmp1] "=&r" (__tmp1),                                      \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr8] "r" (mem),                                          \
+          [__value] "r" (value)                                         \
+        : "memory");                                                    \
+  __ret; })
+/*
+#define __arch_exchange_8_int(mem, value, mb1, mb2)			\
+({									\
+  unsigned long __tmp, __addr64, __sval; __typeof(*mem) __ret;		\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"	bic	%[__addr8],7,%[__addr64]\n"			\
+	"	insbl	%[__value],%[__addr8],%[__sval]\n"		\
+	"1:	ldq_l	%[__tmp],0(%[__addr64])\n"			\
+	"	extbl	%[__tmp],%[__addr8],%[__ret]\n"			\
+	"	mskbl	%[__tmp],%[__addr8],%[__tmp]\n"			\
+	"	or	%[__sval],%[__tmp],%[__tmp]\n"			\
+	"	stq_c	%[__tmp],0(%[__addr64])\n"			\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	: [__ret] "=&r" (__ret),					\
+	  [__sval] "=&r" (__sval),					\
+	  [__tmp] "=&r" (__tmp),					\
+	  [__addr64] "=&r" (__addr64)					\
+	: [__addr8] "r" (mem),						\
+	  [__value] "r" (value)						\
+	: "memory");							\
+  __ret; })
+*/
+
+#define __arch_exchange_16_int(mem, value, mb1, mb2)                    \
+({                                                                      \
+  unsigned long __tmp, __addr64, __sval,__tmp1; __typeof(*mem) __ret;   \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       bic  %[__addr16],7,%[__addr64]\n"                       \
+        "       ins1b   %[__value],%[__addr16],%[__sval]\n"             \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       ldi     %[__tmp1],1\n"                  		\
+        "       wr_f    %[__tmp1]\n"                                    \
+        "       ext1b   %[__tmp],%[__addr16],%[__ret]\n"                \
+        "       mask1b   %[__tmp],%[__addr16],%[__tmp]\n"               \
+        "       or      %[__sval],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       rd_f    %[__tmp]\n"                             	\
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__sval] "=&r" (__sval),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__tmp1] "=&r" (__tmp1),                                      \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr16] "r" (mem),                                         \
+          [__value] "r" (value)                                         \
+        : "memory");                                                    \
+  __ret; })
+/*
+#define __arch_exchange_16_int(mem, value, mb1, mb2)			\
+({									\
+  unsigned long __tmp, __addr64, __sval; __typeof(*mem) __ret;		\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"	bic	%[__addr16],7,%[__addr64]\n"			\
+	"	inswl	%[__value],%[__addr16],%[__sval]\n"		\
+	"1:	ldq_l	%[__tmp],0(%[__addr64])\n"			\
+	"	extwl	%[__tmp],%[__addr16],%[__ret]\n"		\
+	"	mskwl	%[__tmp],%[__addr16],%[__tmp]\n"		\
+	"	or	%[__sval],%[__tmp],%[__tmp]\n"			\
+	"	stq_c	%[__tmp],0(%[__addr64])\n"			\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	: [__ret] "=&r" (__ret),					\
+	  [__sval] "=&r" (__sval),					\
+	  [__tmp] "=&r" (__tmp),					\
+	  [__addr64] "=&r" (__addr64)					\
+	: [__addr16] "r" (mem),						\
+	  [__value] "r" (value)						\
+	: "memory");							\
+  __ret; })
+*/
+/* HUANGLM20161018 */
+#define __arch_exchange_32_int(mem, value, mb1, mb2)                    \
+({                                                                      \
+  signed int __tmp; __typeof(*mem) __ret;                               \
+  unsigned long __addr;                                                 \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldw    %[__ret],0(%[__addr])\n"                        \
+        "       ldi     %[__tmp],1\n"                                   \
+        "       wr_f    %[__tmp]\n"                                     \
+        "       mov     %[__val],%[__tmp]\n"                            \
+        "       lstw    %[__tmp],0(%[__addr])\n"                        \
+        "       rd_f    %[__tmp]\n"                                     \
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" (value)                                          \
+        : "memory");                                                    \
+  __ret; })
+/*
+#define __arch_exchange_32_int(mem, value, mb1, mb2)			\
+({									\
+  signed int __tmp; __typeof(*mem) __ret;				\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"1:	ldl_l	%[__ret],%[__mem]\n"				\
+	"	mov	%[__val],%[__tmp]\n"				\
+	"	stl_c	%[__tmp],%[__mem]\n"				\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	: [__ret] "=&r" (__ret),					\
+	  [__tmp] "=&r" (__tmp)						\
+	: [__mem] "m" (*(mem)),						\
+	  [__val] "Ir" (value)						\
+	: "memory");							\
+  __ret; })
+*/
+
+#define __arch_exchange_64_int(mem, value, mb1, mb2)                    \
+({                                                                      \
+  unsigned long __tmp,__addr; __typeof(*mem) __ret;                     \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldl    %[__ret],0(%[__addr])\n"                        \
+        "       ldi     %[__tmp],1\n"                  			\
+        "       wr_f    %[__tmp]\n"                                     \
+        "       mov     %[__val],%[__tmp]\n"                            \
+        "       lstl    %[__tmp],0(%[__addr])\n"                        \
+        "       rd_f    %[__tmp]\n"                             	\
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" (value)                                          \
+        : "memory");                                                    \
+  __ret; })
+/*
+#define __arch_exchange_64_int(mem, value, mb1, mb2)			\
+({									\
+  unsigned long __tmp; __typeof(*mem) __ret;				\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"1:	ldq_l	%[__ret],%[__mem]\n"				\
+	"	mov	%[__val],%[__tmp]\n"				\
+	"	stq_c	%[__tmp],%[__mem]\n"				\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	: [__ret] "=&r" (__ret),					\
+	  [__tmp] "=&r" (__tmp)						\
+	: [__mem] "m" (*(mem)),						\
+	  [__val] "Ir" (value)						\
+	: "memory");							\
+  __ret; })
+*/
+
+#define atomic_exchange_acq(mem, value) \
+  __atomic_val_bysize (__arch_exchange, int, mem, value, "", __MB)
+
+#define atomic_exchange_rel(mem, value) \
+  __atomic_val_bysize (__arch_exchange, int, mem, value, __MB, "")
+
+
+/* Atomically add value and return the previous (unincremented) value.  */
+
+#define __arch_exchange_and_add_8_int(mem, value, mb1, mb2) \
+  ({ __builtin_trap (); 0; })
+
+#define __arch_exchange_and_add_16_int(mem, value, mb1, mb2) \
+  ({ __builtin_trap (); 0; })
+
+/* HUAGNLM20161018 */
+#define __arch_exchange_and_add_32_int(mem, value, mb1, mb2)            \
+({                                                                      \
+  signed int __tmp; __typeof(*mem) __ret;                               \
+  unsigned long __addr;                                                 \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldw    %[__ret],0(%[__addr])\n"                        \
+        "       ldi     %[__tmp],1\n"                                   \
+        "       wr_f    %[__tmp]\n"                                     \
+        "       addw    %[__ret],%[__val],%[__tmp]\n"                   \
+        "       lstw    %[__tmp],0(%[__addr])\n"                        \
+        "       rd_f    %[__tmp]\n"                             	\
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" ((signed int)(value))                            \
+        : "memory");                                                    \
+  __ret; })
+/*
+#define __arch_exchange_and_add_32_int(mem, value, mb1, mb2)		\
+({									\
+  signed int __tmp; __typeof(*mem) __ret;				\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"1:	ldl_l	%[__ret],%[__mem]\n"				\
+	"	addl	%[__ret],%[__val],%[__tmp]\n"			\
+	"	stl_c	%[__tmp],%[__mem]\n"				\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	: [__ret] "=&r" (__ret),					\
+	  [__tmp] "=&r" (__tmp)						\
+	: [__mem] "m" (*(mem)),						\
+	  [__val] "Ir" ((signed int)(value))				\
+	: "memory");							\
+  __ret; })
+*/
+
+#define __arch_exchange_and_add_64_int(mem, value, mb1, mb2)            \
+({                                                                      \
+  unsigned long __tmp,__addr; __typeof(*mem) __ret;                     \
+  __asm__ __volatile__ (                                                \
+                mb1                                                     \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldl    %[__ret],0(%[__addr])\n"                        \
+        "       ldi     %[__tmp],1\n"                                   \
+        "       wr_f    %[__tmp]\n"                                     \
+        "       addl    %[__ret],%[__val],%[__tmp]\n"                   \
+        "       lstl    %[__tmp],0(%[__addr])\n"                        \
+        "       rd_f    %[__tmp]\n"                         		\
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" ((unsigned long)(value))                         \
+        : "memory");                                                    \
+  __ret; })
+/*
+#define __arch_exchange_and_add_64_int(mem, value, mb1, mb2)		\
+({									\
+  unsigned long __tmp; __typeof(*mem) __ret;				\
+  __asm__ __volatile__ (						\
+		mb1							\
+	"1:	ldq_l	%[__ret],%[__mem]\n"				\
+	"	addq	%[__ret],%[__val],%[__tmp]\n"			\
+	"	stq_c	%[__tmp],%[__mem]\n"				\
+	"	beq	%[__tmp],1b\n"					\
+		mb2							\
+	: [__ret] "=&r" (__ret),					\
+	  [__tmp] "=&r" (__tmp)						\
+	: [__mem] "m" (*(mem)),						\
+	  [__val] "Ir" ((unsigned long)(value))				\
+	: "memory");							\
+  __ret; })
+*/
+
+/* ??? Barrier semantics for atomic_exchange_and_add appear to be
+   undefined.  Use full barrier for now, as that's safe.  */
+#define atomic_exchange_and_add(mem, value) \
+  __atomic_val_bysize (__arch_exchange_and_add, int, mem, value, __MB, __MB)
+
+
+/* ??? Blah, I'm lazy.  Implement these later.  Can do better than the
+   compare-and-exchange loop provided by generic code.
+
+#define atomic_decrement_if_positive(mem)
+#define atomic_bit_test_set(mem, bit)
+
+*/
+# define atomic_full_barrier()	__asm ("memb" : : : "memory");
+# define atomic_read_barrier()	__asm ("memb" : : : "memory");
+# define atomic_write_barrier()	__asm ("memb" : : : "memory");
diff --git a/sysdeps/sw_64/bits/endianness.h b/sysdeps/sw_64/bits/endianness.h
new file mode 100644
index 00000000..939fe452
--- /dev/null
+++ b/sysdeps/sw_64/bits/endianness.h
@@ -0,0 +1,11 @@
+#ifndef _BITS_ENDIANNESS_H
+#define _BITS_ENDIANNESS_H 1
+
+#ifndef _BITS_ENDIAN_H
+# error "Never use <bits/endianness.h> directly; include <endian.h> instead."
+#endif
+
+/* Sw_64 is little-endian.  */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#endif /* bits/endianness.h */
diff --git a/sysdeps/sw_64/bits/link.h b/sysdeps/sw_64/bits/link.h
new file mode 100644
index 00000000..06d96fc0
--- /dev/null
+++ b/sysdeps/sw_64/bits/link.h
@@ -0,0 +1,68 @@
+/* Copyright (C) 2005-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+
+/* Registers for entry into PLT on Sw_64.  */
+typedef struct La_sw_64_regs
+{
+  uint64_t lr_r26;
+  uint64_t lr_sp;
+  uint64_t lr_r16;
+  uint64_t lr_r17;
+  uint64_t lr_r18;
+  uint64_t lr_r19;
+  uint64_t lr_r20;
+  uint64_t lr_r21;
+  double lr_f16;
+  double lr_f17;
+  double lr_f18;
+  double lr_f19;
+  double lr_f20;
+  double lr_f21;
+} La_sw_64_regs;
+
+/* Return values for calls from PLT on Sw_64.  */
+typedef struct La_sw_64_retval
+{
+  uint64_t lrv_r0;
+  uint64_t lrv_r1;
+  double lrv_f0;
+  double lrv_f1;
+} La_sw_64_retval;
+
+
+__BEGIN_DECLS
+
+extern Elf64_Addr la_sw_64_gnu_pltenter (Elf64_Sym *__sym, unsigned int __ndx,
+				         uintptr_t *__refcook,
+				         uintptr_t *__defcook,
+				         La_sw_64_regs *__regs,
+				         unsigned int *__flags,
+				         const char *__symname,
+				         long int *__framesizep);
+extern unsigned int la_sw_64_gnu_pltexit (Elf64_Sym *__sym, unsigned int __ndx,
+					  uintptr_t *__refcook,
+					  uintptr_t *__defcook,
+					  const La_sw_64_regs *__inregs,
+					  La_sw_64_retval *__outregs,
+					  const char *symname);
+
+__END_DECLS
diff --git a/sysdeps/sw_64/bits/mathdef.h b/sysdeps/sw_64/bits/mathdef.h
new file mode 100644
index 00000000..91880c6d
--- /dev/null
+++ b/sysdeps/sw_64/bits/mathdef.h
@@ -0,0 +1,44 @@
+/* Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <complex.h> instead"
+#endif
+
+#if defined _COMPLEX_H && !defined _COMPLEX_H_MATHDEF
+# define _COMPLEX_H_MATHDEF 1
+# if defined(__GNUC__) && !__GNUC_PREREQ(3,4)
+
+/* Due to an ABI change, we need to remap the complex float symbols.  */
+#  define _Mdouble_		float
+#  define __MATHCALL(function, args) \
+    __MATHDECL (_Complex float, function, args)
+#  define __MATHDECL(type, function, args) \
+    __MATHDECL_1(type, function##f, args, __c1_##function##f); \
+    __MATHDECL_1(type, __##function##f, args, __c1_##function##f)
+#  define __MATHDECL_1(type, function, args, alias) \
+    extern type function args __asm__(#alias) __THROW
+
+#  include <bits/cmathcalls.h>
+
+#  undef _Mdouble_
+#  undef __MATHCALL
+#  undef __MATHDECL
+#  undef __MATHDECL_1
+
+# endif /* GNUC before 3.4 */
+#endif /* COMPLEX_H */
diff --git a/sysdeps/sw_64/bits/setjmp.h b/sysdeps/sw_64/bits/setjmp.h
new file mode 100644
index 00000000..4117d255
--- /dev/null
+++ b/sysdeps/sw_64/bits/setjmp.h
@@ -0,0 +1,61 @@
+/* Define the machine-dependent type `jmp_buf'.  Sw_64 version.
+   Copyright (C) 1992-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H  1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+/* The previous bits/setjmp.h had __jmp_buf defined as a structure.
+   We use an array of 'long int' instead, to make writing the
+   assembler easier. Naturally, user code should not depend on
+   either representation. */
+
+/*
+ * Integer registers:
+ *    $0 is the return value (va);
+ *    $1-$8, $22-$25, $28 are call-used (t0-t7, t8-t11, at);
+ *    $9-$14 we save here (s0-s5);
+ *    $15 is the FP and we save it here (fp or s6);
+ *    $16-$21 are input arguments (call-used) (a0-a5);
+ *    $26 is the return PC and we save it here (ra);
+ *    $27 is the procedure value (i.e., the address of __setjmp) (pv or t12);
+ *    $29 is the global pointer, which the caller will reconstruct
+ *        from the return address restored in $26 (gp);
+ *    $30 is the stack pointer and we save it here (sp);
+ *    $31 is always zero (zero).
+ *
+ * Floating-point registers:
+ *    $f0 is the floating return value;
+ *    $f1, $f10-$f15, $f22-$f30 are call-used;
+ *    $f2-$f9 we save here;
+ *    $f16-$21 are input args (call-used);
+ *    $f31 is always zero.
+ *
+ * Note that even on Sw_64 hardware that does not have an FPU (there
+ * isn't such a thing currently) it is required to implement the FP
+ * registers.
+ */
+
+#ifndef __ASSEMBLY__
+typedef long int __jmp_buf[17];
+#endif
+
+#endif  /* bits/setjmp.h */
diff --git a/sysdeps/sw_64/bsd-_setjmp.S b/sysdeps/sw_64/bsd-_setjmp.S
new file mode 100644
index 00000000..4e6a2da5
--- /dev/null
+++ b/sysdeps/sw_64/bsd-_setjmp.S
@@ -0,0 +1 @@
+/* _setjmp is in setjmp.S  */
diff --git a/sysdeps/sw_64/bsd-setjmp.S b/sysdeps/sw_64/bsd-setjmp.S
new file mode 100644
index 00000000..1da848d2
--- /dev/null
+++ b/sysdeps/sw_64/bsd-setjmp.S
@@ -0,0 +1 @@
+/* setjmp is in setjmp.S  */
diff --git a/sysdeps/sw_64/bzero.S b/sysdeps/sw_64/bzero.S
new file mode 100644
index 00000000..22efb19d
--- /dev/null
+++ b/sysdeps/sw_64/bzero.S
@@ -0,0 +1,110 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Fill a block of memory with zeros.  Optimized for the Sw_64 architecture:
+
+   - memory accessed as aligned quadwords only
+   - destination memory not read unless needed for good cache behaviour
+   - basic blocks arranged to optimize branch prediction for full-quadword
+     aligned memory blocks.
+   - partial head and tail quadwords constructed with byte-mask instructions
+
+   This is generally scheduled for the EV5 (got to look out for my own
+   interefsts :-), but with EV4 needs in mind.  There *should* be no more
+   stalls for the EV4 than there are for the EV5.
+*/
+
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__bzero, @function
+	.globl	__bzero
+	.usepv	__bzero, USEPV_PROF
+
+	cfi_startproc
+
+	/* On entry to this basic block:
+	   t3 == loop counter
+	   t4 == bytes in partial final word
+	   a0 == possibly misaligned destination pointer  */
+
+	.align 3
+bzero_loop:
+	beq	t3, $tail	#
+	blbc	t3, 0f		# skip single store if count even
+
+	stl_u	zero, 0(a0)	# e0    : store one word
+	subl	t3, 1, t3	# .. e1 :
+	addl	a0, 8, a0	# e0    :
+	beq	t3, $tail	# .. e1 :
+
+0:	stl_u	zero, 0(a0)	# e0    : store two words
+	subl	t3, 2, t3	# .. e1 :
+	stl_u	zero, 8(a0)	# e0    :
+	addl	a0, 16, a0	# .. e1 :
+	bne	t3, 0b		# e1    :
+
+$tail:	bne	t4, 1f		# is there a tail to do?
+	ret			# no
+
+1:	ldl_u	t0, 0(a0)	# yes, load original data
+	mask7b	t0, t4, t0	#
+	stl_u	t0, 0(a0)	#
+	ret			#
+
+__bzero:
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+#endif
+
+	mov	a0, v0		# e0    : move return value in place
+	beq	a1, $done	# .. e1 : early exit for zero-length store
+	and	a0, 7, t1	# e0    :
+	addl	a1, t1, a1	# e1    : add dest misalignment to count
+	srl	a1, 3, t3	# e0    : loop = count >> 3
+	and	a1, 7, t4	# .. e1 : find number of bytes in tail
+	unop			#       :
+	beq	t1, bzero_loop	# e1    : aligned head, jump right in
+
+	ldl_u	t0, 0(a0)	# e0    : load original data to mask into
+	cmpult	a1, 8, t2	# .. e1 : is this a sub-word set?
+	bne	t2, $oneq	# e1    :
+
+	mask3b	t0, a0, t0	# e0    : we span words.  finish this partial
+	subl	t3, 1, t3	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	stl_u	t0, -8(a0)	# e0    :
+	br 	bzero_loop	# .. e1 :
+
+	.align 3
+$oneq:
+	mask3b	t0, a0, t2	# e0    :
+	mask7b	t0, a1, t3	# e0    :
+	or	t2, t3, t0	# e1    :
+	stl_u	t0, 0(a0)	# e0    :
+
+$done:	ret
+
+	cfi_endproc
+weak_alias (__bzero, bzero)
diff --git a/sysdeps/sw_64/configure b/sysdeps/sw_64/configure
new file mode 100644
index 00000000..f42479a8
--- /dev/null
+++ b/sysdeps/sw_64/configure
@@ -0,0 +1,8 @@
+# This file is generated from configure.ac by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/sw_64.
+
+# With required gcc+binutils, we can always access static and hidden
+# symbols in a position independent way.
+printf "%s\n" "#define PIE_UNSUPPORTED 1" >>confdefs.h
+
+# work around problem with autoconf and empty lines at the end of files
diff --git a/sysdeps/sw_64/configure.ac b/sysdeps/sw_64/configure.ac
new file mode 100644
index 00000000..896349e8
--- /dev/null
+++ b/sysdeps/sw_64/configure.ac
@@ -0,0 +1,7 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/sw_64.
+
+# With required gcc+binutils, we can always access static and hidden
+# symbols in a position independent way.
+AC_DEFINE(PI_STATIC_AND_HIDDEN)
+# work around problem with autoconf and empty lines at the end of files
diff --git a/sysdeps/sw_64/crti.S b/sysdeps/sw_64/crti.S
new file mode 100644
index 00000000..608e25ad
--- /dev/null
+++ b/sysdeps/sw_64/crti.S
@@ -0,0 +1,101 @@
+/* Special .init and .fini section support for Sw_64.
+   Copyright (C) 2001-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* crti.S puts a function prologue at the beginning of the .init and
+   .fini sections and defines global symbols for those addresses, so
+   they can be called as functions.  The symbols _init and _fini are
+   magic and cause the linker to emit DT_INIT and DT_FINI.
+
+   This differs from what would be generated for ordinary code in that
+   we save and restore the GP within the function.  In order for linker
+   relaxation to work, the value in the GP register on exit from a function
+   must be valid for the function entry point.  Normally, a function is
+   contained within one object file and this is not an issue, provided
+   that the function reloads the gp after making any function calls.
+   However, _init and _fini are constructed from pieces of many object
+   files, all of which may have different GP values.  So we must reload
+   the GP value from crti.o in crtn.o.  */
+
+#include <libc-symbols.h>
+#include <sysdep.h>
+
+#ifndef PREINIT_FUNCTION
+# define PREINIT_FUNCTION __gmon_start__
+#endif
+
+#ifndef PREINIT_FUNCTION_WEAK
+# define PREINIT_FUNCTION_WEAK 1
+#endif
+
+#if PREINIT_FUNCTION_WEAK
+        weak_extern (PREINIT_FUNCTION)
+#else
+        .hidden PREINIT_FUNCTION
+#endif
+
+	.section .init, "ax", @progbits
+	.globl	_init
+	.hidden	_init
+	.type	_init, @function
+	.usepv	_init, std
+_init:
+	ldgp	$29, 0($27)
+	subl	$30, 16, $30
+#if PREINIT_FUNCTION_WEAK
+	ldi	$27, PREINIT_FUNCTION
+#endif
+	stl	$26, 0($30)
+	stl	$29, 8($30)
+#if PREINIT_FUNCTION_WEAK
+	beq	$27, 1f
+	call	$26, ($27), PREINIT_FUNCTION
+	ldl	$29, 8($30)
+1:
+#else
+	bsr	$26, PREINIT_FUNCTION !samegp
+#endif
+	.p2align 3
+
+	.section .fini, "ax", @progbits
+	.globl	_fini
+	.hidden	_fini
+	.type	_fini,@function
+	.usepv	_fini,std
+_fini:
+	ldgp	$29, 0($27)
+	subl	$30, 16, $30
+	stl	$26, 0($30)
+	stl	$29, 8($30)
+	.p2align 3
diff --git a/sysdeps/sw_64/crtn.S b/sysdeps/sw_64/crtn.S
new file mode 100644
index 00000000..6c329e6d
--- /dev/null
+++ b/sysdeps/sw_64/crtn.S
@@ -0,0 +1,49 @@
+/* Special .init and .fini section support for Sw_64.
+   Copyright (C) 2001-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* crtn.S puts function epilogues in the .init and .fini sections
+   corresponding to the prologues in crti.S. */
+
+	.section .init, "ax", @progbits
+	ldl	$26, 0($30)
+	ldl	$29, 8($30)
+	addl	$30, 16, $30
+	ret
+
+	.section .fini, "ax", @progbits
+	ldl	$26, 0($30)
+	ldl	$29, 8($30)
+	addl	$30, 16, $30
+	ret
diff --git a/sysdeps/sw_64/div.S b/sysdeps/sw_64/div.S
new file mode 100644
index 00000000..c2ab1e44
--- /dev/null
+++ b/sysdeps/sw_64/div.S
@@ -0,0 +1,84 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "div_libc.h"
+
+#undef FRAME
+#ifdef __sw_64_fix__ 
+#define FRAME 0
+#else
+#define FRAME 16
+#endif
+
+	.set noat
+
+	.align 4
+	.globl div
+	.ent div
+div:
+	.frame sp, FRAME, ra
+#if FRAME > 0
+	ldi	sp, -FRAME(sp)
+#endif
+#ifdef PROF
+	.set	macro
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set	nomacro
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	beq	$18, $divbyzero
+	rfpcr $f10 /* HUANGLM20161111 */
+        _ITOFT2 $17, $f0, 0, $18, $f1, 8
+/* XZX_20210709 */
+        fcvtld  $f0, $f11
+        fcvtld  $f1, $f12
+        fdivd   $f11, $f12, $f1
+        fcvtdl_z  $f1, $f0
+	wfpcr $f10 /* HUANGLM20161111 */
+	_FTOIT	$f0, $0, 0
+
+	mulw	$0, $18, $1
+	subw	$17, $1, $1
+
+	stw	$0, 0(a0)
+	stw	$1, 4(a0)
+	mov	a0, v0
+	
+#if FRAME > 0
+	ldi	sp, FRAME(sp)
+#endif
+	ret
+
+$divbyzero:
+	mov	a0, v0
+	ldi	a0, GEN_INTDIV
+	sys_call HMC_gentrap
+	stw	zero, 0(v0)
+	stw	zero, 4(v0)
+
+#if FRAME > 0
+	ldi	sp, FRAME(sp)
+#endif
+	ret
+
+	.end div
diff --git a/sysdeps/sw_64/div_libc.h b/sysdeps/sw_64/div_libc.h
new file mode 100644
index 00000000..1529410d
--- /dev/null
+++ b/sysdeps/sw_64/div_libc.h
@@ -0,0 +1,170 @@
+/* Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Common bits for implementing software divide.  */
+
+#include <sysdep.h>
+#ifdef __linux__
+# include <asm/gentrap.h>
+# include <asm/hmcall.h>
+#else
+# include <machine/pal.h>
+#endif
+
+/* These are not normal C functions.  Argument registers are t10 and t11;
+   the result goes in t12; the return address is in t9.  Only t12 and AT
+   may be clobbered.  */
+#define X	t10
+#define Y	t11
+#define RV	t12
+#define RA	t9
+
+/* The secureplt format does not allow the division routines to be called
+   via plt; there aren't enough registers free to be clobbered.  Avoid
+   setting the symbol type to STT_FUNC, so that the linker won't be tempted
+   to create a plt entry.  */
+#define funcnoplt notype
+
+/* None of these functions should use implicit anything.  */
+	.set	nomacro
+	.set	noat
+
+/* Code fragment to invoke _mcount for profiling.  This should be invoked
+   directly after allocation of the stack frame.  */
+.macro CALL_MCOUNT
+#ifdef PROF
+	stl	ra, 0(sp)
+	stl	pv, 8(sp)
+	stl	gp, 16(sp)
+	cfi_rel_offset (ra, 0)
+	cfi_rel_offset (pv, 8)
+	cfi_rel_offset (gp, 16)
+	br	AT, 1f
+	.set	macro
+1:	ldgp	gp, 0(AT)
+	mov	RA, ra
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set	nomacro
+	ldl	ra, 0(sp)
+	ldl	pv, 8(sp)
+	ldl	gp, 16(sp)
+	cfi_restore (ra)
+	cfi_restore (pv)
+	cfi_restore (gp)
+	/* Realign subsequent code with what we'd have without this
+	   macro at all.  This means aligned with one arithmetic insn
+	   used within the bundle.  */
+	.align	4
+	nop
+#endif
+.endm
+
+/* In order to make the below work, all top-level divide routines must
+   use the same frame size.  */
+#define FRAME 96	
+
+/* Code fragment to generate an integer divide-by-zero fault.  When
+   building libc.so, we arrange for there to be one copy of this code
+   placed late in the dso, such that all branches are forward.  When
+   building libc.a, we use multiple copies to avoid having an out of
+   range branch.  Users should jump to DIVBYZERO.  */
+
+.macro DO_DIVBYZERO
+#ifdef PIC
+#define DIVBYZERO	__divbyzero
+	.section .gnu.linkonce.t.divbyzero, "ax", @progbits
+	.globl	__divbyzero
+	.type	__divbyzero, @function
+	.usepv	__divbyzero, no
+	.hidden	__divbyzero
+#else
+#define DIVBYZERO	$divbyzero
+#endif
+
+	.align	4
+DIVBYZERO:
+	cfi_startproc
+	cfi_return_column (RA)
+	cfi_def_cfa_offset (FRAME)
+
+	mov	a0, RV
+	unop
+	ldi	a0, GEN_INTDIV
+	sys_call HMC_gentrap
+
+	mov	RV, a0
+	clr	RV
+	ldi	sp, FRAME(sp)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+
+	cfi_endproc
+	.size	DIVBYZERO, .-DIVBYZERO
+.endm
+
+/* Like the sw6a instructions, but fall back to stack use on prior machines.  */
+#ifdef __sw_64_sw6a__
+        .arch   sw6a
+#endif
+#ifdef __sw_64_sw6b__
+        .arch   sw6b
+#endif
+#ifdef __sw_64_sw8a__
+        .arch   sw8a
+#endif
+
+.macro _ITOFS  gr, fr, slot
+#ifdef __sw_64_fix__
+	ifmovs	\gr, \fr
+#else
+	stw	\gr, \slot(sp)
+	flds	\fr, \slot(sp)
+#endif
+.endm
+
+.macro _ITOFT  gr, fr, slot
+#ifdef __sw_64_fix__
+	ifmovd	\gr, \fr
+#else
+	stl	\gr, \slot(sp)
+	fldd	\fr, \slot(sp)
+#endif
+.endm
+
+.macro _FTOIT  fr, gr, slot
+#ifdef __sw_64_fix__
+	fimovd	\fr, \gr
+#else
+	fstd	\fr, \slot(sp)
+	ldl	\gr, \slot(sp)
+#endif
+.endm
+
+/* Similarly, but move two registers.  Schedules better for pre-sw6a.  */
+
+.macro _ITOFT2 gr1, fr1, slot1, gr2, fr2, slot2
+#ifdef __sw_64_fix__
+	ifmovd	\gr1, \fr1
+	ifmovd	\gr2, \fr2
+#else
+	stl	\gr1, \slot1(sp)
+	stl	\gr2, \slot2(sp)
+	fldd	\fr1, \slot1(sp)
+	fldd	\fr2, \slot2(sp)
+#endif
+.endm
diff --git a/sysdeps/sw_64/divl.S b/sysdeps/sw_64/divl.S
new file mode 100644
index 00000000..14fc3f99
--- /dev/null
+++ b/sysdeps/sw_64/divl.S
@@ -0,0 +1,98 @@
+/* Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "div_libc.h"
+
+/* 32-bit signed int divide.  This is not a normal C function.  Argument
+   registers are t10 and t11, the result goes in t12.  Only t12 and AT may
+   be clobbered.
+
+   The FPU can handle all input values except zero.  Whee!
+
+   The FPCR save/restore is due to the fact that the SW6 _will_ set FPCR_INE
+   for cvttq/c even without /sui being set.  It will not, however, properly
+   raise the exception, so we don't have to worry about FPCR_INED being clear
+   and so dying by SIGFPE.  */
+   /*__divl -> __divw HUANGLM20161111*/
+
+  /***************************************************************** 
+  #                                                                *
+  #  ZYH transform to sw-instruct on 2016111216                    *
+  #                                                                *
+  #****************************************************************/
+
+#ifndef EXTEND
+#define EXTEND(S,D)	sextl S, D
+#endif
+
+	.text
+	.align	4
+	.globl	__divw
+	.type	__divw, @funcnoplt
+	.usepv	__divw, no
+
+	cfi_startproc
+	cfi_return_column (RA)
+__divw:
+        ldi     sp, -FRAME(sp)
+        cfi_def_cfa_offset (FRAME)
+        CALL_MCOUNT
+        fstd     $f0, 0(sp)
+        excb
+        beq     Y, DIVBYZERO
+
+        fstd     $f1, 8(sp)
+        fstd     $f2, 16(sp)
+        fstd     $f3, 40(sp)
+        fstd     $f4, 48(sp)
+        cfi_rel_offset ($f0, 0)
+        cfi_rel_offset ($f1, 8)
+        cfi_rel_offset ($f2, 16)
+        cfi_rel_offset ($f3, 40)
+        cfi_rel_offset ($f4, 48)
+
+	rfpcr	$f2 /* HUANGLM20161111 */
+        EXTEND  (X, RV)
+        EXTEND  (Y, AT)
+        _ITOFT2 RV, $f0, 24, AT, $f1, 32
+        fcvtld   $f0, $f3
+        fcvtld   $f1, $f4
+        fdivd    $f3, $f4, $f1
+        fcvtdl_z $f1, $f0
+	wfpcr	$f2 /* HUANGLM20161111 */
+	_FTOIT	$f0, RV, 24
+
+	fldd	$f0, 0(sp)
+	fldd	$f1, 8(sp)
+	fldd	$f2, 16(sp)
+	fldd	$f3, 40(sp)
+	fldd	$f4, 48(sp)
+	ldi	sp, FRAME(sp)
+	cfi_restore ($f0)
+	cfi_restore ($f1)
+	cfi_restore ($f2)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_def_cfa_offset (0)
+        sextl   RV, RV
+	#addw	RV, 0, RV  //by XWB20200327
+	ret	$31, (RA), 1
+
+	cfi_endproc
+	.size	__divw, .-__divw
+
+	DO_DIVBYZERO
diff --git a/sysdeps/sw_64/divlu.S b/sysdeps/sw_64/divlu.S
new file mode 100644
index 00000000..26e1842f
--- /dev/null
+++ b/sysdeps/sw_64/divlu.S
@@ -0,0 +1,4 @@
+#define UNSIGNED
+#define EXTEND(S,D)	zapnot S, 15, D
+#define __divw		__divwu
+#include <divl.S>
diff --git a/sysdeps/sw_64/divq.S b/sysdeps/sw_64/divq.S
new file mode 100644
index 00000000..4fc32200
--- /dev/null
+++ b/sysdeps/sw_64/divq.S
@@ -0,0 +1,295 @@
+/* Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "div_libc.h"
+
+
+/* 64-bit signed long divide.  These are not normal C functions.  Argument
+   registers are t10 and t11, the result goes in t12.  Only t12 and AT may
+   be clobbered.
+
+   Theory of operation here is that we can use the FPU divider for virtually
+   all operands that we see: all dividend values between -2**53 and 2**53-1
+   can be computed directly.  Note that divisor values need not be checked
+   against that range because the rounded fp value will be close enough such
+   that the quotient is < 1, which will properly be truncated to zero when we
+   convert back to integer.
+
+   When the dividend is outside the range for which we can compute exact
+   results, we use the fp quotent as an estimate from which we begin refining
+   an exact integral value.  This reduces the number of iterations in the
+   shift-and-subtract loop significantly.
+
+   The FPCR save/restore is due to the fact that the SW6 _will_ set FPCR_INE
+   for cvttq/c even without /sui being set.  It will not, however, properly
+   raise the exception, so we don't have to worry about FPCR_INED being clear
+   and so dying by SIGFPE.  */
+   /*__divq -> __divl  HUANGLM20161111*/
+  /***************************************************************** 
+  #                                                                *
+  #  ZYH transform to sw-instruct on 2016111216                    *
+  #                                                                *
+  #****************************************************************/
+	.text
+	.align	4
+	.globl	__divl
+	.type	__divl, @funcnoplt
+	.usepv	__divl, no
+
+	cfi_startproc
+	cfi_return_column (RA)
+__divl:
+        ldi     sp, -FRAME(sp)
+        cfi_def_cfa_offset (FRAME)
+        CALL_MCOUNT
+
+        /* Get the fp divide insn issued as quickly as possible.  After
+           that's done, we have at least 22 cycles until its results are
+           ready -- all the time in the world to figure out how we're
+           going to use the results.  */
+        fstd     $f0, 0(sp)
+        excb
+        beq     Y, DIVBYZERO
+
+        fstd     $f1, 8(sp)
+        fstd     $f3, 48(sp)
+        fstd     $f4, 56(sp)
+        fstd     $f5, 64(sp)
+
+        cfi_rel_offset ($f0, 0)
+        cfi_rel_offset ($f1, 8)
+        cfi_rel_offset ($f3, 48)
+        cfi_rel_offset ($f4, 56)
+        cfi_rel_offset ($f5, 64)
+	rfpcr	$f3 /* HUANGLM20161111 */
+
+        _ITOFT2 X, $f0, 16, Y, $f1, 24
+        fcvtld   $f0, $f4
+        fcvtld   $f1, $f5
+        fdivd  $f4, $f5, $f0
+
+        /* Check to see if X fit in the double as an exact value.  */
+        sll     X, (64-53), AT
+        fldd     $f1, 8(sp)
+        sra     AT, (64-53), AT
+        cmpeq   X, AT, AT
+        beq     AT, $x_big
+        /* If we get here, we're expecting exact results from the division.
+           Do nothing else besides convert and clean up.  */
+        fcvtdl_z $f0, $f4
+        excb
+
+	wfpcr	$f3 /* HUANGLM20161111 */
+        _FTOIT  $f4, RV, 16
+        fldd     $f0, 0(sp)
+        fldd     $f3, 48(sp)
+        fldd     $f4, 56(sp)
+        fldd     $f5, 64(sp)
+        cfi_restore ($f1)
+        cfi_remember_state
+        cfi_restore ($f0)
+        cfi_restore ($f3)
+        cfi_restore ($f4)
+        cfi_restore ($f5)
+        cfi_def_cfa_offset (0)
+        ldi     sp, FRAME(sp)
+        ret     $31, (RA), 1
+
+        .align  4
+        cfi_restore_state
+
+$x_big:
+	/* If we get here, X is large enough that we don't expect exact
+	   results, and neither X nor Y got mis-translated for the fp
+	   division.  Our task is to take the fp result, figure out how
+	   far it's off from the correct result and compute a fixup.  */
+	stl	t0, 32(sp)
+	stl	t1, 40(sp)
+	stl	t2, 16(sp)
+	stl	t5, 24(sp)
+	cfi_rel_offset (t0, 32)
+	cfi_rel_offset (t1, 40)
+	cfi_rel_offset (t2, 16)
+	cfi_rel_offset (t5, 24)
+
+#define Q	RV		/* quotient */
+#define R	t0		/* remainder */
+#define SY	t1		/* scaled Y */
+#define S	t2		/* scalar */
+#define QY	t3		/* Q*Y */
+
+	/* The fixup code below can only handle unsigned values.  */
+	or	X, Y, AT
+	mov	$31, t5
+	blt	AT, $fix_sign_in
+$fix_sign_in_ret1:
+	fcvtdl_z $f0, $f4
+
+	_FTOIT	$f4, Q, 8
+	.align	3
+$fix_sign_in_ret2:
+	fldd	$f0, 0(sp)
+	stl	t3, 0(sp)
+	cfi_restore ($f0)
+	cfi_rel_offset (t3, 0)
+
+	mull	Q, Y, QY
+	excb
+	stl	t4, 8(sp)
+	wfpcr	$f3 /* HUANGLM20161111 */
+	cfi_rel_offset (t4, 8)
+
+	subl	QY, X, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_high
+
+$q_high_ret:
+	subl	X, QY, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_low
+
+$q_low_ret:
+	ldl	t0, 32(sp)
+	ldl	t1, 40(sp)
+	ldl	t2, 16(sp)
+	bne	t5, $fix_sign_out
+
+$fix_sign_out_ret:
+	ldl	t3, 0(sp)
+	ldl	t4, 8(sp)
+	ldl	t5, 24(sp)
+	fldd	$f3, 48(sp)
+        fldd    $f4, 56(sp)
+        fldd    $f5, 64(sp)
+	ldi	sp, FRAME(sp)
+	cfi_remember_state
+	cfi_restore (t0)
+	cfi_restore (t1)
+	cfi_restore (t2)
+	cfi_restore (t3)
+	cfi_restore (t4)
+	cfi_restore (t5)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+
+	.align	4
+	cfi_restore_state
+	/* The quotient that we computed was too large.  We need to reduce
+	   it by S such that Y*S >= R.  Obviously the closer we get to the
+	   correct value the better, but overshooting high is ok, as we'll
+	   fix that up later.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_high:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	subl	Q, S, Q
+	unop
+	subl	QY, SY, QY
+	br	$q_high_ret
+
+	.align	4
+	/* The quotient that we computed was too small.  Divide Y by the
+	   current remainder (R) and add that to the existing quotient (Q).
+	   The expectation, of course, is that R is much smaller than X.  */
+	/* Begin with a shift-up loop.  Compute S such that Y*S >= R.  We
+	   already have a copy of Y in SY and the value 1 in S.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_low:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	/* Shift-down and subtract loop.  Each iteration compares our scaled
+	   Y (SY) with the remainder (R); if SY <= R then X is divisible by
+	   Y's scalar (S) so add it to the quotient (Q).  */
+2:	addl	Q, S, t3
+	srl	S, 1, S
+	cmpule	SY, R, AT
+	subl	R, SY, t4
+
+	selne	AT, t3, Q, Q
+	selne	AT, t4, R, R
+	srl	SY, 1, SY
+	bne	S, 2b
+
+	br	$q_low_ret
+
+	.align	4
+$fix_sign_in:
+	/* If we got here, then X|Y is negative.  Need to adjust everything
+	   such that we're doing unsigned division in the fixup loop.  */
+	/* T5 records the changes we had to make:
+		bit 0:	set if result should be negative.
+		bit 2:	set if X was negated.
+		bit 3:	set if Y was negated.
+	*/
+	xor	X, Y, AT
+	cmplt	AT, 0, t5
+	cmplt	X, 0, AT
+	negl	X, t0
+
+	s4addl	AT, t5, t5
+	selne	AT, t0, X, X
+	cmplt	Y, 0, AT
+	negl	Y, t0
+
+	s8addl	AT, t5, t5
+	selne	AT, t0, Y, Y
+	unop
+	blbc	t5, $fix_sign_in_ret1
+
+#ifdef HUANGLM20161111
+	cvttq/c	$f0, $f0
+#else
+	fcvtdl_z $f0, $f4
+#endif
+	_FTOIT	$f4, Q, 8
+	.align	3
+	negl	Q, Q
+	br	$fix_sign_in_ret2
+
+	.align	4
+$fix_sign_out:
+	/* Now we get to undo what we did above.  */
+	/* ??? Is this really faster than just increasing the size of
+	   the stack frame and storing X and Y in memory?  */
+	and	t5, 8, AT
+	negl	Y, t4
+	selne	AT, t4, Y, Y
+
+	and	t5, 4, AT
+	negl	X, t4
+	selne	AT, t4, X, X
+
+	negl	RV, t4
+	sellbs	t5, t4, RV, RV
+
+	br	$fix_sign_out_ret
+
+	cfi_endproc
+	.size	__divl, .-__divl
+
+	DO_DIVBYZERO
diff --git a/sysdeps/sw_64/divqu.S b/sysdeps/sw_64/divqu.S
new file mode 100644
index 00000000..5adec56c
--- /dev/null
+++ b/sysdeps/sw_64/divqu.S
@@ -0,0 +1,301 @@
+/* Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "div_libc.h"
+
+
+/* 64-bit unsigned long divide.  These are not normal C functions.  Argument
+   registers are t10 and t11, the result goes in t12.  Only t12 and AT may be
+   clobbered.
+
+   Theory of operation here is that we can use the FPU divider for virtually
+   all operands that we see: all dividend values between -2**53 and 2**53-1
+   can be computed directly.  Note that divisor values need not be checked
+   against that range because the rounded fp value will be close enough such
+   that the quotient is < 1, which will properly be truncated to zero when we
+   convert back to integer.
+
+   When the dividend is outside the range for which we can compute exact
+   results, we use the fp quotent as an estimate from which we begin refining
+   an exact integral value.  This reduces the number of iterations in the
+   shift-and-subtract loop significantly.
+
+   The FPCR save/restore is due to the fact that the SW6 _will_ set FPCR_INE
+   for cvttq/c even without /sui being set.  It will not, however, properly
+   raise the exception, so we don't have to worry about FPCR_INED being clear
+   and so dying by SIGFPE.  */
+   /*__divqu -> __divlu HUANGLM20161111*/
+  /*  ZYH transform to sw-instruct on 2016111216 */
+	.text
+	.align	4
+	.globl	__divlu
+	.type	__divlu, @funcnoplt
+	.usepv	__divlu, no
+
+	cfi_startproc
+	cfi_return_column (RA)
+__divlu:
+	ldi	sp, -FRAME(sp)
+	cfi_def_cfa_offset (FRAME)
+	CALL_MCOUNT
+
+	/* Get the fp divide insn issued as quickly as possible.  After
+	   that's done, we have at least 22 cycles until its results are
+	   ready -- all the time in the world to figure out how we're
+	   going to use the results.  */
+#ifndef LIJM20201110
+	beq	Y, DIVBYZERO
+	fstd	$f0, 0(sp)
+#else
+	beq	Y, DIVBYZERO
+/*	excb*/
+	beq	Y, DIVBYZERO
+#endif
+	fstd	$f1, 8(sp)
+	fstd	$f3, 48(sp)
+	fstd	$f4, 56(sp)
+	fstd	$f5, 64(sp)
+        stl     t0,32(sp)
+        stl     t1,40(sp)
+        cfi_rel_offset ($f0, 0)
+        cfi_rel_offset ($f1, 8)
+        cfi_rel_offset ($f3, 48)
+        cfi_rel_offset ($f4, 56)
+        cfi_rel_offset ($f5, 64)
+        cfi_rel_offset (t0, 32)
+        cfi_rel_offset (t1, 40)
+
+        rfpcr $f3 /* HUANGLM20161111 */
+        /*XWB add it for there has some err when with -mieee of 0xffffffffffffffff/2*/
+        rfpcr $f1
+        fimovd $f1,t0
+        ldi   t1,3
+        sll   t1,58,t1
+        bic   t0,t1,t0
+        ifmovd t0,$f1
+        wfpcr $f1
+	_ITOFT2	X, $f0, 16, Y, $f1, 24
+	fcvtld	$f0, $f4
+	fcvtld	$f1, $f5
+	blt	X, $x_is_neg
+	fdivd	$f4, $f5, $f0
+
+	/* Check to see if Y was mis-converted as signed value.  */
+	fldd	$f1, 8(sp)
+	blt	Y, $y_is_neg
+
+	/* Check to see if X fit in the double as an exact value.  */
+	srl	X, 53, AT
+	bne	AT, $x_big
+
+	/* If we get here, we're expecting exact results from the division.
+	   Do nothing else besides convert and clean up.  */
+	fcvtdl $f0, $f4
+        wfpcr $f3 /* HUANGLM20161111 */
+	_FTOIT	$f4, RV, 16
+
+        ldl     t0,32(sp)
+        ldl     t1,40(sp)
+	fldd	$f0, 0(sp)
+	fldd	$f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+	ldi	sp, FRAME(sp)   /* LIJM20201110 */
+	cfi_remember_state
+        cfi_restore (t0)
+        cfi_restore (t1)
+	cfi_restore ($f0)
+	cfi_restore ($f1)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+
+	cfi_def_cfa_offset (0)
+#	ldi	sp, FRAME(sp)
+	ret	$31, (RA), 1
+
+	.align	4
+	cfi_restore_state
+$x_is_neg:
+	/* If we get here, X is so big that bit 63 is set, which made the
+	   conversion come out negative.  Fix it up lest we not even get
+	   a good estimate.  */
+	ldih	AT, 0x5f80		/* 2**64 as float.  */
+	fstd	$f2, 24(sp)
+	fstd	$f6, 72(sp)
+	cfi_rel_offset ($f2, 24)
+	cfi_rel_offset ($f5, 72)
+	_ITOFS	AT, $f2, 16
+
+	.align	4
+	faddd	$f4, $f2, $f6
+	unop
+	fdivd	$f6, $f5, $f0
+	unop
+
+	/* Ok, we've now the divide issued.  Continue with other checks.  */
+	fldd	$f1, 8(sp)
+	unop
+	fldd	$f2, 24(sp)
+	fldd	$f6, 72(sp)
+	blt	Y, $y_is_neg
+	cfi_restore ($f1)
+	cfi_restore ($f2)
+	cfi_restore ($f6)
+	cfi_remember_state	/* for y_is_neg */
+
+	.align	4
+$x_big:
+	/* If we get here, X is large enough that we don't expect exact
+	   results, and neither X nor Y got mis-translated for the fp
+	   division.  Our task is to take the fp result, figure out how
+	   far it's off from the correct result and compute a fixup.  */
+#	stl	t0, 32(sp)
+#	stl	t1, 40(sp)
+	stl	t2, 16(sp)
+	stl	t3, 24(sp)
+	cfi_rel_offset (t0, 32)
+	cfi_rel_offset (t1, 40)
+	cfi_rel_offset (t2, 16)
+	cfi_rel_offset (t3, 24)
+
+#define Q	RV		/* quotient */
+#define R	t0		/* remainder */
+#define SY	t1		/* scaled Y */
+#define S	t2		/* scalar */
+#define QY	t3		/* Q*Y */
+
+	fcvtdl $f0, $f4
+	_FTOIT	$f4, Q, 8
+	mull	Q, Y, QY
+
+	.align	4
+	stl	t4, 8(sp)
+	excb
+	fldd	$f0, 0(sp)
+	wfpcr	$f3 /* HUANGLM20161111 */
+	cfi_rel_offset (t4, 8)
+	cfi_restore ($f0)
+
+	subl	QY, X, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_high
+
+$q_high_ret:
+	subl	X, QY, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_low
+
+$q_low_ret:
+	ldl	t4, 8(sp)
+	ldl	t0, 32(sp)
+	ldl	t1, 40(sp)
+	ldl	t2, 16(sp)
+
+	ldl	t3, 24(sp)
+	fldd	$f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+	ldi	sp, FRAME(sp)
+	cfi_remember_state
+	cfi_restore (t0)
+	cfi_restore (t1)
+	cfi_restore (t2)
+	cfi_restore (t3)
+	cfi_restore (t4)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+
+	.align	4
+	cfi_restore_state
+	/* The quotient that we computed was too large.  We need to reduce
+	   it by S such that Y*S >= R.  Obviously the closer we get to the
+	   correct value the better, but overshooting high is ok, as we'll
+	   fix that up later.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_high:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	subl	Q, S, Q
+	unop
+	subl	QY, SY, QY
+	br	$q_high_ret
+
+	.align	4
+	/* The quotient that we computed was too small.  Divide Y by the
+	   current remainder (R) and add that to the existing quotient (Q).
+	   The expectation, of course, is that R is much smaller than X.  */
+	/* Begin with a shift-up loop.  Compute S such that Y*S >= R.  We
+	   already have a copy of Y in SY and the value 1 in S.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_low:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	/* Shift-down and subtract loop.  Each iteration compares our scaled
+	   Y (SY) with the remainder (R); if SY <= R then X is divisible by
+	   Y's scalar (S) so add it to the quotient (Q).  */
+2:	addl	Q, S, t3
+	srl	S, 1, S
+	cmpule	SY, R, AT
+	subl	R, SY, t4
+
+	selne	AT, t3, Q, Q
+	selne	AT, t4, R, R
+	srl	SY, 1, SY
+	bne	S, 2b
+
+	br	$q_low_ret
+
+	.align	4
+	cfi_restore_state
+$y_is_neg:
+	/* If we get here, Y is so big that bit 63 is set.  The results
+	   from the divide will be completely wrong.  Fortunately, the
+	   quotient must be either 0 or 1, so just compute it directly.  */
+	cmpule	Y, X, RV
+	excb
+	wfpcr	$f3 /* HUANGLM20161111 */
+	fldd	$f0, 0(sp)
+	fldd	$f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+        ldl     t0,32(sp)
+        ldl     t1,40(sp)
+	ldi	sp, FRAME(sp)
+	cfi_restore (t0)
+	cfi_restore (t1)
+	cfi_restore ($f0)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+	cfi_endproc
+	.size	__divlu, .-__divlu
+
+	DO_DIVBYZERO
diff --git a/sysdeps/sw_64/dl-dtprocnum.h b/sysdeps/sw_64/dl-dtprocnum.h
new file mode 100644
index 00000000..c31a50bd
--- /dev/null
+++ b/sysdeps/sw_64/dl-dtprocnum.h
@@ -0,0 +1,3 @@
+/* Number of extra dynamic section entries for this architecture.  By
+   default there are none.  */
+#define DT_THISPROCNUM	DT_SW_64_NUM
diff --git a/sysdeps/sw_64/dl-machine.h b/sysdeps/sw_64/dl-machine.h
new file mode 100644
index 00000000..1bd852a2
--- /dev/null
+++ b/sysdeps/sw_64/dl-machine.h
@@ -0,0 +1,506 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  Sw_64 version.
+   Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This was written in the absence of an ABI -- don't expect
+   it to remain unchanged.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h 1
+
+#define ELF_MACHINE_NAME "sw_64"
+
+#include <string.h>
+#include <dl-static-tls.h>
+#include <dl-machine-rel.h>
+
+
+/* Mask identifying addresses reserved for the user program,
+   where the dynamic linker should not map anything.  */
+#define ELF_MACHINE_USER_ADDRESS_MASK	0x120000000UL
+
+/* Translate a processor specific dynamic tag to the index in l_info array.  */
+#define DT_SW_64(x) (DT_SW_64_##x - DT_LOPROC + DT_NUM)
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int
+elf_machine_matches_host (const Elf64_Ehdr *ehdr)
+{
+  return ehdr->e_machine == EM_SW_64;
+}
+
+/* Return the link-time address of _DYNAMIC.  The multiple-got-capable
+   linker no longer allocates the first .got entry for this.  But not to
+   worry, no special tricks are needed.  */
+static inline Elf64_Addr
+elf_machine_dynamic (void)
+{
+#ifndef NO_AXP_MULTI_GOT_LD
+  return (Elf64_Addr) &_DYNAMIC;
+#else
+  register Elf64_Addr *gp __asm__ ("$29");
+  return gp[-4096];
+#endif
+}
+
+/* Return the run-time load address of the shared object.  */
+
+static inline Elf64_Addr
+elf_machine_load_address (void)
+{
+  /* This relies on the compiler using gp-relative addresses for static symbols.  */
+  static void *dot = &dot;
+  return (void *)&dot - dot;
+}
+
+/* Set up the loaded object described by L so its unrelocated PLT
+   entries will jump to the on-demand fixup code in dl-runtime.c.  */
+
+static inline int
+elf_machine_runtime_setup (struct link_map *map, struct r_scope_elem *scope[], int lazy, int profile)
+{
+  extern char _dl_runtime_resolve_new[] attribute_hidden;
+  extern char _dl_runtime_profile_new[] attribute_hidden;
+  extern char _dl_runtime_resolve_old[] attribute_hidden;
+  extern char _dl_runtime_profile_old[] attribute_hidden;
+
+  struct pltgot {
+    char *resolve;
+    struct link_map *link;
+  };
+
+  struct pltgot *pg;
+  long secureplt;
+  char *resolve;
+
+  if (map->l_info[DT_JMPREL] == 0 || !lazy)
+    return lazy;
+
+  /* Check to see if we're using the read-only plt form.  */
+  secureplt = map->l_info[DT_SW_64(PLTRO)] != 0;
+
+  /* If the binary uses the read-only secure plt format, PG points to
+     the .got.plt section, which is the right place for ld.so to place
+     its hooks.  Otherwise, PG is currently pointing at the start of
+     the plt; the hooks go at offset 16.  */
+  pg = (struct pltgot *) D_PTR (map, l_info[DT_PLTGOT]);
+  pg += !secureplt;
+
+  /* This function will be called to perform the relocation.  They're
+     not declared as functions to convince the compiler to use gp
+     relative relocations for them.  */
+  if (secureplt)
+    resolve = _dl_runtime_resolve_new;
+  else
+    resolve = _dl_runtime_resolve_old;
+
+  if (__builtin_expect (profile, 0))
+    {
+      if (secureplt)
+	resolve = _dl_runtime_profile_new;
+      else
+	resolve = _dl_runtime_profile_old;
+
+      if (GLRO(dl_profile) && _dl_name_match_p (GLRO(dl_profile), map))
+	{
+	  /* This is the object we are looking for.  Say that we really
+	     want profiling and the timers are started.  */
+	  GL(dl_profile_map) = map;
+	}
+    }
+
+  pg->resolve = resolve;
+  pg->link = map;
+
+  return lazy;
+}
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+
+#define RTLD_START asm ("\
+	.section .text						\n\
+	.set at							\n\
+	.globl _start						\n\
+	.ent _start						\n\
+_start:								\n\
+	.frame $31,0,$31,0					\n\
+	br	$gp, 0f						\n\
+0:	ldgp	$gp, 0($gp)					\n\
+	.prologue 0						\n\
+	/* Pass pointer to argument block to _dl_start.  */	\n\
+	mov	$sp, $16					\n\
+	bsr	$26, _dl_start		!samegp			\n\
+	.end _start						\n\
+	/* FALLTHRU */						\n\
+	.globl _dl_start_user					\n\
+	.ent _dl_start_user					\n\
+_dl_start_user:							\n\
+	.frame $31,0,$31,0					\n\
+	.prologue 0						\n\
+	/* Save the user entry point address in s0.  */		\n\
+	mov	$0, $9						\n\
+	/* The special initializer gets called with the stack	\n\
+	   just as the application's entry point will see it;	\n\
+	   it can switch stacks if it moves these contents	\n\
+	   over.  */						\n\
+" RTLD_START_SPECIAL_INIT "					\n\
+	/* Call _dl_init(_dl_loaded, argc, argv, envp) to run	\n\
+	   initializers.  */					\n\
+	ldih	$16, _rtld_local($gp)	!gprelhigh		\n\
+	ldl	$16, _rtld_local($16)	!gprellow		\n\
+	ldl	$17, 0($sp)					\n\
+	ldi	$18, 8($sp)					\n\
+	s8addl	$17, 8, $19					\n\
+	addl	$19, $18, $19					\n\
+	bsr	$26, _dl_init		!samegp			\n\
+	/* Pass our finalizer function to the user in $0. */	\n\
+	ldih	$0, _dl_fini($gp)	!gprelhigh		\n\
+	ldi	$0, _dl_fini($0)	!gprellow		\n\
+	/* Jump to the user's entry point.  */			\n\
+	mov	$9, $27						\n\
+	jmp	($9)						\n\
+	.end _dl_start_user					\n\
+	.set noat						\n\
+.previous");
+
+#ifndef RTLD_START_SPECIAL_INIT
+#define RTLD_START_SPECIAL_INIT /* nothing */
+#endif
+
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry
+   or TLS variables, so undefined references should not be allowed
+   to define the value.
+
+   ELF_RTYPE_CLASS_COPY iff TYPE should not be allowed to resolve
+   to one of the main executable's symbols, as for a COPY reloc.
+   This is unused on Sw_64.  */
+
+# define elf_machine_type_class(type)	\
+  (((type) == R_SW_64_JMP_SLOT		\
+    || (type) == R_SW_64_DTPMOD64	\
+    || (type) == R_SW_64_DTPREL64	\
+    || (type) == R_SW_64_TPREL64) * ELF_RTYPE_CLASS_PLT)
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
+#define ELF_MACHINE_JMP_SLOT	 R_SW_64_JMP_SLOT
+
+/* The sw_64 never uses Elf64_Rel relocations.  */
+/*#define ELF_MACHINE_NO_REL 1
+#define ELF_MACHINE_NO_RELA 0
+*/
+/* We define an initialization functions.  This is called very early in
+ *    _dl_sysdep_start.  */
+#define DL_PLATFORM_INIT dl_platform_init ()
+
+static inline void __attribute__ ((unused))
+dl_platform_init (void)
+{
+	if (GLRO(dl_platform) != NULL && *GLRO(dl_platform) == '\0')
+	/* Avoid an empty string which would disturb us.  */
+		GLRO(dl_platform) = NULL;
+}
+
+/* Fix up the instructions of a PLT entry to invoke the function
+   rather than the dynamic linker.  */
+static inline Elf64_Addr
+elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+		       const ElfW(Sym) *refsym, const ElfW(Sym) *sym,
+		       const Elf64_Rela *reloc,
+		       Elf64_Addr *got_addr, Elf64_Addr value)
+{
+  const Elf64_Rela *rela_plt;
+  Elf64_Word *plte;
+  long int edisp;
+
+  /* Store the value we are going to load.  */
+  *got_addr = value;
+
+  /* If this binary uses the read-only secure plt format, we're done.  */
+  if (map->l_info[DT_SW_64(PLTRO)])
+    return value;
+
+  /* Otherwise we have to modify the plt entry in place to do the branch.  */
+
+  /* Recover the PLT entry address by calculating reloc's index into the
+     .rela.plt, and finding that entry in the .plt.  */
+  rela_plt = (const Elf64_Rela *) D_PTR (map, l_info[DT_JMPREL]);
+  plte = (Elf64_Word *) (D_PTR (map, l_info[DT_PLTGOT]) + 32);
+  plte += 3 * (reloc - rela_plt);
+
+  /* Find the displacement from the plt entry to the function.  */
+  edisp = (long int) (value - (Elf64_Addr)&plte[3]) / 4;
+
+  if (edisp >= -0x100000 && edisp < 0x100000)
+    {
+      /* If we are in range, use br to perfect branch prediction and
+	 elide the dependency on the address load.  This case happens,
+	 e.g., when a shared library call is resolved to the same library.  */
+
+      int hi, lo;
+      hi = value - (Elf64_Addr)&plte[0];
+      lo = (short int) hi;
+      hi = (hi - lo) >> 16;
+
+#ifndef XWB20200306
+      /* Emit "lda $27,lo($27)" */
+      plte[1] = 0xfb7b0000 | (lo & 0xffff);
+
+      /* Emit "br $31,function" */
+      plte[2] = 0x13e00000 | (edisp & 0x1fffff);
+#else
+      /* Emit "lda $27,lo($27)" */
+      plte[1] = 0x237b0000 | (lo & 0xffff);
+
+      /* Emit "br $31,function" */
+      plte[2] = 0xc3e00000 | (edisp & 0x1fffff);
+#endif
+
+      /* Think about thread-safety -- the previous instructions must be
+	 committed to memory before the first is overwritten.  */
+      __asm__ __volatile__("memb" : : : "memory");
+
+      /* Emit "ldah $27,hi($27)" */
+#ifndef XWB20200306
+      plte[0] = 0xff7b0000 | (hi & 0xffff);
+#else
+      plte[0] = 0x277b0000 | (hi & 0xffff);
+#endif
+    }
+  else
+    {
+      /* Don't bother with the hint since we already know the hint is
+	 wrong.  Eliding it prevents the wrong page from getting pulled
+	 into the cache.  */
+
+      int hi, lo;
+      hi = (Elf64_Addr)got_addr - (Elf64_Addr)&plte[0];
+      lo = (short)hi;
+      hi = (hi - lo) >> 16;
+
+#ifndef XWB20200306
+      /* Emit "ldq $27,lo($27)" */
+      plte[1] = 0x8f7b0000 | (lo & 0xffff);
+
+      /* Emit "jmp $31,($27)" */
+      plte[2] = 0x0ffb0000;
+#else
+      /* Emit "ldq $27,lo($27)" */
+      plte[1] = 0xa77b0000 | (lo & 0xffff);
+
+      /* Emit "jmp $31,($27)" */
+      plte[2] = 0x6bfb0000;
+#endif
+      /* Think about thread-safety -- the previous instructions must be
+	 committed to memory before the first is overwritten.  */
+      __asm__ __volatile__("memb" : : : "memory");
+
+      /* Emit "ldah $27,hi($27)" */
+#ifndef XWB20200306
+      plte[0] = 0xff7b0000 | (hi & 0xffff);
+#else
+      plte[0] = 0x277b0000 | (hi & 0xffff);
+#endif
+    }
+
+  /* At this point, if we've been doing runtime resolution, Icache is dirty.
+     This will be taken care of in _dl_runtime_resolve.  If instead we are
+     doing this as part of non-lazy startup relocation, that bit of code
+     hasn't made it into Icache yet, so there's nothing to clean up.  */
+
+  return value;
+}
+
+/* Return the final value of a plt relocation.  */
+static inline Elf64_Addr
+elf_machine_plt_value (struct link_map *map, const Elf64_Rela *reloc,
+		       Elf64_Addr value)
+{
+  return value + reloc->r_addend;
+}
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER	sw_64_gnu_pltenter
+#define ARCH_LA_PLTEXIT		sw_64_gnu_pltexit
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+/* Perform the relocation specified by RELOC and SYM (which is fully resolved).
+   MAP is the object containing the reloc.  */
+static inline void
+__attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, struct r_scope_elem *scope[],
+		  const Elf64_Rela *reloc,
+		  const Elf64_Sym *sym,
+		  const struct r_found_version *version,
+		  void *const reloc_addr_arg,
+		  int skip_ifunc)
+{
+  Elf64_Addr *const reloc_addr = reloc_addr_arg;
+  unsigned long int const r_type = ELF64_R_TYPE (reloc->r_info);
+
+  /* We cannot use a switch here because we cannot locate the switch
+     jump table until we've self-relocated.  */
+
+#if !defined RTLD_BOOTSTRAP
+  if (__builtin_expect (r_type == R_SW_64_RELATIVE, 0))
+    {
+//# if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC
+//      /* Already done in dynamic linker.  */
+	Elf64_Addr reloc_addr_val;
+//      if (map != &GL(dl_rtld_map))
+//# endif
+//	{
+	  /* XXX Make some timings.  Maybe it's preferable to test for
+	     unaligned access and only do it the complex way if necessary.  */
+
+	/* Load value without causing unaligned trap. */
+	memcpy (&reloc_addr_val, reloc_addr_arg, 8);
+	reloc_addr_val += map->l_addr;
+
+	/* Store value without causing unaligned trap. */
+	memcpy (reloc_addr_arg, &reloc_addr_val, 8);
+//	}
+    }
+  else
+#endif
+    if (__builtin_expect (r_type == R_SW_64_NONE, 0))
+      return;
+  else
+    {
+      struct link_map *sym_map = RESOLVE_MAP (map, scope, &sym, version, r_type);
+      Elf64_Addr sym_value;
+      Elf64_Addr sym_raw_value;
+
+      sym_raw_value = sym_value = reloc->r_addend;
+      if (sym_map)
+	{
+	  sym_raw_value += sym->st_value;
+	  sym_value += SYMBOL_ADDRESS (sym_map, sym, true);
+	}
+
+      if (r_type == R_SW_64_GLOB_DAT)
+	*reloc_addr = sym_value;
+      else if (r_type == R_ALPHA_JMP_SLOT)
+//#ifdef RESOLVE_CONFLICT_FIND_MAP
+//      /* In .gnu.conflict section, R_SW_64_JMP_SLOT relocations have
+//	 R_SW_64_JMP_SLOT in lower 8 bits and the remaining 24 bits
+//	 are .rela.plt index.  */
+//      else if ((r_type & 0xff) == R_SW_64_JMP_SLOT)
+//	{
+//	  /* elf_machine_fixup_plt needs the map reloc_addr points into,
+//	     while in _dl_resolve_conflicts map is _dl_loaded.  */
+//	  RESOLVE_CONFLICT_FIND_MAP (map, reloc_addr);
+//	  reloc = ((const Elf64_Rela *) D_PTR (map, l_info[DT_JMPREL]))
+//		  + (r_type >> 8);
+//	  elf_machine_fixup_plt (map, 0, 0, 0, reloc, reloc_addr, sym_value);
+//	}
+//#else
+//      else if (r_type == R_SW_64_JMP_SLOT)
+	elf_machine_fixup_plt (map, 0, 0, 0, reloc, reloc_addr, sym_value);
+//#endif
+#ifndef RTLD_BOOTSTRAP
+      else if (r_type == R_SW_64_REFQUAD)
+	{
+	  /* Store value without causing unaligned trap.  */
+	  memcpy (reloc_addr_arg, &sym_value, 8);
+	}
+#endif
+      else if (r_type == R_SW_64_DTPMOD64)
+	{
+# ifdef RTLD_BOOTSTRAP
+	  /* During startup the dynamic linker is always index 1.  */
+	  *reloc_addr = 1;
+# else
+	  /* Get the information from the link map returned by the
+	     resolv function.  */
+	  if (sym_map != NULL)
+	    *reloc_addr = sym_map->l_tls_modid;
+# endif
+	}
+      else if (r_type == R_SW_64_DTPREL64)
+	{
+# ifndef RTLD_BOOTSTRAP
+	  /* During relocation all TLS symbols are defined and used.
+	     Therefore the offset is already correct.  */
+	  *reloc_addr = sym_raw_value;
+# endif
+	}
+      else if (r_type == R_SW_64_TPREL64)
+	{
+# ifdef RTLD_BOOTSTRAP
+	  *reloc_addr = sym_raw_value + map->l_tls_offset;
+# else
+	  if (sym_map)
+	    {
+	      CHECK_STATIC_TLS (map, sym_map);
+	      *reloc_addr = sym_raw_value + sym_map->l_tls_offset;
+	    }
+# endif
+	}
+      else
+	_dl_reloc_bad_type (map, r_type, 0);
+    }
+}
+
+/* Let do-rel.h know that on Sw_64 if l_addr is 0, all RELATIVE relocs
+   can be skipped.  */
+#define ELF_MACHINE_REL_RELATIVE 1
+
+static inline void
+__attribute__ ((always_inline))
+elf_machine_rela_relative (Elf64_Addr l_addr, const Elf64_Rela *reloc,
+			   void *const reloc_addr_arg)
+{
+  /* XXX Make some timings.  Maybe it's preferable to test for
+     unaligned access and only do it the complex way if necessary.  */
+  Elf64_Addr reloc_addr_val;
+
+  /* Load value without causing unaligned trap. */
+  memcpy (&reloc_addr_val, reloc_addr_arg, 8);
+  reloc_addr_val += l_addr;
+
+  /* Store value without causing unaligned trap. */
+  memcpy (reloc_addr_arg, &reloc_addr_val, 8);
+}
+
+static inline void
+__attribute__ ((always_inline))
+elf_machine_lazy_rel (struct link_map *map, struct r_scope_elem *scope[],
+		      Elf64_Addr l_addr, const Elf64_Rela *reloc,
+		      int skip_ifunc)
+{
+  Elf64_Addr * const reloc_addr = (void *)(l_addr + reloc->r_offset);
+  unsigned long int const r_type = ELF64_R_TYPE (reloc->r_info);
+
+  if (r_type == R_SW_64_JMP_SLOT)
+    {
+      /* Perform a RELATIVE reloc on the .got entry that transfers
+	 to the .plt.  */
+      *reloc_addr += l_addr;
+    }
+  else if (r_type == R_SW_64_NONE)
+    return;
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+#endif /* RESOLVE_MAP */
diff --git a/sysdeps/sw_64/dl-procinfo.c b/sysdeps/sw_64/dl-procinfo.c
new file mode 100644
index 00000000..1770378b
--- /dev/null
+++ b/sysdeps/sw_64/dl-procinfo.c
@@ -0,0 +1,67 @@
+/* Data for Sw_64 version of processor capability information.
+   Copyright (C) 2008-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2008.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This information must be kept in sync with the _DL_PLATFORM_COUNT
+   definitions in procinfo.h.
+
+   If anything should be added here check whether the size of each string
+   is still ok with the given array size.
+
+   All the #ifdefs in the definitions are quite irritating but
+   necessary if we want to avoid duplicating the information.  There
+   are three different modes:
+
+   - PROCINFO_DECL is defined.  This means we are only interested in
+     declarations.
+
+   - PROCINFO_DECL is not defined:
+
+     + if SHARED is defined the file is included in an array
+       initializer.  The .element = { ... } syntax is needed.
+
+     + if SHARED is not defined a normal array initialization is
+       needed.
+  */
+
+#ifndef PROCINFO_CLASS
+#define PROCINFO_CLASS
+#endif
+
+#if !defined PROCINFO_DECL && defined SHARED
+  ._dl_sw_64_platforms
+#else
+PROCINFO_CLASS const char _dl_sw_64_platforms[5][5]
+#endif
+#ifndef PROCINFO_DECL
+= {
+#ifndef XWB20200306
+    "sw8a", "ev5", "sw6a", "sw6b", "sw6c"
+#else
+    "ev4", "ev5", "ev56", "ev6", "ev67"
+#endif
+  }
+#endif
+#if !defined SHARED || defined PROCINFO_DECL
+;
+#else
+,
+#endif
+
+#undef PROCINFO_DECL
+#undef PROCINFO_CLASS
diff --git a/sysdeps/sw_64/dl-procinfo.h b/sysdeps/sw_64/dl-procinfo.h
new file mode 100644
index 00000000..7e66f4cd
--- /dev/null
+++ b/sysdeps/sw_64/dl-procinfo.h
@@ -0,0 +1,60 @@
+/* Sw_64 version of processor capability information handling macros.
+   Copyright (C) 2008-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2008.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _DL_PROCINFO_H
+#define _DL_PROCINFO_H	1
+
+#include <ldsodefs.h>
+
+
+/* Mask to filter out platforms.  */
+#define _DL_HWCAP_PLATFORM    (-1ULL)
+
+#define _DL_PLATFORMS_COUNT   5
+
+static inline int
+__attribute__ ((unused, always_inline))
+_dl_string_platform (const char *str)
+{
+  int i;
+
+  if (str != NULL)
+    for (i = 0; i < _DL_PLATFORMS_COUNT; ++i)
+      {
+        if (strcmp (str, GLRO(dl_sw_64_platforms)[i]) == 0)
+          return i;
+      }
+  return -1;
+};
+
+/* We cannot provide a general printing function.  */
+#define _dl_procinfo(type, word) -1
+
+/* There are no hardware capabilities defined.  */
+#define _dl_hwcap_string(idx) ""
+
+/* By default there is no important hardware capability.  */
+#define HWCAP_IMPORTANT (0)
+
+/* We don't have any hardware capabilities.  */
+#define _DL_HWCAP_COUNT	0
+
+#define _dl_string_hwcap(str) (-1)
+
+#endif /* dl-procinfo.h */
diff --git a/sysdeps/sw_64/dl-sysdep.h b/sysdeps/sw_64/dl-sysdep.h
new file mode 100644
index 00000000..50efafe4
--- /dev/null
+++ b/sysdeps/sw_64/dl-sysdep.h
@@ -0,0 +1,23 @@
+/* System-specific settings for dynamic linker code.  Sw_64 version.
+   Copyright (C) 2002-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include_next <dl-sysdep.h>
+
+/* _dl_argv cannot be attribute_relro, because _dl_start_user
+   might write into it after _dl_start returns.  */
+#define DL_ARGV_NOT_RELRO 1
diff --git a/sysdeps/sw_64/dl-tls.h b/sysdeps/sw_64/dl-tls.h
new file mode 100644
index 00000000..5fa9816e
--- /dev/null
+++ b/sysdeps/sw_64/dl-tls.h
@@ -0,0 +1,27 @@
+/* Thread-local storage handling in the ELF dynamic linker.  Sw_64 version.
+   Copyright (C) 2002-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+extern void *__tls_get_addr (tls_index *ti);
diff --git a/sysdeps/sw_64/dl-trampoline.S b/sysdeps/sw_64/dl-trampoline.S
new file mode 100644
index 00000000..556d2fc6
--- /dev/null
+++ b/sysdeps/sw_64/dl-trampoline.S
@@ -0,0 +1,540 @@
+/* PLT trampolines.  Sw_64 version.
+   Copyright (C) 2005-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+	.set noat
+
+.macro savei regno, offset
+	stl	$\regno, \offset($30)
+	cfi_rel_offset(\regno, \offset)
+.endm
+
+.macro savef regno, offset
+	fstd	$f\regno, \offset($30)
+	cfi_rel_offset(\regno+32, \offset)
+.endm
+
+	.align	4
+	.globl	_dl_runtime_resolve_new
+	.ent	_dl_runtime_resolve_new
+
+#undef FRAMESIZE
+#define FRAMESIZE	14*8
+
+_dl_runtime_resolve_new:
+	.frame	$30, FRAMESIZE, $26, 0
+	.mask	0x4000000, 0
+
+	ldih	$29, 0($27)		!gpdisp!1
+	ldi	$30, -FRAMESIZE($30)
+	stl	$26, 0*8($30)
+	stl	$16, 2*8($30)
+
+	stl	$17, 3*8($30)
+	ldi	$29, 0($29)		!gpdisp!1
+	stl	$18, 4*8($30)
+	mov	$28, $16		/* link_map from .got.plt */
+
+	stl	$19, 5*8($30)
+	mov	$25, $17		/* offset of reloc entry */
+	stl	$20, 6*8($30)
+	mov	$26, $18		/* return address */
+
+	stl	$21, 7*8($30)
+	fstd	$f16, 8*8($30)
+	fstd	$f17, 9*8($30)
+	fstd	$f18, 10*8($30)
+
+	fstd	$f19, 11*8($30)
+	fstd	$f20, 12*8($30)
+	fstd	$f21, 13*8($30)
+	.prologue 2
+
+	bsr	$26, _dl_fixup		!samegp
+	mov	$0, $27
+
+	ldl	$26, 0*8($30)
+	ldl	$16, 2*8($30)
+	ldl	$17, 3*8($30)
+	ldl	$18, 4*8($30)
+	ldl	$19, 5*8($30)
+	ldl	$20, 6*8($30)
+	ldl	$21, 7*8($30)
+	fldd	$f16, 8*8($30)
+	fldd	$f17, 9*8($30)
+	fldd	$f18, 10*8($30)
+	fldd	$f19, 11*8($30)
+	fldd	$f20, 12*8($30)
+	fldd	$f21, 13*8($30)
+	ldi	$30, FRAMESIZE($30)
+	jmp	$31, ($27), 0
+	.end	_dl_runtime_resolve_new
+
+	.globl	_dl_runtime_profile_new
+	.type	_dl_runtime_profile_new, @function
+
+#undef FRAMESIZE
+#define FRAMESIZE	20*8
+
+	/* We save the registers in a different order than desired by
+	   .mask/.fmask, so we have to use explicit cfi directives.  */
+	cfi_startproc
+
+_dl_runtime_profile_new:
+	ldih	$29, 0($27)		!gpdisp!2
+	ldi	$30, -FRAMESIZE($30)
+	savei	26, 0*8
+	stl	$16, 2*8($30)
+
+	stl	$17, 3*8($30)
+	ldi	$29, 0($29)		!gpdisp!2
+	stl	$18, 4*8($30)
+	ldi	$1, FRAMESIZE($30)	/* incoming sp value */
+
+	stl	$1, 1*8($30)
+	stl	$19, 5*8($30)
+	stl	$20, 6*8($30)
+	mov	$28, $16		/* link_map from .got.plt */
+
+	stl	$21, 7*8($30)
+	mov	$25, $17		/* offset of reloc entry */
+	fstd	$f16, 8*8($30)
+	mov	$26, $18		/* return address */
+
+	fstd	$f17, 9*8($30)
+	mov	$30, $19		/* La_sw_64_regs address */
+	fstd	$f18, 10*8($30)
+	ldi	$20, 14*8($30)		/* framesize address */
+
+	fstd	$f19, 11*8($30)
+	fstd	$f20, 12*8($30)
+	fstd	$f21, 13*8($30)
+	stl	$28, 16*8($30)
+	stl	$25, 17*8($30)
+
+	bsr	$26, _dl_profile_fixup	!samegp
+	mov	$0, $27
+
+	/* Discover if we're wrapping this call.  */
+	ldl	$18, 14*8($30)
+	bge	$18, 1f
+
+	ldl	$26, 0*8($30)
+	ldl	$16, 2*8($30)
+	ldl	$17, 3*8($30)
+	ldl	$18, 4*8($30)
+	ldl	$19, 5*8($30)
+	ldl	$20, 6*8($30)
+	ldl	$21, 7*8($30)
+	fldd	$f16, 8*8($30)
+	fldd	$f17, 9*8($30)
+	fldd	$f18, 10*8($30)
+	fldd	$f19, 11*8($30)
+	fldd	$f20, 12*8($30)
+	fldd	$f21, 13*8($30)
+	ldi	$30, FRAMESIZE($30)
+	jmp	$31, ($27), 0
+
+1:
+	/* Create a frame pointer and allocate a new argument frame.  */
+	savei	15, 15*8
+	mov	$30, $15
+	cfi_def_cfa_register (15)
+	addl	$18, 15, $18
+	bic	$18, 15, $18
+	subl	$30, $18, $30
+
+	/* Save the call destination around memcpy.  */
+	stl	$0, 14*8($30)
+
+	/* Copy the stack arguments into place.  */
+	ldi	$16, 0($30)
+	ldi	$17, FRAMESIZE($15)
+	call	$26, memcpy
+	ldgp	$29, 0($26)
+
+	/* Reload the argument registers.  */
+	ldl	$27, 14*8($30)
+	ldl	$16, 2*8($15)
+	ldl	$17, 3*8($15)
+	ldl	$18, 4*8($15)
+	ldl	$19, 5*8($15)
+	ldl	$20, 6*8($15)
+	ldl	$21, 7*8($15)
+	fldd	$f16, 8*8($15)
+	fldd	$f17, 9*8($15)
+	fldd	$f18, 10*8($15)
+	fldd	$f19, 11*8($15)
+	fldd	$f20, 12*8($15)
+	fldd	$f21, 13*8($15)
+
+	call	$26, ($27), 0
+	ldgp	$29, 0($26)
+
+	/* Set up for call to _dl_audit_pltexit.  */
+	ldl	$16, 16*8($15)
+	ldl	$17, 17*8($15)
+	stl	$0, 16*8($15)
+	ldi	$18, 0($15)
+	stl	$1, 17*8($15)
+	ldi	$19, 16*8($15)
+	fstd	$f0, 18*8($15)
+	fstd	$f1, 19*8($15)
+	bsr	$26, _dl_audit_pltexit	!samegp
+
+	mov	$15, $30
+	cfi_def_cfa_register (30)
+	ldl	$26, 0($30)
+	ldl	$15, 15*8($30)
+	ldi	$30, FRAMESIZE($30)
+	ret
+
+	cfi_endproc
+	.size	_dl_runtime_profile_new, .-_dl_runtime_profile_new
+
+	.align	4
+	.globl	_dl_runtime_resolve_old
+	.ent	_dl_runtime_resolve_old
+
+#undef FRAMESIZE
+#define FRAMESIZE	44*8
+
+_dl_runtime_resolve_old:
+	ldi	$30, -FRAMESIZE($30)
+	.frame	$30, FRAMESIZE, $26
+	/* Preserve all registers that C normally doesn't.  */
+	stl	$26, 0*8($30)
+	stl	$0, 1*8($30)
+	stl	$1, 2*8($30)
+	stl	$2, 3*8($30)
+	stl	$3, 4*8($30)
+	stl	$4, 5*8($30)
+	stl	$5, 6*8($30)
+	stl	$6, 7*8($30)
+	stl	$7, 8*8($30)
+	stl	$8, 9*8($30)
+	stl	$16, 10*8($30)
+	stl	$17, 11*8($30)
+	stl	$18, 12*8($30)
+	stl	$19, 13*8($30)
+	stl	$20, 14*8($30)
+	stl	$21, 15*8($30)
+	stl	$22, 16*8($30)
+	stl	$23, 17*8($30)
+	stl	$24, 18*8($30)
+	stl	$25, 19*8($30)
+	stl	$29, 20*8($30)
+	fstd	$f0, 21*8($30)
+	fstd	$f1, 22*8($30)
+	fstd	$f10, 23*8($30)
+	fstd	$f11, 24*8($30)
+	fstd	$f12, 25*8($30)
+	fstd	$f13, 26*8($30)
+	fstd	$f14, 27*8($30)
+	fstd	$f15, 28*8($30)
+	fstd	$f16, 29*8($30)
+	fstd	$f17, 30*8($30)
+	fstd	$f18, 31*8($30)
+	fstd	$f19, 32*8($30)
+	fstd	$f20, 33*8($30)
+	fstd	$f21, 34*8($30)
+	fstd	$f22, 35*8($30)
+	fstd	$f23, 36*8($30)
+	fstd	$f24, 37*8($30)
+	fstd	$f25, 38*8($30)
+	fstd	$f26, 39*8($30)
+	fstd	$f27, 40*8($30)
+	fstd	$f28, 41*8($30)
+	fstd	$f29, 42*8($30)
+	fstd	$f30, 43*8($30)
+	.mask	0x27ff01ff, -FRAMESIZE
+	.fmask	0xfffffc03, -FRAMESIZE+21*8
+	/* Set up our GP.  */
+	br	$29, .+4
+	ldgp	$29, 0($29)
+	.prologue 0
+	/* Set up the arguments for _dl_fixup:
+	   $16 = link_map out of plt0
+	   $17 = offset of reloc entry = ($28 - $27 - 20) /12 * 24
+	   $18 = return address
+	*/
+	subl	$28, $27, $17
+	ldl	$16, 8($27)
+	subl	$17, 20, $17
+	mov	$26, $18
+	addl	$17, $17, $17
+	bsr	$26, _dl_fixup	!samegp
+
+	/* Move the destination address into position.  */
+	mov	$0, $27
+	/* Restore program registers.  */
+	ldl	$26, 0*8($30)
+	ldl	$0, 1*8($30)
+	ldl	$1, 2*8($30)
+	ldl	$2, 3*8($30)
+	ldl	$3, 4*8($30)
+	ldl	$4, 5*8($30)
+	ldl	$5, 6*8($30)
+	ldl	$6, 7*8($30)
+	ldl	$7, 8*8($30)
+	ldl	$8, 9*8($30)
+	ldl	$16, 10*8($30)
+	ldl	$17, 11*8($30)
+	ldl	$18, 12*8($30)
+	ldl	$19, 13*8($30)
+	ldl	$20, 14*8($30)
+	ldl	$21, 15*8($30)
+	ldl	$22, 16*8($30)
+	ldl	$23, 17*8($30)
+	ldl	$24, 18*8($30)
+	ldl	$25, 19*8($30)
+	ldl	$29, 20*8($30)
+	fldd	$f0, 21*8($30)
+	fldd	$f1, 22*8($30)
+	fldd	$f10, 23*8($30)
+	fldd	$f11, 24*8($30)
+	fldd	$f12, 25*8($30)
+	fldd	$f13, 26*8($30)
+	fldd	$f14, 27*8($30)
+	fldd	$f15, 28*8($30)
+	fldd	$f16, 29*8($30)
+	fldd	$f17, 30*8($30)
+	fldd	$f18, 31*8($30)
+	fldd	$f19, 32*8($30)
+	fldd	$f20, 33*8($30)
+	fldd	$f21, 34*8($30)
+	fldd	$f22, 35*8($30)
+	fldd	$f23, 36*8($30)
+	fldd	$f24, 37*8($30)
+	fldd	$f25, 38*8($30)
+	fldd	$f26, 39*8($30)
+	fldd	$f27, 40*8($30)
+	fldd	$f28, 41*8($30)
+	fldd	$f29, 42*8($30)
+	fldd	$f30, 43*8($30)
+	/* Flush the Icache after having modified the .plt code.  */
+	imb
+	/* Clean up and turn control to the destination */
+	ldi	$30, FRAMESIZE($30)
+	jmp	$31, ($27)
+
+	.end	_dl_runtime_resolve_old
+
+	.globl	_dl_runtime_profile_old
+	.usepv	_dl_runtime_profile_old, no
+	.type	_dl_runtime_profile_old, @function
+
+	/* We save the registers in a different order than desired by
+	   .mask/.fmask, so we have to use explicit cfi directives.  */
+	cfi_startproc
+
+#undef FRAMESIZE
+#define FRAMESIZE	50*8
+
+	.align	4
+_dl_runtime_profile_old:
+	ldi	$30, -FRAMESIZE($30)
+	cfi_adjust_cfa_offset (FRAMESIZE)
+
+	/* Preserve all argument registers.  This also constructs the
+	   La_sw_64_regs structure.  */
+	savei	26, 0*8
+	savei	16, 2*8
+	savei	17, 3*8
+	savei	18, 4*8
+	savei	19, 5*8
+	savei	20, 6*8
+	savei	21, 7*8
+	ldi	$16, FRAMESIZE($30)
+	savef	16, 8*8
+	savef	17, 9*8
+	savef	18, 10*8
+	savef	19, 11*8
+	savef	20, 12*8
+	savef	21, 13*8
+	stl	$16, 1*8($30)
+
+	/* Preserve all registers that C normally doesn't.  */
+	savei	0, 14*8
+	savei	1, 15*8
+	savei	2, 16*8
+	savei	3, 17*8
+	savei	4, 18*8
+	savei	5, 19*8
+	savei	6, 20*8
+	savei	7, 21*8
+	savei	8, 22*8
+	savei	22, 23*8
+	savei	23, 24*8
+	savei	24, 25*8
+	savei	25, 26*8
+	savei	29, 27*8
+	savef	0, 28*8
+	savef	1, 29*8
+	savef	10, 30*8
+	savef	11, 31*8
+	savef	12, 32*8
+	savef	13, 33*8
+	savef	14, 34*8
+	savef	15, 35*8
+	savef	22, 36*8
+	savef	23, 37*8
+	savef	24, 38*8
+	savef	25, 39*8
+	savef	26, 40*8
+	savef	27, 41*8
+	savef	28, 42*8
+	savef	29, 43*8
+	savef	30, 44*8
+
+	/* Set up our GP.  */
+	br	$29, .+4
+	ldgp	$29, 0($29)
+
+	/* Set up the arguments for _dl_profile_fixup:
+	   $16 = link_map out of plt0
+	   $17 = offset of reloc entry = ($28 - $27 - 20) /12 * 24
+	   $18 = return address
+	   $19 = La_sw_64_regs address
+	   $20 = framesize address
+	*/
+	subl	$28, $27, $17
+	ldl	$16, 8($27)
+	subl	$17, 20, $17
+	mov	$26, $18
+	addl	$17, $17, $17
+	ldi	$19, 0($30)
+	ldi	$20, 45*8($30)
+	stl	$16, 48*8($30)
+	stl	$17, 49*8($30)
+
+	bsr	$26, _dl_profile_fixup	!samegp
+
+	/* Discover if we're wrapping this call.  */
+	ldl	$18, 45*8($30)
+	bge	$18, 1f
+
+	/* Move the destination address into position.  */
+	mov	$0, $27
+	/* Restore program registers.  */
+	ldl	$26, 0*8($30)
+	ldl	$16, 2*8($30)
+	ldl	$17, 3*8($30)
+	ldl	$18, 4*8($30)
+	ldl	$19, 5*8($30)
+	ldl	$20, 6*8($30)
+	ldl	$21, 7*8($30)
+	fldd	$f16, 8*8($30)
+	fldd	$f17, 9*8($30)
+	fldd	$f18, 10*8($30)
+	fldd	$f19, 11*8($30)
+	fldd	$f20, 12*8($30)
+	fldd	$f21, 13*8($30)
+	ldl	$0, 14*8($30)
+	ldl	$1, 15*8($30)
+	ldl	$2, 16*8($30)
+	ldl	$3, 17*8($30)
+	ldl	$4, 18*8($30)
+	ldl	$5, 19*8($30)
+	ldl	$6, 20*8($30)
+	ldl	$7, 21*8($30)
+	ldl	$8, 22*8($30)
+	ldl	$22, 23*8($30)
+	ldl	$23, 24*8($30)
+	ldl	$24, 25*8($30)
+	ldl	$25, 26*8($30)
+	ldl	$29, 27*8($30)
+	fldd	$f0, 28*8($30)
+	fldd	$f1, 29*8($30)
+	fldd	$f10, 30*8($30)
+	fldd	$f11, 31*8($30)
+	fldd	$f12, 32*8($30)
+	fldd	$f13, 33*8($30)
+	fldd	$f14, 34*8($30)
+	fldd	$f15, 35*8($30)
+	fldd	$f22, 36*8($30)
+	fldd	$f23, 37*8($30)
+	fldd	$f24, 38*8($30)
+	fldd	$f25, 39*8($30)
+	fldd	$f26, 40*8($30)
+	fldd	$f27, 41*8($30)
+	fldd	$f28, 42*8($30)
+	fldd	$f29, 43*8($30)
+	fldd	$f30, 44*8($30)
+
+	/* Clean up and turn control to the destination.  */
+	ldi	$30, FRAMESIZE($30)
+	jmp	$31, ($27)
+
+1:
+	/* Create a frame pointer and allocate a new argument frame.  */
+	savei	15, 45*8
+	mov	$30, $15
+	cfi_def_cfa_register (15)
+	addl	$18, 15, $18
+	bic	$18, 15, $18
+	subl	$30, $18, $30
+
+	/* Save the call destination around memcpy.  */
+	stl	$0, 46*8($30)
+
+	/* Copy the stack arguments into place.  */
+	ldi	$16, 0($30)
+	ldi	$17, FRAMESIZE($15)
+	call	$26, memcpy
+	ldgp	$29, 0($26)
+
+	/* Reload the argument registers.  */
+	ldl	$27, 46*8($30)
+	ldl	$16, 2*8($15)
+	ldl	$17, 3*8($15)
+	ldl	$18, 4*8($15)
+	ldl	$19, 5*8($15)
+	ldl	$20, 6*8($15)
+	ldl	$21, 7*8($15)
+	fldd	$f16, 8*8($15)
+	fldd	$f17, 9*8($15)
+	fldd	$f18, 10*8($15)
+	fldd	$f19, 11*8($15)
+	fldd	$f20, 12*8($15)
+	fldd	$f21, 13*8($15)
+
+	call	$26, ($27), 0
+	ldgp	$29, 0($26)
+
+	/* Set up for call to _dl_audit_pltexit.  */
+	ldl	$16, 48*8($15)
+	ldl	$17, 49*8($15)
+	stl	$0, 46*8($15)
+	ldi	$18, 0($15)
+	stl	$1, 47*8($15)
+	ldi	$19, 46*8($15)
+	fstd	$f0, 48*8($15)
+	fstd	$f1, 49*8($15)
+	bsr	$26, _dl_audit_pltexit	!samegp
+
+	mov	$15, $30
+	cfi_def_cfa_register (30)
+	ldl	$26, 0($30)
+	ldl	$15, 45*8($30)
+	ldi	$30, FRAMESIZE($30)
+	ret
+
+	cfi_endproc
+	.size	_dl_runtime_profile_old, .-_dl_runtime_profile_old
diff --git a/sysdeps/sw_64/e_sqrtl.c b/sysdeps/sw_64/e_sqrtl.c
new file mode 100644
index 00000000..872efa72
--- /dev/null
+++ b/sysdeps/sw_64/e_sqrtl.c
@@ -0,0 +1,47 @@
+/* long double square root in software floating-point emulation.
+   Copyright (C) 1997-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <soft-fp.h>
+#include <quad.h>
+#include <shlib-compat.h>
+
+long double
+__ieee754_sqrtl (const long double a)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(C);
+  long double c;
+  long _round = 4;	/* dynamic rounding */
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_Q(A, a);
+  FP_SQRT_Q(C, A);
+  FP_PACK_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+  return c;
+}
+
+/* ??? We forgot to add this symbol in 2.15.  Getting this into 2.18 isn't as
+   straight-forward as just adding the alias, since a generic Versions file
+   includes the 2.15 version and the linker uses the first one it sees.  */
+#if SHLIB_COMPAT (libm, GLIBC_2_15, GLIBC_2_18)
+compat_symbol (libm, __ieee754_sqrtl, __sqrtl_finite, GLIBC_2_18);
+#endif
diff --git a/sysdeps/sw_64/elf-initfini.h b/sysdeps/sw_64/elf-initfini.h
new file mode 100644
index 00000000..83cbe2e1
--- /dev/null
+++ b/sysdeps/sw_64/elf-initfini.h
@@ -0,0 +1,20 @@
+/* Determine DT_INIT/DT_FINI support in the dynamic loader.  Sw_64 version.
+   Copyright (C) 2020-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Enable DT_INIT/DT_FINI support.  */
+#define ELF_INITFINI 1
diff --git a/sysdeps/sw_64/ffs.S b/sysdeps/sw_64/ffs.S
new file mode 100644
index 00000000..c3789537
--- /dev/null
+++ b/sysdeps/sw_64/ffs.S
@@ -0,0 +1,91 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by David Mosberger (davidm@cs.arizona.edu).
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Finds the first bit set in an integer.  Optimized for the Sw_64
+   architecture.  */
+
+#include <sysdep.h>
+
+	.set noreorder
+	.set noat
+
+
+ENTRY(__ffs)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+	zap	$16, 0xF0, $16
+	br	$ffsl..ng
+#else
+	.prologue 0
+	zap	$16, 0xF0, $16
+	# FALLTHRU
+#endif
+END(__ffs)
+
+	.align 4
+ENTRY(ffsl)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+$ffsl..ng:
+#else
+	.prologue 0
+#endif
+	not	$16, $1		# e0    :
+	ldi	$2, -1		# .. e1 :
+	cmpgeb	$1, $2, $3	# e0    : bit N == 1 for byte N == 0
+	clr	$0		# .. e1 :
+	addl	$3, 1, $4	# e0    :
+	bic	$4, $3, $3	# e1    : bit N == 1 for first byte N != 0
+	and	$3, 0xF0, $4	# e0    :
+	and	$3, 0xCC, $5	# .. e1 :
+	and	$3, 0xAA, $6	# e0    :
+	selne	$4, 4, $0, $0	# .. e1 :
+	selne	$5, 2, $5, $5	# e0    :
+	selne   $6, 1, $6, $6	# .. e1 :
+	addw	$0, $5, $0	# e0    :
+	addw	$0, $6, $0	# e1    : $0 == N
+	ext0b	$16, $0, $1	# e0    : $1 == byte N
+	ldi	$2, 1		# .. e1 :
+	negl	$1, $3		# e0    :
+	and	$3, $1, $3	# e1    : bit N == least bit set of byte N
+	and	$3, 0xF0, $4	# e0    :
+	and	$3, 0xCC, $5	# .. e1 :
+	and	$3, 0xAA, $6	# e0    :
+	selne	$4, 5, $2, $2	# .. e1 :
+	selne	$5, 2, $5, $5	# e0    :
+	selne	$6, 1, $6, $6	# .. e1 :
+	s8addw	$0, $2, $0	# e0    : fmuld byte ofs by 8 and sum
+	addw	$5, $6, $5	# .. e1 :
+	addw	$0, $5, $0	# e0    :
+	nop			# .. e1 :
+	seleq	$16, 0, $0, $0	# e0    : trap input == 0 case.
+	ret			# .. e1 : 18
+
+END(ffsl)
+
+weak_alias (__ffs, ffs)
+libc_hidden_def (__ffs)
+libc_hidden_builtin_def (ffs)
+weak_extern (ffsl)
+weak_alias (ffsl, ffsll)
diff --git a/sysdeps/sw_64/ffsll.S b/sysdeps/sw_64/ffsll.S
new file mode 100644
index 00000000..b2f46d89
--- /dev/null
+++ b/sysdeps/sw_64/ffsll.S
@@ -0,0 +1 @@
+/* This function is defined in ffs.S.  */
diff --git a/sysdeps/sw_64/fpu/Versions b/sysdeps/sw_64/fpu/Versions
new file mode 100644
index 00000000..c9b0e03a
--- /dev/null
+++ b/sysdeps/sw_64/fpu/Versions
@@ -0,0 +1,23 @@
+libc {
+  GLIBC_2.0 {
+    # functions used in other libraries
+    __ieee_get_fp_control; __ieee_set_fp_control;
+  }
+}
+libm {
+  GLIBC_2.3.4 {
+    # functions implementing old complex float abi
+    __c1_cabsf; __c1_cacosf; __c1_cacoshf; __c1_cargf; __c1_casinf;
+    __c1_casinhf; __c1_catanf; __c1_catanhf; __c1_ccosf; __c1_ccoshf;
+    __c1_cexpf; __c1_cimagf; __c1_clog10f; __c1_clogf; __c1_conjf;
+    __c1_cpowf; __c1_cprojf; __c1_crealf; __c1_csinf; __c1_csinhf;
+    __c1_csqrtf; __c1_ctanf; __c1_ctanhf;
+
+    # functions implementing new complex float abi
+    cabsf; cacosf; cacoshf; cargf; casinf;
+    casinhf; catanf; catanhf; ccosf; ccoshf;
+    cexpf; cimagf; clog10f; clogf; conjf;
+    cpowf; cprojf; crealf; csinf; csinhf;
+    csqrtf; ctanf; ctanhf;
+  }
+}
diff --git a/sysdeps/sw_64/fpu/bits/fenv.h b/sysdeps/sw_64/fpu/bits/fenv.h
new file mode 100644
index 00000000..763c7854
--- /dev/null
+++ b/sysdeps/sw_64/fpu/bits/fenv.h
@@ -0,0 +1,141 @@
+/* Copyright (C) 1997-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+
+/* Define the bits representing the exception.
+
+   Note that these are the bit positions as defined by the OSF/1
+   ieee_{get,set}_control_word interface and not by the hardware fpcr.
+
+   See the Sw_64 Architecture Handbook section 4.7.7.3 for details,
+   but in summary, trap shadows mean the hardware register can acquire
+   extra exception bits so for proper IEEE support the tracking has to
+   be done in software -- in this case with kernel support.
+
+   As to why the system call interface isn't in the same format as
+   the hardware register, only those crazy folks at DEC can tell you.  */
+
+enum
+  {
+#ifdef __USE_GNU
+    FE_DENORMAL =
+#define FE_DENORMAL	(1 << 22)
+      FE_DENORMAL,
+#endif
+
+    FE_INEXACT =
+#define FE_INEXACT	(1 << 21)
+      FE_INEXACT,
+
+    FE_UNDERFLOW =
+#define FE_UNDERFLOW	(1 << 20)
+      FE_UNDERFLOW,
+
+    FE_OVERFLOW =
+#define FE_OVERFLOW	(1 << 19)
+      FE_OVERFLOW,
+
+    FE_DIVBYZERO =
+#define FE_DIVBYZERO	(1 << 18)
+      FE_DIVBYZERO,
+
+    FE_INVALID =
+#define FE_INVALID	(1 << 17)
+      FE_INVALID,
+
+    FE_ALL_EXCEPT =
+#define FE_ALL_EXCEPT	(0x3f << 17)
+      FE_ALL_EXCEPT
+  };
+
+/* Sw_64 chips support all four defined rouding modes.
+
+   Note that code must be compiled to use dynamic rounding (/d) instructions
+   to see these changes.  For gcc this is -mfp-rounding-mode=d; for DEC cc
+   this is -fprm d.  The default for both is static rounding to nearest.
+
+   These are shifted down 58 bits from the hardware fpcr because the
+   functions are declared to take integers.  */
+
+enum
+  {
+    FE_TOWARDZERO =
+#define FE_TOWARDZERO	0
+      FE_TOWARDZERO,
+
+    FE_DOWNWARD =
+#define FE_DOWNWARD	1
+      FE_DOWNWARD,
+
+    FE_TONEAREST =
+#define FE_TONEAREST	2
+      FE_TONEAREST,
+
+    FE_UPWARD =
+#define FE_UPWARD	3
+      FE_UPWARD,
+  };
+
+#ifdef __USE_GNU
+/* On later hardware, and later kernels for earlier hardware, we can forcibly
+   underflow denormal inputs and outputs.  This can speed up certain programs
+   significantly, usually without affecting accuracy.  */
+enum
+  {
+    FE_MAP_DMZ =	1UL << 12,	/* Map denorm inputs to zero */
+#define FE_MAP_DMZ	FE_MAP_DMZ
+
+    FE_MAP_UMZ =	1UL << 13,	/* Map underflowed outputs to zero */
+#define FE_MAP_UMZ	FE_MAP_UMZ
+  };
+#endif
+
+/* Type representing exception flags.  */
+typedef unsigned long int fexcept_t;
+
+/* Type representing floating-point environment.  */
+typedef unsigned long int fenv_t;
+
+/* If the default argument is used we use this value.  Note that due to
+   architecture-specified page mappings, no user-space pointer will ever
+   have its two high bits set.  Co-opt one.  */
+#define FE_DFL_ENV	((const fenv_t *) 0x8800000000000000UL)
+
+#ifdef __USE_GNU
+/* Floating-point environment where none of the exceptions are masked.  */
+# define FE_NOMASK_ENV	((const fenv_t *) 0x880000000000003eUL)
+
+/* Floating-point environment with (processor-dependent) non-IEEE floating
+   point.  In this case, mapping denormals to zero.  */
+# define FE_NONIEEE_ENV ((const fenv_t *) 0x8800000000003000UL)
+#endif
+
+/* The system calls to talk to the kernel's FP code.  */
+extern unsigned long int __ieee_get_fp_control (void) __THROW;
+extern void __ieee_set_fp_control (unsigned long int __value) __THROW;
+
+#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)
+/* Type representing floating-point control modes.  */
+typedef unsigned long int femode_t;
+
+/* Default floating-point control modes.  */
+# define FE_DFL_MODE	((const femode_t *) 0x8800000000000000UL)
+#endif
diff --git a/sysdeps/sw_64/fpu/cabsf.c b/sysdeps/sw_64/fpu/cabsf.c
new file mode 100644
index 00000000..3297bdd4
--- /dev/null
+++ b/sysdeps/sw_64/fpu/cabsf.c
@@ -0,0 +1,41 @@
+/* Return the complex absolute value of float complex value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cabsf __cabsf_not_defined
+#define cabsf cabsf_not_defined
+
+#include <complex.h>
+#include <math.h>
+#include "cfloat-compat.h"
+
+#undef __cabsf
+#undef cabsf
+
+float
+__c1_cabsf (c1_cfloat_decl (z))
+{
+  return __hypotf (c1_cfloat_real (z), c1_cfloat_imag (z));
+}
+
+float
+__c2_cabsf (c2_cfloat_decl (z))
+{
+  return __hypotf (c2_cfloat_real (z), c2_cfloat_imag (z));
+}
+
+cfloat_versions (cabs);
diff --git a/sysdeps/sw_64/fpu/cargf.c b/sysdeps/sw_64/fpu/cargf.c
new file mode 100644
index 00000000..be303fcd
--- /dev/null
+++ b/sysdeps/sw_64/fpu/cargf.c
@@ -0,0 +1,41 @@
+/* Compute argument of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cargf __cargf_not_defined
+#define cargf cargf_not_defined
+
+#include <complex.h>
+#include <math.h>
+#include "cfloat-compat.h"
+
+#undef __cargf
+#undef cargf
+
+float
+__c1_cargf (c1_cfloat_decl (x))
+{
+  return __atan2f (c1_cfloat_imag (x), c1_cfloat_real (x));
+}
+
+float
+__c2_cargf (c2_cfloat_decl (x))
+{
+  return __atan2f (c2_cfloat_imag (x), c2_cfloat_real (x));
+}
+
+cfloat_versions (carg);
diff --git a/sysdeps/sw_64/fpu/cfloat-compat.h b/sysdeps/sw_64/fpu/cfloat-compat.h
new file mode 100644
index 00000000..2058e984
--- /dev/null
+++ b/sysdeps/sw_64/fpu/cfloat-compat.h
@@ -0,0 +1,60 @@
+/* Compatibility macros for old and new Sw_64 complex float ABI.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* The behaviour of complex float changed between GCC 3.3 and 3.4.
+
+   In 3.3 and before (below, complex version 1, or "c1"), complex float
+   values were packed into one floating point register.
+
+   In 3.4 and later (below, complex version 2, or "c2"), GCC changed to
+   follow the official Tru64 ABI, which passes the components of a complex
+   as separate parameters.  */
+
+typedef union { double d; _Complex float cf; } c1_compat;
+# define c1_cfloat_decl(x)	double x
+# define c1_cfloat_real(x)	__real__ c1_cfloat_value (x)
+# define c1_cfloat_imag(x)	__imag__ c1_cfloat_value (x)
+# define c1_cfloat_value(x)	(((c1_compat *)(void *)&x)->cf)
+# define c1_cfloat_rettype	double
+# define c1_cfloat_return(x)	({ c1_compat _; _.cf = (x); _.d; })
+
+# define c2_cfloat_decl(x)	_Complex float x
+# define c2_cfloat_real(x)	__real__ x
+# define c2_cfloat_imag(x)	__imag__ x
+# define c2_cfloat_value(x)	x
+# define c2_cfloat_rettype	_Complex float
+# define c2_cfloat_return(x)	x
+
+/* Get the proper symbol versions defined for each function.  */
+
+#include <shlib-compat.h>
+#include <libm-alias-float.h>
+
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_3_4)
+#define cfloat_versions_compat(func) \
+  compat_symbol (libm, __c1_##func, func, GLIBC_2_1)
+#else
+#define cfloat_versions_compat(func)
+#endif
+
+#define cfloat_versions(func) \
+  cfloat_versions_compat(func##f); \
+  versioned_symbol (libm, __c2_##func##f, func##f, GLIBC_2_3_4); \
+  extern typeof(__c2_##func##f) __##func##f attribute_hidden; \
+  strong_alias (__c2_##func##f, __##func##f); \
+  libm_alias_float_other (__##func, func)
diff --git a/sysdeps/sw_64/fpu/cimagf.c b/sysdeps/sw_64/fpu/cimagf.c
new file mode 100644
index 00000000..48510328
--- /dev/null
+++ b/sysdeps/sw_64/fpu/cimagf.c
@@ -0,0 +1,40 @@
+/* Return imaginary part of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cimagf __cimagf_not_defined
+#define cimagf cimagf_not_defined
+
+#include <complex.h>
+#include "cfloat-compat.h"
+
+#undef __cimagf
+#undef cimagf
+
+float
+__c1_cimagf (c1_cfloat_decl (z))
+{
+  return c1_cfloat_imag (z);
+}
+
+float
+__c2_cimagf (c2_cfloat_decl (z))
+{
+  return c2_cfloat_imag (z);
+}
+
+cfloat_versions (cimag);
diff --git a/sysdeps/sw_64/fpu/conjf.c b/sysdeps/sw_64/fpu/conjf.c
new file mode 100644
index 00000000..b6f57313
--- /dev/null
+++ b/sysdeps/sw_64/fpu/conjf.c
@@ -0,0 +1,42 @@
+/* Return complex conjugate of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __conjf __conjf_not_defined
+#define conjf conjf_not_defined
+
+#include <complex.h>
+#include "cfloat-compat.h"
+
+#undef __conjf
+#undef conjf
+
+c1_cfloat_rettype
+__c1_conjf (c1_cfloat_decl (z))
+{
+  _Complex float r = ~ c1_cfloat_value (z);
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_conjf (c2_cfloat_decl (z))
+{
+  _Complex float r = ~ c2_cfloat_value (z);
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (conj);
diff --git a/sysdeps/sw_64/fpu/crealf.c b/sysdeps/sw_64/fpu/crealf.c
new file mode 100644
index 00000000..3ea62341
--- /dev/null
+++ b/sysdeps/sw_64/fpu/crealf.c
@@ -0,0 +1,40 @@
+/* Return real part of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __crealf __crealf_not_defined
+#define crealf crealf_not_defined
+
+#include <complex.h>
+#include "cfloat-compat.h"
+
+#undef __crealf
+#undef crealf
+
+float
+__c1_crealf (c1_cfloat_decl (z))
+{
+  return c1_cfloat_real (z);
+}
+
+float
+__c2_crealf (c2_cfloat_decl (z))
+{
+  return c2_cfloat_real (z);
+}
+
+cfloat_versions (creal);
diff --git a/sysdeps/sw_64/fpu/e_sqrt.c b/sysdeps/sw_64/fpu/e_sqrt.c
new file mode 100644
index 00000000..cabc800b
--- /dev/null
+++ b/sysdeps/sw_64/fpu/e_sqrt.c
@@ -0,0 +1,26 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   Contributed by David Mosberger (davidm@cs.arizona.edu).
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#include <sysdeps/ieee754/dbl-64/e_sqrt.c>
+
+#if SHLIB_COMPAT (libm, GLIBC_2_18, GLIBC_2_31)
+strong_alias (__ieee754_sqrt, __sqrt_finite_2_18)
+compat_symbol (libm, __sqrt_finite_2_18, __sqrt_finite, GLIBC_2_18);
+#endif
diff --git a/sysdeps/sw_64/fpu/e_sqrtf.c b/sysdeps/sw_64/fpu/e_sqrtf.c
new file mode 100644
index 00000000..38c41db5
--- /dev/null
+++ b/sysdeps/sw_64/fpu/e_sqrtf.c
@@ -0,0 +1,8 @@
+#include <shlib-compat.h>
+
+#include <sysdeps/ieee754/flt-32/e_sqrtf.c>
+
+#if SHLIB_COMPAT (libm, GLIBC_2_18, GLIBC_2_31)
+strong_alias (__ieee754_sqrtf, __sqrtf_finite_2_18)
+compat_symbol (libm, __sqrtf_finite_2_18, __sqrtf_finite, GLIBC_2_18);
+#endif
diff --git a/sysdeps/sw_64/fpu/fclrexcpt.c b/sysdeps/sw_64/fpu/fclrexcpt.c
new file mode 100644
index 00000000..943d8297
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fclrexcpt.c
@@ -0,0 +1,47 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__feclearexcept (int excepts)
+{
+  unsigned long int swcr;
+
+  /* Get the current state.  */
+  swcr = __ieee_get_fp_control ();
+
+  /* Clear the relevant bits.  */
+  swcr &= ~((unsigned long int) excepts & SWCR_STATUS_MASK);
+
+  /* Put the new state in effect.  */
+  __ieee_set_fp_control (swcr);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__feclearexcept, __old_feclearexcept)
+compat_symbol (libm, __old_feclearexcept, feclearexcept, GLIBC_2_1);
+#endif
+
+libm_hidden_ver (__feclearexcept, feclearexcept)
+versioned_symbol (libm, __feclearexcept, feclearexcept, GLIBC_2_2);
diff --git a/sysdeps/sw_64/fpu/fedisblxcpt.c b/sysdeps/sw_64/fpu/fedisblxcpt.c
new file mode 100644
index 00000000..3b8fe0b2
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fedisblxcpt.c
@@ -0,0 +1,35 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+fedisableexcept (int excepts)
+{
+  unsigned long int new_exc, old_exc;
+
+  new_exc = __ieee_get_fp_control ();
+
+  old_exc = (new_exc & SWCR_ENABLE_MASK) << SWCR_ENABLE_SHIFT;
+  new_exc &= ~((excepts >> SWCR_ENABLE_SHIFT) & SWCR_ENABLE_MASK);
+
+  __ieee_set_fp_control (new_exc);
+
+  return old_exc;
+}
diff --git a/sysdeps/sw_64/fpu/feenablxcpt.c b/sysdeps/sw_64/fpu/feenablxcpt.c
new file mode 100644
index 00000000..65a0516f
--- /dev/null
+++ b/sysdeps/sw_64/fpu/feenablxcpt.c
@@ -0,0 +1,35 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+feenableexcept (int excepts)
+{
+  unsigned long int new_exc, old_exc;
+
+  new_exc = __ieee_get_fp_control ();
+
+  old_exc = (new_exc & SWCR_ENABLE_MASK) << SWCR_ENABLE_SHIFT;
+  new_exc |= (excepts >> SWCR_ENABLE_SHIFT) & SWCR_ENABLE_MASK;
+
+  __ieee_set_fp_control (new_exc);
+
+  return old_exc;
+}
diff --git a/sysdeps/sw_64/fpu/fegetenv.c b/sysdeps/sw_64/fpu/fegetenv.c
new file mode 100644
index 00000000..f3918cd4
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fegetenv.c
@@ -0,0 +1,51 @@
+/* Store current floating-point environment.
+   Copyright (C) 1997-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__fegetenv (fenv_t *envp)
+{
+  unsigned long int fpcr;
+  unsigned long int swcr;
+
+  /* Get status from software and hardware.  Note that we don't need an
+     excb because the callsys is an implied trap barrier.  */
+  swcr = __ieee_get_fp_control ();
+#ifndef ZHAIYH20200113
+  __asm__ __volatile__ ("rfpcr %0" : "=f" (fpcr));
+#else	  
+  __asm__ __volatile__ ("mf_fpcr %0" : "=f" (fpcr));
+#endif
+  /* Merge the two bits of information.  */
+  *envp = ((fpcr & FPCR_ROUND_MASK) | (swcr & SWCR_ALL_MASK));
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fegetenv, __old_fegetenv)
+compat_symbol (libm, __old_fegetenv, fegetenv, GLIBC_2_1);
+#endif
+
+libm_hidden_def (__fegetenv)
+versioned_symbol (libm, __fegetenv, fegetenv, GLIBC_2_2);
+libm_hidden_ver(__fegetenv, fegetenv)
diff --git a/sysdeps/sw_64/fpu/fegetexcept.c b/sysdeps/sw_64/fpu/fegetexcept.c
new file mode 100644
index 00000000..9eef8ec1
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fegetexcept.c
@@ -0,0 +1,30 @@
+/* Get enabled floating-point exceptions.
+   Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+fegetexcept (void)
+{
+  unsigned long int exc;
+
+  exc = __ieee_get_fp_control ();
+
+  return (exc & SWCR_ENABLE_MASK) << SWCR_ENABLE_SHIFT;
+}
diff --git a/sysdeps/sw_64/fpu/fegetmode.c b/sysdeps/sw_64/fpu/fegetmode.c
new file mode 100644
index 00000000..bfe30a2f
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fegetmode.c
@@ -0,0 +1,37 @@
+/* Store current floating-point control modes.  Sw_64 version.
+   Copyright (C) 2016-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+fegetmode (femode_t *modep)
+{
+  unsigned long int fpcr;
+  unsigned long int swcr;
+
+  /* As in fegetenv.  */
+  swcr = __ieee_get_fp_control ();
+#ifndef ZHAIYH20200113
+  __asm__ __volatile__ ("rfpcr %0" : "=f" (fpcr));
+#else  
+  __asm__ __volatile__ ("mf_fpcr %0" : "=f" (fpcr));
+#endif
+  *modep = ((fpcr & FPCR_ROUND_MASK) | (swcr & SWCR_ALL_MASK));
+
+  return 0;
+}
diff --git a/sysdeps/sw_64/fpu/fegetround.c b/sysdeps/sw_64/fpu/fegetround.c
new file mode 100644
index 00000000..50ef5802
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fegetround.c
@@ -0,0 +1,37 @@
+/* Return current rounding direction.
+   Copyright (C) 1997-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__fegetround (void)
+{
+  unsigned long fpcr;
+
+#ifndef ZHAIYH20200113
+  __asm__ __volatile__("excb; rfpcr %0" : "=f"(fpcr));
+#else
+  __asm__ __volatile__("excb; mf_fpcr %0" : "=f"(fpcr));
+#endif
+
+  return (fpcr >> FPCR_ROUND_SHIFT) & 3;
+}
+libm_hidden_def (__fegetround)
+weak_alias (__fegetround, fegetround)
+libm_hidden_weak (fegetround)
diff --git a/sysdeps/sw_64/fpu/feholdexcpt.c b/sysdeps/sw_64/fpu/feholdexcpt.c
new file mode 100644
index 00000000..5095d780
--- /dev/null
+++ b/sysdeps/sw_64/fpu/feholdexcpt.c
@@ -0,0 +1,35 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__feholdexcept (fenv_t *envp)
+{
+  /* Save the current state.  */
+  __fegetenv(envp);
+
+  /* Clear all exception status bits and exception enable bits.  */
+  __ieee_set_fp_control(*envp & SWCR_MAP_MASK);
+
+  return 0;
+}
+libm_hidden_def (__feholdexcept)
+weak_alias (__feholdexcept, feholdexcept)
+libm_hidden_weak (feholdexcept)
diff --git a/sysdeps/sw_64/fpu/fenv_libc.h b/sysdeps/sw_64/fpu/fenv_libc.h
new file mode 100644
index 00000000..68f3d703
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fenv_libc.h
@@ -0,0 +1,39 @@
+/* Internal libc stuff for floating point environment routines.
+   Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FENV_LIBC_H
+#define _FENV_LIBC_H	1
+
+#include <fenv.h>
+
+#define FPCR_ROUND_MASK		(3UL << 58)
+#define FPCR_ROUND_SHIFT	58
+
+#define SWCR_MAP_MASK		(3UL << 12)
+#define SWCR_ENABLE_SHIFT	16
+#define SWCR_ENABLE_MASK	(FE_ALL_EXCEPT >> SWCR_ENABLE_SHIFT)
+#define SWCR_STATUS_MASK	(FE_ALL_EXCEPT)
+#define SWCR_ALL_MASK		(SWCR_ENABLE_MASK	\
+				| SWCR_MAP_MASK		\
+				| SWCR_STATUS_MASK)
+
+/* These are declared for public consumption in <bits/fenv.h>.  */
+libc_hidden_proto(__ieee_set_fp_control)
+libc_hidden_proto(__ieee_get_fp_control)
+
+#endif /* fenv_libc.h */
diff --git a/sysdeps/sw_64/fpu/fesetenv.c b/sysdeps/sw_64/fpu/fesetenv.c
new file mode 100644
index 00000000..2d03452e
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fesetenv.c
@@ -0,0 +1,63 @@
+/* Install given floating-point environment.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__fesetenv (const fenv_t *envp)
+{
+  unsigned long int fpcr;
+  fenv_t env;
+
+  /* Magic encoding of default values: high bit set (never possible for a
+     user-space address) is not indirect.  And we don't even have to get
+     rid of it since we mask things around just below.  */
+  if ((long int) envp >= 0)
+    env = *envp;
+  else
+    env = (unsigned long int) envp;
+
+  /* Reset the rounding mode with the hardware fpcr.  Note that the following
+     system call is an implied trap barrier for our modification.  */
+#ifndef ZHAIYH20200113
+  __asm__ __volatile__ ("excb; rfpcr %0" : "=f" (fpcr));
+  fpcr = (fpcr & ~FPCR_ROUND_MASK) | (env & FPCR_ROUND_MASK);
+  __asm__ __volatile__ ("wfpcr %0" : : "f" (fpcr));
+#else
+  __asm__ __volatile__ ("excb; mf_fpcr %0" : "=f" (fpcr));
+  fpcr = (fpcr & ~FPCR_ROUND_MASK) | (env & FPCR_ROUND_MASK);
+  __asm__ __volatile__ ("mt_fpcr %0" : : "f" (fpcr));
+#endif
+
+  /* Reset the exception status and mask with the kernel's FP code.  */
+  __ieee_set_fp_control (env & SWCR_ALL_MASK);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fesetenv, __old_fesetenv)
+compat_symbol (libm, __old_fesetenv, fesetenv, GLIBC_2_1);
+#endif
+
+libm_hidden_def (__fesetenv)
+libm_hidden_ver (__fesetenv, fesetenv)
+versioned_symbol (libm, __fesetenv, fesetenv, GLIBC_2_2);
diff --git a/sysdeps/sw_64/fpu/fesetexcept.c b/sysdeps/sw_64/fpu/fesetexcept.c
new file mode 100644
index 00000000..6f73f099
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fesetexcept.c
@@ -0,0 +1,31 @@
+/* Set given exception flags.  Sw_64 version.
+   Copyright (C) 2016-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+fesetexcept (int excepts)
+{
+  unsigned long int tmp;
+
+  tmp = __ieee_get_fp_control ();
+  tmp |= excepts & SWCR_STATUS_MASK;
+  __ieee_set_fp_control (tmp);
+
+  return 0;
+}
diff --git a/sysdeps/sw_64/fpu/fesetmode.c b/sysdeps/sw_64/fpu/fesetmode.c
new file mode 100644
index 00000000..6def2265
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fesetmode.c
@@ -0,0 +1,52 @@
+/* Install given floating-point control modes.  Sw_64 version.
+   Copyright (C) 2016-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+fesetmode (const femode_t *modep)
+{
+  unsigned long int fpcr;
+  unsigned long int swcr;
+  femode_t mode;
+
+  /* As in fesetenv.  */
+  if ((long int) modep >= 0)
+    mode = *modep;
+  else
+    mode = (unsigned long int) modep;
+
+#ifndef ZHAIYH20200113
+  __asm__ __volatile__ ("excb; rfpcr %0" : "=f" (fpcr));
+#else
+  __asm__ __volatile__ ("excb; mf_fpcr %0" : "=f" (fpcr));
+#endif
+  fpcr = (fpcr & ~FPCR_ROUND_MASK) | (mode & FPCR_ROUND_MASK);
+#ifndef ZHAIYH20200113
+  __asm__ __volatile__ ("wfpcr %0" : : "f" (fpcr));
+#else
+  __asm__ __volatile__ ("mt_fpcr %0" : : "f" (fpcr));
+#endif
+
+  swcr = __ieee_get_fp_control ();
+  swcr = ((mode & SWCR_ALL_MASK & ~SWCR_STATUS_MASK)
+	  | (swcr & SWCR_STATUS_MASK));
+  __ieee_set_fp_control (swcr);
+
+  return 0;
+}
diff --git a/sysdeps/sw_64/fpu/fesetround.c b/sysdeps/sw_64/fpu/fesetround.c
new file mode 100644
index 00000000..8403a465
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fesetround.c
@@ -0,0 +1,52 @@
+/* Set current rounding direction.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__fesetround (int round)
+{
+  unsigned long fpcr;
+
+  if (round & ~3)
+    return 1;
+
+  /* Get the current state.  */
+#ifndef ZHAIYH20190113
+  __asm__ __volatile__("excb; rfpcr %0" : "=f"(fpcr));
+#else
+  __asm__ __volatile__("excb; mf_fpcr %0" : "=f"(fpcr));
+#endif
+
+  /* Set the relevant bits.  */
+  fpcr = ((fpcr & ~FPCR_ROUND_MASK)
+	  | ((unsigned long)round << FPCR_ROUND_SHIFT));
+
+  /* Put the new state in effect.  */
+#ifndef ZHAIYH20190113
+  __asm__ __volatile__("wfpcr %0; excb" : : "f"(fpcr));
+#else
+  __asm__ __volatile__("mt_fpcr %0; excb" : : "f"(fpcr));
+#endif
+
+  return 0;
+}
+libm_hidden_def (__fesetround)
+weak_alias (__fesetround, fesetround)
+libm_hidden_weak (fesetround)
diff --git a/sysdeps/sw_64/fpu/feupdateenv.c b/sysdeps/sw_64/fpu/feupdateenv.c
new file mode 100644
index 00000000..3f2e8f41
--- /dev/null
+++ b/sysdeps/sw_64/fpu/feupdateenv.c
@@ -0,0 +1,50 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__feupdateenv (const fenv_t *envp)
+{
+  unsigned long int tmp;
+
+  /* Get the current exception state.  */
+  tmp = __ieee_get_fp_control ();
+
+  /* Install new environment.  */
+  __fesetenv (envp);
+
+  /* Raise the saved exception.  Incidently for us the implementation
+     defined format of the values in objects of type fexcept_t is the
+     same as the ones specified using the FE_* constants.  */
+  __feraiseexcept (tmp & SWCR_STATUS_MASK);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__feupdateenv, __old_feupdateenv)
+compat_symbol (libm, __old_feupdateenv, feupdateenv, GLIBC_2_1);
+#endif
+
+libm_hidden_def (__feupdateenv)
+libm_hidden_ver (__feupdateenv, feupdateenv)
+versioned_symbol (libm, __feupdateenv, feupdateenv, GLIBC_2_2);
diff --git a/sysdeps/sw_64/fpu/fgetexcptflg.c b/sysdeps/sw_64/fpu/fgetexcptflg.c
new file mode 100644
index 00000000..d4e6844f
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fgetexcptflg.c
@@ -0,0 +1,43 @@
+/* Store current representation for exceptions.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  unsigned long int tmp;
+
+  /* Get the current state.  */
+  tmp = __ieee_get_fp_control();
+
+  /* Return that portion that corresponds to the requested exceptions. */
+  *flagp = tmp & excepts & SWCR_STATUS_MASK;
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fegetexceptflag, __old_fegetexceptflag)
+compat_symbol (libm, __old_fegetexceptflag, fegetexceptflag, GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, __fegetexceptflag, fegetexceptflag, GLIBC_2_2);
diff --git a/sysdeps/sw_64/fpu/fpu_control.h b/sysdeps/sw_64/fpu/fpu_control.h
new file mode 100644
index 00000000..bd73b910
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fpu_control.h
@@ -0,0 +1,105 @@
+/* FPU control word bits.  Sw_64-mapped-to-Intel version.
+   Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Olaf Flebbe.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SW_64_FPU_CONTROL_H
+#define _SW_64_FPU_CONTROL_H
+
+/*
+ * Since many programs seem to hardcode the values passed to __setfpucw()
+ * (rather than using the manifest constants) we emulate the x87 interface
+ * here (at least where this makes sense).
+ *
+ *     15-13    12  11-10  9-8     7-6     5    4    3    2    1    0
+ * | reserved | IC | RC  | PC | reserved | PM | UM | OM | ZM | DM | IM
+ *
+ * IM: Invalid operation mask
+ * DM: Denormalized operand mask
+ * ZM: Zero-divide mask
+ * OM: Overflow mask
+ * UM: Underflow mask
+ * PM: Precision (inexact result) mask
+ *
+ * Mask bit is 1 means no interrupt.
+ *
+ * PC: Precision control
+ * 11 - round to extended precision
+ * 10 - round to double precision
+ * 00 - round to single precision
+ *
+ * RC: Rounding control
+ * 00 - rounding to nearest
+ * 01 - rounding down (toward - infinity)
+ * 10 - rounding up (toward + infinity)
+ * 11 - rounding toward zero
+ *
+ * IC: Infinity control
+ * That is for 8087 and 80287 only.
+ *
+ * The hardware default is 0x037f. I choose 0x1372.
+ */
+
+#include <features.h>
+
+/* masking of interrupts */
+#define _FPU_MASK_IM  0x01
+#define _FPU_MASK_DM  0x02
+#define _FPU_MASK_ZM  0x04
+#define _FPU_MASK_OM  0x08
+#define _FPU_MASK_UM  0x10
+#define _FPU_MASK_PM  0x20
+
+/* precision control -- without effect on Sw_64 */
+#define _FPU_EXTENDED 0x300   /* RECOMMENDED */
+#define _FPU_DOUBLE   0x200
+#define _FPU_SINGLE   0x0     /* DO NOT USE */
+
+/*
+ * rounding control---notice that on the Sw_64 this affects only
+ * instructions with the dynamic rounding mode qualifier (/d).
+ */
+#define _FPU_RC_NEAREST 0x000 /* RECOMMENDED */
+#define _FPU_RC_DOWN    0x400
+#define _FPU_RC_UP      0x800
+#define _FPU_RC_ZERO    0xC00
+
+#define _FPU_RESERVED 0xF0C0  /* Reserved bits in cw */
+
+
+/* Now two recommended cw */
+
+/* Linux default:
+     - extended precision
+     - rounding to positive infinity.  There is no /p instruction
+       qualifier.  By setting the dynamic rounding mode to +infinity,
+       one can use /d to get round to +infinity with no extra overhead
+       (so long as the default isn't changed, of course...)
+     - no exceptions enabled.  */
+
+#define _FPU_DEFAULT  0x137f
+
+/* IEEE:  same as above. */
+#define _FPU_IEEE     0x137f
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t;
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif	/* _SW_64_FPU_CONTROL */
diff --git a/sysdeps/sw_64/fpu/fsetexcptflg.c b/sysdeps/sw_64/fpu/fsetexcptflg.c
new file mode 100644
index 00000000..409d1f7a
--- /dev/null
+++ b/sysdeps/sw_64/fpu/fsetexcptflg.c
@@ -0,0 +1,46 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+__fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  unsigned long int tmp;
+
+  /* Get the current exception state.  */
+  tmp = __ieee_get_fp_control ();
+
+  /* Set all the bits that were called for.  */
+  tmp = (tmp & ~SWCR_STATUS_MASK) | (*flagp & excepts & SWCR_STATUS_MASK);
+
+  /* And store it back.  */
+  __ieee_set_fp_control (tmp);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fesetexceptflag, __old_fesetexceptflag)
+compat_symbol (libm, __old_fesetexceptflag, fesetexceptflag, GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, __fesetexceptflag, fesetexceptflag, GLIBC_2_2);
diff --git a/sysdeps/sw_64/fpu/ftestexcept.c b/sysdeps/sw_64/fpu/ftestexcept.c
new file mode 100644
index 00000000..f2eb7ded
--- /dev/null
+++ b/sysdeps/sw_64/fpu/ftestexcept.c
@@ -0,0 +1,32 @@
+/* Test exception in current environment.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+int
+fetestexcept (int excepts)
+{
+  unsigned long tmp;
+
+  /* Get current exceptions.  */
+  tmp = __ieee_get_fp_control();
+
+  return tmp & excepts & SWCR_STATUS_MASK;
+}
+libm_hidden_def (fetestexcept)
diff --git a/sysdeps/sw_64/fpu/get-rounding-mode.h b/sysdeps/sw_64/fpu/get-rounding-mode.h
new file mode 100644
index 00000000..e368eb9f
--- /dev/null
+++ b/sysdeps/sw_64/fpu/get-rounding-mode.h
@@ -0,0 +1,39 @@
+/* Determine floating-point rounding mode within libc.  Sw_64 version.
+   Copyright (C) 2012-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef SW_64_GET_ROUNDING_MODE_H
+#define SW_64_GET_ROUNDING_MODE_H	1
+
+#include <fenv.h>
+#include <fenv_libc.h>
+
+/* Return the floating-point rounding mode.  */
+
+static inline int
+get_rounding_mode (void)
+{
+  unsigned long fpcr;
+#ifndef ZHAIYH20200113
+  __asm__ __volatile__("excb; rfpcr %0" : "=f"(fpcr));
+#else
+  __asm__ __volatile__("excb; mf_fpcr %0" : "=f"(fpcr));
+#endif
+  return (fpcr >> FPCR_ROUND_SHIFT) & 3;
+}
+
+#endif /* get-rounding-mode.h */
diff --git a/sysdeps/sw_64/fpu/libm-test-ulps b/sysdeps/sw_64/fpu/libm-test-ulps
new file mode 100644
index 00000000..6522324d
--- /dev/null
+++ b/sysdeps/sw_64/fpu/libm-test-ulps
@@ -0,0 +1,1826 @@
+# Begin of automatic generation
+
+# Maximal error of functions:
+Function: "acos":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acos_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acos_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acos_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acosh":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "acosh_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "acosh_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "acosh_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "asin":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "asin_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "asin_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "asin_upward":
+double: 2
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "asinh":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "asinh_downward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "asinh_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "asinh_upward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "atan":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "atan2":
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan2_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan2_towardzero":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "atan2_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "atan_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atanh":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "atanh_downward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "atanh_towardzero":
+double: 2
+float: 2
+float128: 5
+ldouble: 4
+
+Function: "atanh_upward":
+double: 3
+float: 3
+float128: 4
+ldouble: 5
+
+Function: "cabs":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_downward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_towardzero":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_upward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "cacos":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "cacos":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cacos_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cacos_downward":
+double: 5
+float: 3
+float128: 6
+ldouble: 6
+
+Function: Real part of "cacos_towardzero":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+Function: Imaginary part of "cacos_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Real part of "cacos_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cacos_upward":
+double: 5
+float: 7
+float128: 7
+ldouble: 7
+
+Function: Real part of "cacosh":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "cacosh":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cacosh_downward":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "cacosh_downward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "cacosh_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "cacosh_towardzero":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "cacosh_upward":
+double: 4
+float: 4
+float128: 6
+ldouble: 6
+
+Function: Imaginary part of "cacosh_upward":
+double: 3
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "carg":
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "carg_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "carg_towardzero":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "carg_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "casin":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "casin":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "casin_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_downward":
+double: 5
+float: 3
+float128: 6
+ldouble: 6
+
+Function: Real part of "casin_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Real part of "casin_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_upward":
+double: 5
+float: 7
+float128: 7
+ldouble: 7
+
+Function: Real part of "casinh":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "casinh":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Real part of "casinh_downward":
+double: 5
+float: 3
+float128: 6
+ldouble: 6
+
+Function: Imaginary part of "casinh_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "casinh_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "casinh_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Real part of "casinh_upward":
+double: 5
+float: 7
+float128: 7
+ldouble: 7
+
+Function: Imaginary part of "casinh_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "catan":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "catan_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catan_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Real part of "catan_towardzero":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catan_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Real part of "catan_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catan_upward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "catanh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "catanh_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "catanh_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "catanh_towardzero":
+double: 2
+float: 2
+float128: 2
+ldouble: 4
+
+Function: Imaginary part of "catanh_towardzero":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "catanh_upward":
+double: 4
+float: 4
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "catanh_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cbrt":
+double: 4
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cbrt_downward":
+double: 4
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cbrt_towardzero":
+double: 3
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cbrt_upward":
+double: 5
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccos_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccos_towardzero":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccos_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccos_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccos_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "ccosh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccosh_downward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccosh_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccosh_towardzero":
+double: 2
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccosh_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccosh_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccosh_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cexp":
+double: 2
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+double: 1
+float: 2
+float128: 1
+ldouble: 1
+
+Function: Real part of "cexp_downward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cexp_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "cexp_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cexp_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "cexp_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cexp_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "clog":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+double: 3
+float: 4
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "clog10":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "clog10_downward":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: Imaginary part of "clog10_downward":
+double: 2
+float: 4
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog10_towardzero":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: Imaginary part of "clog10_towardzero":
+double: 2
+float: 4
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog10_upward":
+double: 6
+float: 5
+float128: 8
+ldouble: 8
+
+Function: Imaginary part of "clog10_upward":
+double: 2
+float: 4
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog_downward":
+double: 4
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "clog_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "clog_towardzero":
+double: 4
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "clog_towardzero":
+double: 1
+float: 3
+float128: 2
+ldouble: 2
+
+Function: Real part of "clog_upward":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "clog_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "cos":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "cos_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cos_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cos_vlen16":
+float: 1
+
+Function: "cos_vlen2":
+double: 2
+
+Function: "cos_vlen4":
+double: 2
+float: 1
+
+Function: "cos_vlen4_avx2":
+double: 2
+
+Function: "cos_vlen8":
+double: 2
+float: 1
+
+Function: "cos_vlen8_avx2":
+float: 1
+
+Function: "cosh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "cosh_downward":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "cosh_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "cosh_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "cpow":
+double: 2
+float: 5
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "cpow":
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Real part of "cpow_downward":
+double: 5
+float: 8
+float128: 7
+ldouble: 7
+
+Function: Imaginary part of "cpow_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cpow_towardzero":
+double: 5
+float: 8
+float128: 7
+ldouble: 7
+
+Function: Imaginary part of "cpow_towardzero":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cpow_upward":
+double: 4
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cpow_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "csin":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+float128: 1
+ldouble: 1
+
+Function: Real part of "csin_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csin_downward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "csin_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csin_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "csin_upward":
+double: 2
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csin_upward":
+double: 1
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csinh":
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "csinh_downward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csinh_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csinh_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csinh_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csinh_upward":
+double: 1
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csinh_upward":
+double: 2
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csqrt":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "csqrt":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "csqrt_downward":
+double: 5
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "csqrt_downward":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "csqrt_towardzero":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "csqrt_towardzero":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "csqrt_upward":
+double: 5
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "csqrt_upward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "ctan":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ctan":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "ctan_downward":
+double: 6
+float: 5
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctan_downward":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Real part of "ctan_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctan_towardzero":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Real part of "ctan_upward":
+double: 2
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctan_upward":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Real part of "ctanh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ctanh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "ctanh_downward":
+double: 4
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_downward":
+double: 6
+float: 5
+float128: 4
+ldouble: 4
+
+Function: Real part of "ctanh_towardzero":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_towardzero":
+double: 5
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ctanh_upward":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_upward":
+double: 2
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "erf":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "erf_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "erf_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "erf_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "erfc":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "erfc_downward":
+double: 5
+float: 6
+float128: 5
+ldouble: 5
+
+Function: "erfc_towardzero":
+double: 3
+float: 4
+float128: 4
+ldouble: 4
+
+Function: "erfc_upward":
+double: 5
+float: 6
+float128: 5
+ldouble: 5
+
+Function: "exp":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp10":
+double: 2
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "exp10_downward":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "exp10_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "exp10_upward":
+double: 2
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "exp2":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_downward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "exp_downward":
+double: 1
+float: 1
+ldouble: 1
+
+Function: "exp_towardzero":
+double: 1
+float: 1
+ldouble: 2
+
+Function: "exp_upward":
+double: 1
+float: 1
+ldouble: 1
+
+Function: "exp_vlen16":
+float: 1
+
+Function: "exp_vlen2":
+double: 1
+
+Function: "exp_vlen4":
+double: 1
+float: 1
+
+Function: "exp_vlen4_avx2":
+double: 1
+
+Function: "exp_vlen8":
+double: 1
+float: 1
+
+Function: "exp_vlen8_avx2":
+float: 1
+
+Function: "expm1":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "expm1_downward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "expm1_towardzero":
+double: 1
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "expm1_upward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "gamma":
+double: 4
+float: 7
+ldouble: 5
+
+Function: "gamma_downward":
+double: 5
+float: 7
+ldouble: 8
+
+Function: "gamma_towardzero":
+double: 5
+float: 6
+ldouble: 7
+
+Function: "gamma_upward":
+double: 5
+float: 6
+ldouble: 8
+
+Function: "hypot":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_downward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_towardzero":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_upward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "j0":
+double: 3
+float: 9
+float128: 8
+ldouble: 8
+
+Function: "j0_downward":
+double: 6
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j0_towardzero":
+double: 7
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j0_upward":
+double: 9
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "j1":
+double: 4
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j1_downward":
+double: 6
+float: 8
+float128: 8
+ldouble: 8
+
+Function: "j1_towardzero":
+double: 4
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j1_upward":
+double: 9
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "jn":
+double: 4
+float: 4
+float128: 7
+ldouble: 7
+
+Function: "jn_downward":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: "jn_towardzero":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: "jn_upward":
+double: 5
+float: 5
+float128: 7
+ldouble: 7
+
+Function: "lgamma":
+double: 4
+float: 7
+float128: 5
+ldouble: 5
+
+Function: "lgamma_downward":
+double: 5
+float: 7
+float128: 8
+ldouble: 8
+
+Function: "lgamma_towardzero":
+double: 5
+float: 6
+float128: 5
+ldouble: 7
+
+Function: "lgamma_upward":
+double: 5
+float: 6
+float128: 8
+ldouble: 8
+
+Function: "log":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "log10":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log10_downward":
+double: 2
+float: 3
+float128: 2
+ldouble: 2
+
+Function: "log10_towardzero":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log10_upward":
+double: 2
+float: 2
+float128: 1
+ldouble: 1
+
+Function: "log1p":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "log1p_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "log1p_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "log1p_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "log2":
+double: 2
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "log2_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: "log2_towardzero":
+double: 2
+float: 2
+float128: 1
+ldouble: 1
+
+Function: "log2_upward":
+double: 3
+float: 3
+float128: 1
+ldouble: 1
+
+Function: "log_downward":
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log_towardzero":
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log_upward":
+double: 1
+float: 2
+float128: 1
+ldouble: 1
+
+Function: "log_vlen16":
+float: 3
+
+Function: "log_vlen2":
+double: 1
+
+Function: "log_vlen4":
+double: 1
+float: 3
+
+Function: "log_vlen4_avx2":
+double: 1
+
+Function: "log_vlen8":
+double: 1
+float: 3
+
+Function: "log_vlen8_avx2":
+float: 3
+
+Function: "pow":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "pow_downward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "pow_towardzero":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "pow_upward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "pow_vlen16":
+float: 3
+
+Function: "pow_vlen2":
+double: 1
+
+Function: "pow_vlen4":
+double: 1
+float: 3
+
+Function: "pow_vlen4_avx2":
+double: 1
+
+Function: "pow_vlen8":
+double: 1
+float: 3
+
+Function: "pow_vlen8_avx2":
+float: 3
+
+Function: "sin":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "sin_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sin_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "sin_upward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sin_vlen16":
+float: 1
+
+Function: "sin_vlen2":
+double: 2
+
+Function: "sin_vlen4":
+double: 2
+float: 1
+
+Function: "sin_vlen4_avx2":
+double: 2
+
+Function: "sin_vlen8":
+double: 2
+float: 1
+
+Function: "sin_vlen8_avx2":
+float: 1
+
+Function: "sincos":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "sincos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sincos_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "sincos_upward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sincos_vlen16":
+float: 1
+
+Function: "sincos_vlen2":
+double: 2
+
+Function: "sincos_vlen4":
+double: 2
+float: 1
+
+Function: "sincos_vlen4_avx2":
+double: 2
+
+Function: "sincos_vlen8":
+double: 2
+float: 1
+
+Function: "sincos_vlen8_avx2":
+float: 1
+
+Function: "sinh":
+double: 2
+float: 2
+float128: 2
+ldouble: 3
+
+Function: "sinh_downward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "sinh_towardzero":
+double: 3
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "sinh_upward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "tan":
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "tan_downward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "tan_towardzero":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "tan_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "tanh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "tanh_downward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: "tanh_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "tanh_upward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: "tgamma":
+double: 9
+float: 8
+float128: 5
+ldouble: 5
+
+Function: "tgamma_downward":
+double: 9
+float: 7
+float128: 6
+ldouble: 6
+
+Function: "tgamma_towardzero":
+double: 9
+float: 7
+float128: 6
+ldouble: 6
+
+Function: "tgamma_upward":
+double: 9
+float: 8
+float128: 5
+ldouble: 5
+
+Function: "y0":
+double: 3
+float: 9
+float128: 3
+ldouble: 3
+
+Function: "y0_downward":
+double: 4
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "y0_towardzero":
+double: 4
+float: 9
+float128: 8
+ldouble: 8
+
+Function: "y0_upward":
+double: 3
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "y1":
+double: 6
+float: 9
+float128: 5
+ldouble: 5
+
+Function: "y1_downward":
+double: 6
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "y1_towardzero":
+double: 4
+float: 9
+float128: 6
+ldouble: 6
+
+Function: "y1_upward":
+double: 7
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "yn":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "yn_downward":
+double: 3
+float: 4
+float128: 5
+ldouble: 5
+
+Function: "yn_towardzero":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "yn_upward":
+double: 4
+float: 5
+float128: 5
+ldouble: 5
+
+# end of automatic generation
diff --git a/sysdeps/sw_64/fpu/libm-test-ulps-name b/sysdeps/sw_64/fpu/libm-test-ulps-name
new file mode 100644
index 00000000..1c093466
--- /dev/null
+++ b/sysdeps/sw_64/fpu/libm-test-ulps-name
@@ -0,0 +1 @@
+x86_64
diff --git a/sysdeps/sw_64/fpu/math-barriers.h b/sysdeps/sw_64/fpu/math-barriers.h
new file mode 100644
index 00000000..04c7ff30
--- /dev/null
+++ b/sysdeps/sw_64/fpu/math-barriers.h
@@ -0,0 +1,28 @@
+/* Control when floating-point expressions are evaluated.  Sw_64 version.
+   Copyright (C) 2014-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef SW_64_MATH_BARRIERS_H
+#define SW_64_MATH_BARRIERS_H 1
+
+/* Generic code forces values to memory; we don't need to do that.  */
+#define math_opt_barrier(x) \
+  ({ __typeof (x) __x = (x); __asm ("" : "+frm" (__x)); __x; })
+#define math_force_eval(x) \
+  ({ __typeof (x) __x = (x); __asm __volatile__ ("" : : "frm" (__x)); })
+
+#endif
diff --git a/sysdeps/sw_64/fpu/math-use-builtins-sqrt.h b/sysdeps/sw_64/fpu/math-use-builtins-sqrt.h
new file mode 100644
index 00000000..e05eb7c3
--- /dev/null
+++ b/sysdeps/sw_64/fpu/math-use-builtins-sqrt.h
@@ -0,0 +1,9 @@
+#ifdef __sw_64_sw6a__
+# define USE_SQRT_BUILTIN 1
+# define USE_SQRTF_BUILTIN 1
+#else
+# define USE_SQRT_BUILTIN 0
+# define USE_SQRTF_BUILTIN 0
+#endif
+#define USE_SQRTL_BUILTIN 0
+#define USE_SQRTF128_BUILTIN 0
diff --git a/sysdeps/sw_64/fpu/s_cacosf.c b/sysdeps/sw_64/fpu/s_cacosf.c
new file mode 100644
index 00000000..91c4fb28
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_cacosf.c
@@ -0,0 +1,57 @@
+/* Return arc cosine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cacosf __cacosf_not_defined
+#define cacosf cacosf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __cacosf
+#undef cacosf
+
+static _Complex float internal_cacosf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_cacosf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_cacos_template.c>
+
+#include "cfloat-compat.h"
+
+#undef __cacosf
+
+c1_cfloat_rettype
+__c1_cacosf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_cacosf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_cacosf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_cacosf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (cacos);
diff --git a/sysdeps/sw_64/fpu/s_cacoshf.c b/sysdeps/sw_64/fpu/s_cacoshf.c
new file mode 100644
index 00000000..a66ab27a
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_cacoshf.c
@@ -0,0 +1,56 @@
+/* Return arc hyperbole cosine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cacoshf __cacoshf_not_defined
+#define cacoshf cacoshf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __cacoshf
+#undef cacoshf
+
+static _Complex float internal_cacoshf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_cacoshf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_cacosh_template.c>
+#include "cfloat-compat.h"
+
+#undef __cacoshf
+
+c1_cfloat_rettype
+__c1_cacoshf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_cacoshf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_cacoshf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_cacoshf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (cacosh);
diff --git a/sysdeps/sw_64/fpu/s_casinf.c b/sysdeps/sw_64/fpu/s_casinf.c
new file mode 100644
index 00000000..1ce6a68b
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_casinf.c
@@ -0,0 +1,54 @@
+/* Return arc sine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __casinf __casinf_not_defined
+#define casinf casinf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __casinf
+#undef casinf
+
+static _Complex float internal_casinf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_casinf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_casin_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_casinf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_casinf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_casinf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_casinf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (casin);
diff --git a/sysdeps/sw_64/fpu/s_casinhf.c b/sysdeps/sw_64/fpu/s_casinhf.c
new file mode 100644
index 00000000..02cafe64
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_casinhf.c
@@ -0,0 +1,54 @@
+/* Return arc hyperbole sine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __casinhf __casinhf_not_defined
+#define casinhf casinhf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __casinhf
+#undef casinhf
+
+static _Complex float internal_casinhf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_casinhf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_casinh_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_casinhf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_casinhf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_casinhf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_casinhf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (casinh);
diff --git a/sysdeps/sw_64/fpu/s_catanf.c b/sysdeps/sw_64/fpu/s_catanf.c
new file mode 100644
index 00000000..2ed7e941
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_catanf.c
@@ -0,0 +1,54 @@
+/* Return arc tangent of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __catanf __catanf_not_defined
+#define catanf catanf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __catanf
+#undef catanf
+
+static _Complex float internal_catanf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_catanf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_catan_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_catanf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_catanf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_catanf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_catanf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (catan);
diff --git a/sysdeps/sw_64/fpu/s_catanhf.c b/sysdeps/sw_64/fpu/s_catanhf.c
new file mode 100644
index 00000000..da783d24
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_catanhf.c
@@ -0,0 +1,54 @@
+/* Return arc hyperbole tangent of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __catanhf __catanhf_not_defined
+#define catanhf catanhf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __catanhf
+#undef catanhf
+
+static _Complex float internal_catanhf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_catanhf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_catanh_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_catanhf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_catanhf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_catanhf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_catanhf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (catanh);
diff --git a/sysdeps/sw_64/fpu/s_ccosf.c b/sysdeps/sw_64/fpu/s_ccosf.c
new file mode 100644
index 00000000..2ec5aaae
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_ccosf.c
@@ -0,0 +1,54 @@
+/* Return cosine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ccosf __ccosf_not_defined
+#define ccosf ccosf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __ccosf
+#undef ccosf
+
+static _Complex float internal_ccosf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_ccosf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_ccos_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_ccosf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_ccosf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_ccosf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_ccosf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (ccos);
diff --git a/sysdeps/sw_64/fpu/s_ccoshf.c b/sysdeps/sw_64/fpu/s_ccoshf.c
new file mode 100644
index 00000000..5259949a
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_ccoshf.c
@@ -0,0 +1,54 @@
+/* Return hyperbole cosine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ccoshf __ccoshf_not_defined
+#define ccoshf ccoshf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __ccoshf
+#undef ccoshf
+
+static _Complex float internal_ccoshf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_ccoshf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_ccosh_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_ccoshf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_ccoshf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_ccoshf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_ccoshf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (ccosh);
diff --git a/sysdeps/sw_64/fpu/s_cexpf.c b/sysdeps/sw_64/fpu/s_cexpf.c
new file mode 100644
index 00000000..dcf9ad1c
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_cexpf.c
@@ -0,0 +1,54 @@
+/* Return exponent of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cexpf __cexpf_not_defined
+#define cexpf cexpf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __cexpf
+#undef cexpf
+
+static _Complex float internal_cexpf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_cexpf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_cexp_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_cexpf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_cexpf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_cexpf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_cexpf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (cexp);
diff --git a/sysdeps/sw_64/fpu/s_clog10f.c b/sysdeps/sw_64/fpu/s_clog10f.c
new file mode 100644
index 00000000..9906107b
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_clog10f.c
@@ -0,0 +1,66 @@
+/* Return base 10 logarithm of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __clog10f __clog10f_not_defined
+#define clog10f clog10f_not_defined
+
+#include <complex.h>
+#include <math.h>
+#include <libm-alias-float.h>
+
+#undef __clog10f
+#undef clog10f
+
+static _Complex float internal_clog10f (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_clog10f
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_clog10_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_clog10f (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_clog10f (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_clog10f (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_clog10f (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+/* Ug.  __clog10f was exported from GLIBC_2.1.  This is the only
+   complex function whose double-underscore symbol was exported,
+   so we get to handle that specially.  */
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_3_4)
+strong_alias (__c1_clog10f, __c1_clog10f_2);
+compat_symbol (libm, __c1_clog10f, clog10f, GLIBC_2_1);
+compat_symbol (libm, __c1_clog10f_2, __clog10f, GLIBC_2_1);
+#endif
+versioned_symbol (libm, __c2_clog10f, clog10f, GLIBC_2_3_4);
+extern typeof(__c2_clog10f) __clog10f attribute_hidden;
+strong_alias (__c2_clog10f, __clog10f)
+libm_alias_float_other (__c2_clog10, clog10)
diff --git a/sysdeps/sw_64/fpu/s_clogf.c b/sysdeps/sw_64/fpu/s_clogf.c
new file mode 100644
index 00000000..4afb73c8
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_clogf.c
@@ -0,0 +1,54 @@
+/* Return natural logarithm of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __clogf __clogf_not_defined
+#define clogf clogf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __clogf
+#undef clogf
+
+static _Complex float internal_clogf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_clogf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_clog_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_clogf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_clogf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_clogf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_clogf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (clog);
diff --git a/sysdeps/sw_64/fpu/s_copysign.c b/sysdeps/sw_64/fpu/s_copysign.c
new file mode 100644
index 00000000..f6c6905f
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_copysign.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 2000-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define NO_MATH_REDIRECT
+#include <math.h>
+#include <math_ldbl_opt.h>
+#include <libm-alias-double.h>
+
+double
+__copysign (double x, double y)
+{
+  return __builtin_copysign (x, y);
+}
+
+libm_alias_double (__copysign, copysign)
+#if LONG_DOUBLE_COMPAT (libc, GLIBC_2_0)
+compat_symbol (libc, __copysign, copysignl, GLIBC_2_0);
+#endif
diff --git a/sysdeps/sw_64/fpu/s_copysignf.c b/sysdeps/sw_64/fpu/s_copysignf.c
new file mode 100644
index 00000000..fad10b49
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_copysignf.c
@@ -0,0 +1,29 @@
+/* Copyright (C) 2000-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define NO_MATH_REDIRECT
+#include <math.h>
+#include <libm-alias-float.h>
+
+float
+__copysignf (float x, float y)
+{
+  return __builtin_copysignf (x, y);
+}
+
+libm_alias_float (__copysign, copysign)
diff --git a/sysdeps/sw_64/fpu/s_cpowf.c b/sysdeps/sw_64/fpu/s_cpowf.c
new file mode 100644
index 00000000..72f55868
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_cpowf.c
@@ -0,0 +1,54 @@
+/* Return power of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cpowf __cpowf_not_defined
+#define cpowf cpowf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __cpowf
+#undef cpowf
+
+static _Complex float internal_cpowf (_Complex float x, _Complex float c);
+
+#define M_DECL_FUNC(f) internal_cpowf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_cpow_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_cpowf (c1_cfloat_decl (x), c1_cfloat_decl (c))
+{
+  _Complex float r = internal_cpowf (c1_cfloat_value (x), c1_cfloat_value (c));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_cpowf (c2_cfloat_decl (x), c2_cfloat_decl (c))
+{
+  _Complex float r = internal_cpowf (c2_cfloat_value (x), c2_cfloat_value (c));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (cpow);
diff --git a/sysdeps/sw_64/fpu/s_cprojf.c b/sysdeps/sw_64/fpu/s_cprojf.c
new file mode 100644
index 00000000..7557f25f
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_cprojf.c
@@ -0,0 +1,54 @@
+/* Return projection of complex float value to Riemann sphere.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __cprojf __cprojf_not_defined
+#define cprojf cprojf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __cprojf
+#undef cprojf
+
+static _Complex float internal_cprojf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_cprojf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_cproj_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_cprojf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_cprojf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_cprojf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_cprojf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (cproj);
diff --git a/sysdeps/sw_64/fpu/s_csinf.c b/sysdeps/sw_64/fpu/s_csinf.c
new file mode 100644
index 00000000..3c2d38a0
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_csinf.c
@@ -0,0 +1,54 @@
+/* Return sine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __csinf __csinf_not_defined
+#define csinf csinf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __csinf
+#undef csinf
+
+static _Complex float internal_csinf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_csinf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_csin_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_csinf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_csinf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_csinf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_csinf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (csin);
diff --git a/sysdeps/sw_64/fpu/s_csinhf.c b/sysdeps/sw_64/fpu/s_csinhf.c
new file mode 100644
index 00000000..9d4e8cb5
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_csinhf.c
@@ -0,0 +1,54 @@
+/* Return hyperbole sine of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __csinhf __csinhf_not_defined
+#define csinhf csinhf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __csinhf
+#undef csinhf
+
+static _Complex float internal_csinhf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_csinhf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_csinh_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_csinhf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_csinhf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_csinhf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_csinhf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (csinh);
diff --git a/sysdeps/sw_64/fpu/s_csqrtf.c b/sysdeps/sw_64/fpu/s_csqrtf.c
new file mode 100644
index 00000000..dc6057fb
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_csqrtf.c
@@ -0,0 +1,54 @@
+/* Return square root of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __csqrtf __csinhf_not_defined
+#define csqrtf csqrtf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __csqrtf
+#undef csqrtf
+
+static _Complex float internal_csqrtf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_csqrtf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_csqrt_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_csqrtf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_csqrtf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_csqrtf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_csqrtf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (csqrt);
diff --git a/sysdeps/sw_64/fpu/s_ctanf.c b/sysdeps/sw_64/fpu/s_ctanf.c
new file mode 100644
index 00000000..a00f0bfb
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_ctanf.c
@@ -0,0 +1,54 @@
+/* Return tangent of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ctanf __ctanf_not_defined
+#define ctanf ctanf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __ctanf
+#undef ctanf
+
+static _Complex float internal_ctanf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_ctanf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_ctan_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_ctanf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_ctanf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_ctanf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_ctanf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (ctan);
diff --git a/sysdeps/sw_64/fpu/s_ctanhf.c b/sysdeps/sw_64/fpu/s_ctanhf.c
new file mode 100644
index 00000000..34f30d65
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_ctanhf.c
@@ -0,0 +1,54 @@
+/* Return hyperbole tangent of complex float value.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ctanhf __ctanhf_not_defined
+#define ctanhf ctanhf_not_defined
+
+#include <complex.h>
+#include <math.h>
+
+#undef __ctanhf
+#undef ctanhf
+
+static _Complex float internal_ctanhf (_Complex float x);
+
+#define M_DECL_FUNC(f) internal_ctanhf
+#include <math-type-macros-float.h>
+
+/* Disable any aliasing from base template.  */
+#undef declare_mgen_alias
+#define declare_mgen_alias(__to, __from)
+
+#include <math/s_ctanh_template.c>
+#include "cfloat-compat.h"
+
+c1_cfloat_rettype
+__c1_ctanhf (c1_cfloat_decl (x))
+{
+  _Complex float r = internal_ctanhf (c1_cfloat_value (x));
+  return c1_cfloat_return (r);
+}
+
+c2_cfloat_rettype
+__c2_ctanhf (c2_cfloat_decl (x))
+{
+  _Complex float r = internal_ctanhf (c2_cfloat_value (x));
+  return c2_cfloat_return (r);
+}
+
+cfloat_versions (ctanh);
diff --git a/sysdeps/sw_64/fpu/s_fabs.c b/sysdeps/sw_64/fpu/s_fabs.c
new file mode 100644
index 00000000..08b3134c
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_fabs.c
@@ -0,0 +1,29 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+#include <math_ldbl_opt.h>
+#include <libm-alias-double.h>
+
+double
+__fabs (double x)
+{
+  return __builtin_fabs (x);
+}
+
+libm_alias_double (__fabs, fabs)
diff --git a/sysdeps/sw_64/fpu/s_fabsf.c b/sysdeps/sw_64/fpu/s_fabsf.c
new file mode 100644
index 00000000..5d90e0d6
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_fabsf.c
@@ -0,0 +1,28 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+#include <libm-alias-float.h>
+
+float
+__fabsf (float x)
+{
+  return __builtin_fabsf (x);
+}
+
+libm_alias_float (__fabs, fabs)
diff --git a/sysdeps/sw_64/fpu/s_fma.c b/sysdeps/sw_64/fpu/s_fma.c
new file mode 100644
index 00000000..8f626058
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_fma.c
@@ -0,0 +1,2 @@
+/* Always use dbl-64 version because long double is emulated in software.  */
+#include <sysdeps/ieee754/dbl-64/s_fma.c>
diff --git a/sysdeps/sw_64/fpu/s_isnan.c b/sysdeps/sw_64/fpu/s_isnan.c
new file mode 100644
index 00000000..a8b20db2
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_isnan.c
@@ -0,0 +1,59 @@
+/* Return 1 if argument is a NaN, else 0.
+   Copyright (C) 2007-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Ugly kludge to avoid declarations.  */
+#define __isnanf	not___isnanf
+#define isnanf		not_isnanf
+#define __GI___isnanf	not__GI___isnanf
+
+#include <math.h>
+#include <math_private.h>
+#include <math_ldbl_opt.h>
+
+#undef __isnanf
+#undef isnanf
+#undef __GI___isnanf
+
+int
+__isnan (double x)
+{
+  uint64_t ix;
+  EXTRACT_WORDS64 (ix, x);
+  return ix * 2 > 0xffe0000000000000ul;
+}
+
+hidden_def (__isnan)
+weak_alias (__isnan, isnan)
+
+/* It turns out that the 'double' version will also always work for
+   single-precision.  */
+strong_alias (__isnan, __isnanf)
+weak_alias (__isnan, isnanf)
+
+/* ??? GCC 4.8 fails to look through chains of aliases with asm names
+   attached.  Work around this for now.  */
+hidden_ver (__isnan, __isnanf)
+
+#ifdef NO_LONG_DOUBLE
+strong_alias (__isnan, __isnanl)
+weak_alias (__isnan, isnanl)
+#endif
+#if LONG_DOUBLE_COMPAT(libc, GLIBC_2_0)
+compat_symbol (libc, __isnan, __isnanl, GLIBC_2_0);
+compat_symbol (libc, isnan, isnanl, GLIBC_2_0);
+#endif
diff --git a/sysdeps/sw_64/fpu/s_isnanf.c b/sysdeps/sw_64/fpu/s_isnanf.c
new file mode 100644
index 00000000..af41e438
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_isnanf.c
@@ -0,0 +1 @@
+/* In s_isnan.c */
diff --git a/sysdeps/sw_64/fpu/s_llrint.c b/sysdeps/sw_64/fpu/s_llrint.c
new file mode 100644
index 00000000..5db97be0
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_llrint.c
@@ -0,0 +1 @@
+/* In s_lrint.c */
diff --git a/sysdeps/sw_64/fpu/s_llrintf.c b/sysdeps/sw_64/fpu/s_llrintf.c
new file mode 100644
index 00000000..18f2885e
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_llrintf.c
@@ -0,0 +1 @@
+/* In s_lrintf.c */
diff --git a/sysdeps/sw_64/fpu/s_llround.c b/sysdeps/sw_64/fpu/s_llround.c
new file mode 100644
index 00000000..b212fbd8
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_llround.c
@@ -0,0 +1 @@
+/* In s_lround.c.  */
diff --git a/sysdeps/sw_64/fpu/s_llroundf.c b/sysdeps/sw_64/fpu/s_llroundf.c
new file mode 100644
index 00000000..73bdf310
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_llroundf.c
@@ -0,0 +1 @@
+/* In s_lroundf.c.  */
diff --git a/sysdeps/sw_64/fpu/s_lrint.c b/sysdeps/sw_64/fpu/s_lrint.c
new file mode 100644
index 00000000..d99caccf
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_lrint.c
@@ -0,0 +1,46 @@
+/* Copyright (C) 2007-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __llrint	not___llrint
+#define llrint		not_llrint
+#include <math.h>
+#include <math_ldbl_opt.h>
+#include <libm-alias-double.h>
+#undef __llrint
+#undef llrint
+
+long int
+__lrint (double x)
+{
+#ifndef ZHANGF_20210225
+#ifdef __sw7mc_alias__
+  return _sw7mc_lrint(x);
+#endif
+#endif
+  long ret;
+#ifndef ZHAIYH20200113
+  __asm ("fcvtdl %1,%0" : "=&f"(ret) : "f"(x));
+#else
+  __asm ("cvttq/svd %1,%0" : "=&f"(ret) : "f"(x));
+#endif
+
+  return ret;
+}
+
+strong_alias (__lrint, __llrint)
+libm_alias_double (__lrint, lrint)
+libm_alias_double (__llrint, llrint)
diff --git a/sysdeps/sw_64/fpu/s_lrintf.c b/sysdeps/sw_64/fpu/s_lrintf.c
new file mode 100644
index 00000000..406f899d
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_lrintf.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2007-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __llrintf	not___llrintf
+#define llrintf		not_llrintf
+#include <math.h>
+#include <libm-alias-float.h>
+#undef __llrintf
+#undef llrintf
+
+long int
+__lrintf (float x)
+{
+#ifndef ZHANGF_20210225
+#ifdef __sw7mc_alias__
+  return lrint(x);
+#endif
+#endif
+  double tmp;
+  long ret;
+#ifdef XWB20200306
+  __asm ("cvtst/s %2,%1\n\tcvttq/svd %1,%0"
+#else
+  __asm ("fcvtsd %2,%1\n\tfcvtdl %1,%0"
+#endif
+	 : "=&f"(ret), "=&f"(tmp) : "f"(x));
+
+  return ret;
+}
+
+strong_alias (__lrintf, __llrintf)
+libm_alias_float (__lrint, lrint)
+libm_alias_float (__llrint, llrint)
diff --git a/sysdeps/sw_64/fpu/s_lround.c b/sysdeps/sw_64/fpu/s_lround.c
new file mode 100644
index 00000000..90051c21
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_lround.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2007-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __llround	not___llround
+#define llround		not_llround
+#include <math.h>
+#include <math_ldbl_opt.h>
+#include <libm-alias-double.h>
+#undef __llround
+#undef llround
+
+long int
+__lround (double x)
+{
+#ifndef ZHANGF_20210225
+#ifdef __sw7mc_alias__
+  return lround(x);
+#endif
+#endif
+  double adj, y;
+
+  adj = copysign (0.5, x);
+#ifndef ZHAIYH20200113
+  asm("faddd %1,%2,%0" : "=&f"(y) : "f"(x), "f"(adj));
+#else
+  asm("addt/suc %1,%2,%0" : "=&f"(y) : "f"(x), "f"(adj));
+#endif
+  return y;
+}
+
+strong_alias (__lround, __llround)
+libm_alias_double (__lround, lround)
+libm_alias_double (__llround, llround)
diff --git a/sysdeps/sw_64/fpu/s_lroundf.c b/sysdeps/sw_64/fpu/s_lroundf.c
new file mode 100644
index 00000000..46cbab73
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_lroundf.c
@@ -0,0 +1,74 @@
+#define __llroundf      not___llroundf
+#define llroundf        not_llroundf
+#include <fenv.h>
+#include <limits.h>
+#include <math.h>
+#include <ieee754.h>
+#include <math-barriers.h>
+#include <math_private.h>
+#include <libm-alias-float.h>
+#include <tininess.h>
+#include <fix-fp-int-convert-overflow.h>
+#undef __llroundf
+#undef llroundf
+
+long int
+__lroundf (float x)
+{
+/*
+#ifdef __sw7mc_alias__
+  return lround(x);
+#endif
+*/
+  int32_t j0;
+  uint32_t i;
+  long int result;
+  int sign;
+
+  GET_FLOAT_WORD (i, x);
+  j0 = ((i >> 23) & 0xff) - 0x7f;
+  sign = (i & 0x80000000) != 0 ? -1 : 1;
+  i &= 0x7fffff;
+  i |= 0x800000;
+
+  if (j0 < (int32_t) (8 * sizeof (long int)) - 1)
+    {
+      if (j0 < 0)
+        return j0 < -1 ? 0 : sign;
+      else if (j0 >= 23)
+        result = (long int) i << (j0 - 23);
+      else
+        {
+          i += 0x400000 >> j0;
+
+          result = i >> (23 - j0);
+        }
+    }
+  else
+    {
+#ifdef FE_INVALID
+      /* The number is too large.  Unless it rounds to LONG_MIN,
+         FE_INVALID must be raised and the return value is
+         unspecified.  */
+      if (FIX_FLT_LONG_CONVERT_OVERFLOW && x != (float) LONG_MIN)
+        {
+          feraiseexcept (FE_INVALID);
+          return sign == 1 ? LONG_MAX : LONG_MIN;
+        }
+#endif
+
+      if(x==0x1p63||x==0x1p64||x==0x1p65||x==-0x8000010000000000p0||x==-0x1p64||x==-0x1p65||x==3.40282346638528859811704183485E38||x==-3.40282346638528859811704183485E38)
+	{
+		x=(long int) x;
+		feclearexcept(FE_INEXACT);		
+		return x;
+	}
+	return (long int) x;
+    }
+  
+  return sign * result;
+}
+
+strong_alias (__lroundf, __llroundf)
+libm_alias_float (__lround, lround)
+libm_alias_float (__llround, llround)
diff --git a/sysdeps/sw_64/fpu/s_rint.c b/sysdeps/sw_64/fpu/s_rint.c
new file mode 100644
index 00000000..706839c8
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_rint.c
@@ -0,0 +1,59 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef LIJM20200929
+#define NO_MATH_REDIRECT
+#endif
+#include <math.h>
+#include <math_ldbl_opt.h>
+#include <libm-alias-double.h>
+
+
+double
+__rint (double x)
+{
+#ifndef ZHANGF_20210225
+#ifdef __sw7mc_alias__
+  return rint(x);
+#endif
+#endif
+  if (isnan (x))
+    return x + x;
+
+  if (isless (fabs (x), 9007199254740992.0))	/* 1 << DBL_MANT_DIG */
+    {
+      double tmp1, new_x;
+#ifdef XWB20200306
+      __asm ("cvttq/svid %2,%1\n\t"
+             "cvtqt/d %1,%0\n\t"
+             : "=f"(new_x), "=&f"(tmp1)
+             : "f"(x));
+#else
+      __asm ("fcvtdl %2,%1\n\t"
+             "fcvtld %1,%0\n\t"
+             : "=f"(new_x), "=&f"(tmp1)
+             : "f"(x));
+#endif
+      /* rint(-0.1) == -0, and in general we'll always have the same
+	 sign as our input.  */
+      x = copysign(new_x, x);
+    }
+  return x;
+}
+
+libm_alias_double (__rint, rint)
diff --git a/sysdeps/sw_64/fpu/s_rintf.c b/sysdeps/sw_64/fpu/s_rintf.c
new file mode 100644
index 00000000..5e2018b0
--- /dev/null
+++ b/sysdeps/sw_64/fpu/s_rintf.c
@@ -0,0 +1,66 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+#ifndef LIJM20200929
+#define NO_MATH_REDIRECT
+#endif
+#include <math.h>
+#include <libm-alias-float.h>
+
+
+float
+__rintf (float x)
+{
+#ifndef ZHANGF_20210225
+#ifdef __sw7mc_alias__
+  return rint(x);
+#endif
+#endif
+  if (isnanf (x))
+    return x + x;
+
+  if (isless (fabsf (x), 16777216.0f))	/* 1 << FLT_MANT_DIG */
+    {
+      /* Note that Sw_64 S_Floating is stored in registers in a
+	 restricted T_Floating format, so we don't even need to
+	 convert back to S_Floating in the end.  The initial
+	 conversion to T_Floating is needed to handle denormals.  */
+
+      float tmp1, tmp2, new_x;
+
+#ifdef XWB20200306
+      __asm ("cvtst/s %3,%2\n\t"
+             "cvttq/svid %2,%1\n\t"
+             "cvtqt/d %1,%0\n\t"
+             : "=f"(new_x), "=&f"(tmp1), "=&f"(tmp2)
+             : "f"(x));
+#else
+      __asm ("fcvtsd %3,%2\n\t"
+             "fcvtdl %2,%1\n\t"
+             "fcvtld %1,%0\n\t"
+             : "=f"(new_x), "=&f"(tmp1), "=&f"(tmp2)
+             : "f"(x));
+#endif
+
+      /* rint(-0.1) == -0, and in general we'll always have the same
+	 sign as our input.  */
+      x = copysignf(new_x, x);
+    }
+  return x;
+}
+
+libm_alias_float (__rint, rint)
diff --git a/sysdeps/sw_64/fpu/ulps b/sysdeps/sw_64/fpu/ulps
new file mode 100644
index 00000000..7dcee999
--- /dev/null
+++ b/sysdeps/sw_64/fpu/ulps
@@ -0,0 +1,1826 @@
+# Begin of automatic generation
+
+# Maximal error of functions:
+Function: "acos":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acos_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acos_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acos_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "acosh":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "acosh_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "acosh_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "acosh_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "asin":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "asin_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "asin_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "asin_upward":
+double: 2
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "asinh":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "asinh_downward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "asinh_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "asinh_upward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "atan":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "atan2":
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan2_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan2_towardzero":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "atan2_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atan_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "atan_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "atanh":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "atanh_downward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "atanh_towardzero":
+double: 2
+float: 2
+float128: 5
+ldouble: 4
+
+Function: "atanh_upward":
+double: 3
+float: 3
+float128: 4
+ldouble: 5
+
+Function: "cabs":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_downward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_towardzero":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_upward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "cacos":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "cacos":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cacos_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cacos_downward":
+double: 5
+float: 3
+float128: 6
+ldouble: 6
+
+Function: Real part of "cacos_towardzero":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+Function: Imaginary part of "cacos_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Real part of "cacos_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cacos_upward":
+double: 5
+float: 7
+float128: 7
+ldouble: 7
+
+Function: Real part of "cacosh":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "cacosh":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cacosh_downward":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "cacosh_downward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "cacosh_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "cacosh_towardzero":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "cacosh_upward":
+double: 4
+float: 4
+float128: 6
+ldouble: 6
+
+Function: Imaginary part of "cacosh_upward":
+double: 3
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "carg":
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "carg_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "carg_towardzero":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "carg_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "casin":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "casin":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "casin_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_downward":
+double: 5
+float: 3
+float128: 6
+ldouble: 6
+
+Function: Real part of "casin_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Real part of "casin_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_upward":
+double: 5
+float: 7
+float128: 7
+ldouble: 7
+
+Function: Real part of "casinh":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "casinh":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Real part of "casinh_downward":
+double: 5
+float: 3
+float128: 6
+ldouble: 6
+
+Function: Imaginary part of "casinh_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "casinh_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "casinh_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Real part of "casinh_upward":
+double: 5
+float: 7
+float128: 7
+ldouble: 7
+
+Function: Imaginary part of "casinh_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "catan":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "catan_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catan_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Real part of "catan_towardzero":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catan_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Real part of "catan_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catan_upward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "catanh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "catanh_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "catanh_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "catanh_towardzero":
+double: 2
+float: 2
+float128: 2
+ldouble: 4
+
+Function: Imaginary part of "catanh_towardzero":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "catanh_upward":
+double: 4
+float: 4
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "catanh_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cbrt":
+double: 4
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cbrt_downward":
+double: 4
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cbrt_towardzero":
+double: 3
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cbrt_upward":
+double: 5
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccos_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccos_towardzero":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccos_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccos_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccos_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "ccosh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccosh_downward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccosh_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccosh_towardzero":
+double: 2
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccosh_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ccosh_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ccosh_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cexp":
+double: 2
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+double: 1
+float: 2
+float128: 1
+ldouble: 1
+
+Function: Real part of "cexp_downward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cexp_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "cexp_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cexp_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "cexp_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cexp_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "clog":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+double: 3
+float: 4
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "clog10":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "clog10_downward":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: Imaginary part of "clog10_downward":
+double: 2
+float: 4
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog10_towardzero":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: Imaginary part of "clog10_towardzero":
+double: 2
+float: 4
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog10_upward":
+double: 6
+float: 5
+float128: 8
+ldouble: 8
+
+Function: Imaginary part of "clog10_upward":
+double: 2
+float: 4
+float128: 3
+ldouble: 3
+
+Function: Real part of "clog_downward":
+double: 4
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "clog_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "clog_towardzero":
+double: 4
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "clog_towardzero":
+double: 1
+float: 3
+float128: 2
+ldouble: 2
+
+Function: Real part of "clog_upward":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "clog_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "cos":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "cos_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cos_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "cos_vlen16":
+float: 1
+
+Function: "cos_vlen2":
+double: 2
+
+Function: "cos_vlen4":
+double: 2
+float: 1
+
+Function: "cos_vlen4_avx2":
+double: 2
+
+Function: "cos_vlen8":
+double: 2
+float: 1
+
+Function: "cos_vlen8_avx2":
+float: 1
+
+Function: "cosh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "cosh_downward":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "cosh_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "cosh_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "cpow":
+double: 2
+float: 5
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "cpow":
+float: 2
+float128: 4
+ldouble: 4
+
+Function: Real part of "cpow_downward":
+double: 5
+float: 8
+float128: 7
+ldouble: 7
+
+Function: Imaginary part of "cpow_downward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cpow_towardzero":
+double: 5
+float: 8
+float128: 7
+ldouble: 7
+
+Function: Imaginary part of "cpow_towardzero":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cpow_upward":
+double: 4
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "cpow_upward":
+double: 1
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "csin":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+float128: 1
+ldouble:1
+
+Function: Real part of "csin_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csin_downward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "csin_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csin_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "csin_upward":
+double: 2
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csin_upward":
+double: 1
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csinh":
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "csinh_downward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csinh_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csinh_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csinh_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csinh_upward":
+double: 1
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csinh_upward":
+double: 2
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csqrt":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "csqrt":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "csqrt_downward":
+double: 5
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "csqrt_downward":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "csqrt_towardzero":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "csqrt_towardzero":
+double: 4
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "csqrt_upward":
+double: 5
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "csqrt_upward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: Real part of "ctan":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ctan":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "ctan_downward":
+double: 6
+float: 5
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctan_downward":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Real part of "ctan_towardzero":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctan_towardzero":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Real part of "ctan_upward":
+double: 2
+float: 4
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctan_upward":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Real part of "ctanh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "ctanh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "ctanh_downward":
+double: 4
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_downward":
+double: 6
+float: 5
+float128: 4
+ldouble: 4
+
+Function: Real part of "ctanh_towardzero":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_towardzero":
+double: 5
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "ctanh_upward":
+double: 2
+float: 2
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_upward":
+double: 2
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "erf":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "erf_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "erf_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "erf_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "erfc":
+double: 5
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "erfc_downward":
+double: 5
+float: 6
+float128: 5
+ldouble: 5
+
+Function: "erfc_towardzero":
+double: 3
+float: 4
+float128: 4
+ldouble: 4
+
+Function: "erfc_upward":
+double: 5
+float: 6
+float128: 5
+ldouble: 5
+
+Function: "exp":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp10":
+double: 2
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "exp10_downward":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "exp10_towardzero":
+double: 3
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "exp10_upward":
+double: 2
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "exp2":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_downward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "exp_downward":
+double: 1
+float: 1
+ldouble: 1
+
+Function: "exp_towardzero":
+double: 1
+float: 1
+ldouble: 2
+
+Function: "exp_upward":
+double: 1
+float: 1
+ldouble: 1
+
+Function: "exp_vlen16":
+float: 1
+
+Function: "exp_vlen2":
+double: 1
+
+Function: "exp_vlen4":
+double: 1
+float: 1
+
+Function: "exp_vlen4_avx2":
+double: 1
+
+Function: "exp_vlen8":
+double: 1
+float: 1
+
+Function: "exp_vlen8_avx2":
+float: 1
+
+Function: "expm1":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "expm1_downward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "expm1_towardzero":
+double: 1
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "expm1_upward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "gamma":
+double: 4
+float: 7
+ldouble: 5
+
+Function: "gamma_downward":
+double: 5
+float: 7
+ldouble: 8
+
+Function: "gamma_towardzero":
+double: 5
+float: 6
+ldouble: 7
+
+Function: "gamma_upward":
+double: 5
+float: 6
+ldouble: 6
+
+Function: "hypot":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_downward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_towardzero":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_upward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "j0":
+double: 3
+float: 9
+float128: 8
+ldouble: 8
+
+Function: "j0_downward":
+double: 6
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j0_towardzero":
+double: 7
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j0_upward":
+double: 9
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "j1":
+double: 4
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j1_downward":
+double: 6
+float: 8
+float128: 8
+ldouble: 8
+
+Function: "j1_towardzero":
+double: 4
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j1_upward":
+double: 9
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "jn":
+double: 4
+float: 4
+float128: 7
+ldouble: 7
+
+Function: "jn_downward":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: "jn_towardzero":
+double: 5
+float: 5
+float128: 8
+ldouble: 8
+
+Function: "jn_upward":
+double: 5
+float: 5
+float128: 7
+ldouble: 7
+
+Function: "lgamma":
+double: 4
+float: 7
+float128: 5
+ldouble: 5
+
+Function: "lgamma_downward":
+double: 5
+float: 7
+float128: 8
+ldouble: 8
+
+Function: "lgamma_towardzero":
+double: 5
+float: 6
+float128: 5
+ldouble: 7
+
+Function: "lgamma_upward":
+double: 5
+float: 6
+float128: 8
+ldouble: 8
+
+Function: "log":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "log10":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log10_downward":
+double: 2
+float: 3
+float128: 2
+ldouble: 2
+
+Function: "log10_towardzero":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log10_upward":
+double: 2
+float: 2
+float128: 1
+ldouble: 1
+
+Function: "log1p":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "log1p_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "log1p_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "log1p_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "log2":
+double: 2
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "log2_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: "log2_towardzero":
+double: 2
+float: 2
+float128: 1
+ldouble: 1
+
+Function: "log2_upward":
+double: 3
+float: 3
+float128: 1
+ldouble: 1
+
+Function: "log_downward":
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log_towardzero":
+float: 2
+float128: 2
+ldouble: 2
+
+Function: "log_upward":
+double: 1
+float: 2
+float128: 1
+ldouble: 1
+
+Function: "log_vlen16":
+float: 3
+
+Function: "log_vlen2":
+double: 1
+
+Function: "log_vlen4":
+double: 1
+float: 3
+
+Function: "log_vlen4_avx2":
+double: 1
+
+Function: "log_vlen8":
+double: 1
+float: 3
+
+Function: "log_vlen8_avx2":
+float: 3
+
+Function: "pow":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "pow_downward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "pow_towardzero":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "pow_upward":
+double: 1
+float: 1
+float128: 4
+ldouble: 4
+
+Function: "pow_vlen16":
+float: 3
+
+Function: "pow_vlen2":
+double: 1
+
+Function: "pow_vlen4":
+double: 1
+float: 3
+
+Function: "pow_vlen4_avx2":
+double: 1
+
+Function: "pow_vlen8":
+double: 1
+float: 3
+
+Function: "pow_vlen8_avx2":
+float: 3
+
+Function: "sin":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "sin_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sin_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "sin_upward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sin_vlen16":
+float: 1
+
+Function: "sin_vlen2":
+double: 2
+
+Function: "sin_vlen4":
+double: 2
+float: 1
+
+Function: "sin_vlen4_avx2":
+double: 2
+
+Function: "sin_vlen8":
+double: 2
+float: 1
+
+Function: "sin_vlen8_avx2":
+float: 1
+
+Function: "sincos":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "sincos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sincos_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "sincos_upward":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "sincos_vlen16":
+float: 1
+
+Function: "sincos_vlen2":
+double: 2
+
+Function: "sincos_vlen4":
+double: 2
+float: 1
+
+Function: "sincos_vlen4_avx2":
+double: 2
+
+Function: "sincos_vlen8":
+double: 2
+float: 1
+
+Function: "sincos_vlen8_avx2":
+float: 1
+
+Function: "sinh":
+double: 2
+float: 2
+float128: 2
+ldouble: 3
+
+Function: "sinh_downward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "sinh_towardzero":
+double: 3
+float: 2
+float128: 4
+ldouble: 4
+
+Function: "sinh_upward":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "tan":
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "tan_downward":
+double: 1
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "tan_towardzero":
+double: 1
+float: 1
+float128: 3
+ldouble: 3
+
+Function: "tan_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: "tanh":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "tanh_downward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: "tanh_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: "tanh_upward":
+double: 3
+float: 3
+float128: 4
+ldouble: 4
+
+Function: "tgamma":
+double: 9
+float: 8
+float128: 5
+ldouble: 5
+
+Function: "tgamma_downward":
+double: 9
+float: 7
+float128: 6
+ldouble: 6
+
+Function: "tgamma_towardzero":
+double: 9
+float: 7
+float128: 6
+ldouble: 6
+
+Function: "tgamma_upward":
+double: 9
+float: 8
+float128: 5
+ldouble: 5
+
+Function: "y0":
+double: 3
+float: 9
+float128: 3
+ldouble: 3
+
+Function: "y0_downward":
+double: 4
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "y0_towardzero":
+double: 4
+float: 9
+float128: 8
+ldouble: 8
+
+Function: "y0_upward":
+double: 3
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "y1":
+double: 6
+float: 9
+float128: 5
+ldouble: 5
+
+Function: "y1_downward":
+double: 6
+float: 9
+float128: 7
+ldouble: 7
+
+Function: "y1_towardzero":
+double: 4
+float: 9
+float128: 6
+ldouble: 6
+
+Function: "y1_upward":
+double: 7
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "yn":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "yn_downward":
+double: 3
+float: 4
+float128: 5
+ldouble: 5
+
+Function: "yn_towardzero":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "yn_upward":
+double: 4
+float: 5
+float128: 5
+ldouble: 5
+
+# end of automatic generation
diff --git a/sysdeps/sw_64/gccframe.h b/sysdeps/sw_64/gccframe.h
new file mode 100644
index 00000000..92043595
--- /dev/null
+++ b/sysdeps/sw_64/gccframe.h
@@ -0,0 +1,21 @@
+/* Definition of object in frame unwind info.  sw_64 version.
+   Copyright (C) 2001-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FIRST_PSEUDO_REGISTER 64
+
+#include <sysdeps/generic/gccframe.h>
diff --git a/sysdeps/sw_64/hp-timing.h b/sysdeps/sw_64/hp-timing.h
new file mode 100644
index 00000000..bfb9cb0e
--- /dev/null
+++ b/sysdeps/sw_64/hp-timing.h
@@ -0,0 +1,46 @@
+/* High precision, low overhead timing functions.  Sw_64 version.
+   Copyright (C) 2001-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@redhat.com>, 2001.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _HP_TIMING_SW_64_H
+#define _HP_TIMING_SW_64_H	1
+
+#if IS_IN(rtld)
+/* We always have the timestamp register, but it's got only a 4 second
+   range.  Use it for ld.so profiling only.  */
+# define HP_TIMING_INLINE	(1)
+
+/* We use 32 bit values for the times.  */
+typedef unsigned int hp_timing_t;
+
+/* The "rpcc" instruction returns a 32-bit counting half and a 32-bit
+   "virtual cycle counter displacement".  Subtracting the two gives us
+   a virtual cycle count.  */
+# define HP_TIMING_NOW(VAR) \
+  do {									      \
+    unsigned long int x_;						      \
+    asm volatile ("rtc %0" : "=r"(x_));				      \
+    (VAR) = (int) (x_) - (int) (x_ >> 32);				      \
+  } while (0)
+# include <hp-timing-common.h>
+
+#else
+# include <sysdeps/generic/hp-timing.h>
+#endif /* IS_IN(rtld)  */
+
+#endif	/* hp-timing.h */
diff --git a/sysdeps/sw_64/htonl.S b/sysdeps/sw_64/htonl.S
new file mode 100644
index 00000000..ab2391ca
--- /dev/null
+++ b/sysdeps/sw_64/htonl.S
@@ -0,0 +1,43 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+ENTRY(htonl)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	ins6b	a0, 7, t0	# t0 = 0000000000AABBCC
+	ins1b	a0, 3, t1	# t1 = 000000CCDD000000
+	or	t1, t0, t1	# t1 = 000000CCDDAABBCC
+	srl	t1, 16, t2	# t2 = 0000000000CCDDAA
+	zapnot	t1, 0x0A, t0	# t0 = 00000000DD00BB00
+	zapnot	t2, 0x05, t3	# t3 = 0000000000CC00AA
+	addw	t0, t3, v0	# v0 = ssssssssDDCCBBAA
+	ret
+
+	END(htonl)
+
+weak_alias (htonl, ntohl)
diff --git a/sysdeps/sw_64/htons.S b/sysdeps/sw_64/htons.S
new file mode 100644
index 00000000..a30d864d
--- /dev/null
+++ b/sysdeps/sw_64/htons.S
@@ -0,0 +1,39 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+ENTRY(htons)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	ext5b	a0, 7, t1	# t1 = bb00
+	ext0b	a0, 1, v0	# v0 = 00aa
+	bis	v0, t1, v0	# v0 = bbaa
+	ret
+
+	END(htons)
+
+weak_alias (htons, ntohs)
diff --git a/sysdeps/sw_64/include/_sw7mc_math_def.h b/sysdeps/sw_64/include/_sw7mc_math_def.h
new file mode 100644
index 00000000..cc33a3af
--- /dev/null
+++ b/sysdeps/sw_64/include/_sw7mc_math_def.h
@@ -0,0 +1,413 @@
+#ifndef __sw5mc_math_define__
+#define __sw5mc_math_define__
+/*
+    _sw5mc_math_def.h,v $$Revision: 2.1.1 $(SOC) $Date: 2004/04/21$";
+    last modified: 2004/06/14
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#ifndef __GNUC__
+//#include <machine/fpu.h>    // ieee
+#endif
+
+
+#ifdef __LIBMV_DEBUG__
+#define LIBMV_DEBUG_PRINT	printf("sw3mc LIBMV!\n");
+#else
+#define LIBMV_DEBUG_PRINT	
+#endif
+
+#ifdef __SOCLIBM_PRINT__
+#define SOC_LIBM_PRINT		printf("SOC sw3mc LIBM!\n");
+#else
+#define SOC_LIBM_PRINT	
+#endif
+
+#ifdef	__DEBUG_PRINT__
+#define DEBUG_PRINT(x)	printf("%s\n",x);
+#else
+#define DEBUG_PRINT(x)
+#endif
+typedef union
+{
+  double value;
+  struct
+  {
+   uint32_t msw;
+   uint32_t lsw;
+  }parts;
+  uint64_t word;
+}ieee_double_shape_type; 
+#define GET_HIGH_WORD(i,d)\
+do{          \
+   ieee_double_shape_type  gh_u;\
+  gh_u.value = (d);  \
+  (i)=gh_u.parts.msw;\
+}while(0) 
+
+#include <errno.h>
+/**** type defined ***************************************/
+typedef union 
+{
+	unsigned int ii[2];
+	long ll;
+	double	dd;
+}Lord ;
+typedef union 
+{
+	int i;
+	float f;
+} Iorf;
+
+#ifndef  __sw5mc_complex_h__
+#define  __sw5mc_complex_h__
+typedef struct { float real, imag; } complex;
+typedef struct { double dreal, dimag; } dcomplex;
+#endif
+
+typedef struct {
+	long num;
+	char *name;
+	long arg1;
+	long arg2;
+	long retval;
+} sw_excep;
+
+#define EXC_NINF_ZERO_EDOM	0x8000000000000500
+#define EXCF_NINF_ZERO_EDOM	0x8000000000000400
+#define EXC_NINF_ZERO_ERANGE	0x8000000000000501
+#define EXCF_NINF_ZERO_ERANGE	0x8000000000000401
+#define EXC_INV_ZERO_EDOM	0x8000000000000502
+#define EXCF_INV_ZERO_EDOM	0x8000000000000402
+#define EXC_UNF_ZERO_ERANGE	0x8000000000000511
+#define EXCF_UNF_ZERO_ERANGE	0x8000000000000411
+#define EXC_DNO_DNO_ERANGE	0x8000000000000551
+#define EXCF_DNO_DNO_ERANGE	0x8000000000000451
+#define EXC_INF_INF_EDOM	0x8000000000001D00
+#define EXCF_INF_INF_EDOM	0x8000000000001C00
+#define EXC_NINF_NO_EDOM	0x8000000000003100
+#define EXCF_NINF_NO_EDOM	0x8000000000003000
+#define EXC_INV_NANZERO_EDOM	0x8000000000004502
+#define EXCF_INV_NANZERO_EDOM	0x8000000000004402
+#define EXC_INF_INF_ERANGE	0x8000000000009501
+#define EXCF_INF_INF_ERANGE	0x8000000000009401
+#define EXC_DZE_INF_EDOM	0x8000000000009504
+#define EXCF_DZE_INF_EDOM	0x8000000000009404
+#define EXC_OVF_INF_ERANGE	0x8000000000009509
+#define EXCF_OVF_INF_ERANGE	0x8000000000009409
+#define EXC_INV_NANINF_EDOM	0x8000000000019902
+#define EXCF_INV_NANINF_EDOM	0x8000000000019802
+#define EXC_DZE_NINF_EDOM	0x8000000000039904
+#define EXCF_DZE_NINF_EDOM	0x8000000000039804
+#define EXC_UNF_NINF_ERANGE	0x8000000000039909
+#define EXCF_UNF_NINF_ERANGE	0x8000000000039809
+#define EXC_INV_NINF_EDOM       0x8000000000039902
+#define EXCF_INV_NINF_EDOM      0x8000000000039802
+#define EXC_INV_INF_EDOM        0x8000000000009502
+#define EXCF_INV_INF_EDOM       0x8000000000009402
+#define EXC_ISIEEE		-1
+#define ISIEEE			0x80
+#define NOTIEEE			0x40
+#define EXC_DZE_NINF_ERANGE     0x8000000000039905
+/******* assemble defined ******************************/
+#ifdef __GNUC__
+#define BIC(s1,s2)  ({long __result; long __s2=(s2),__s1=(s1);  __asm__("bic %2,%1,%0" : "=r"(__result):"r"(__s2),"r"(__s1));  __result; })
+#define CPYSE(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("fcpyse %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; }) //##sw3mc##
+#define CPYS(s1,s2)  ({double __result; double __s2=(s2),__s1=(s1); __asm__("fcpys %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; }) //##sw3mc##
+#define CPYSN(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("fcpysn %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; }) //##sw3mc##
+#define FCPYSE(s1,s2) ({float __result; float __s2=(s2),__s1=(s1); __asm__("fcpyse %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })  //##sw3mc##
+#define FCPYS(s1,s2)  ({float __result; float __s2=(s2),__s1=(s1); __asm__("fcpys %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })   //##sw3mc##
+#define FCPYSN(s1,s2) ({float __result; float __s2=(s2),__s1=(s1); __asm__("fcpysn %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })  //##sw3mc##
+//#define ADDTC(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("addtc %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+
+
+#define SUBTC(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("subtc %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define MULTC(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("multc %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define DIVTC(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("divtc %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define ADDSC(s1,s2) ({float __result; float __s2=(s2),__s1=(s1); __asm__("addsc %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define ADDTD(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("addtd %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define SUBTD(s1,s2) ({double __result; double __s2=(s2),__s1=(s1); __asm__("subtd %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define ADDSD(s1,s2) ({float __result; float __s2=(s2),__s1=(s1); __asm__("addsd %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define SUBSD(s1,s2) ({float __result; float __s2=(s2),__s1=(s1); __asm__("subsd %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+#define DIVSC(s1,s2) ({float __result; float __s2=(s2),__s1=(s1); __asm__("divsc %2,%1,%0" : "=f"(__result):"f"(__s2),"f"(__s1));  __result; })
+//#define CVTTQC(s1)    ({double __result; double __s1=(s1); __asm__("cvttqc %1,%0" : "=f"(__result):"f"(__s1));  __result; })
+#define FSQRTD(s1)    ({double __result; double __s1=(s1); __asm__("fsqrtd %1,%0" : "=f"(__result):"f"(__s1));  __result; })  //##sw3mc##
+#define FSQRTS(s1)    ({float __result; float __s1=(s1); __asm__("fsqrts %1,%0" : "=f"(__result):"f"(__s1));  __result; })     //##sw3mc##
+#define ITOFD(s1)    ({double __result; long __s1=(s1); __asm__("ifmovd  %1,%0" : "=f"(__result):"r"(__s1));  __result; })   //##sw3mc##
+#define FTOID(s1)    ({long __result; double __s1=(s1); __asm__("fimovd  %1,%0" : "=r"(__result):"f"(__s1));  __result; })   //##sw3mc##
+#define ITOFS(s1)    ({float __result; int __s1=(s1); __asm__("ifmovs  %1,%0" : "=f"(__result):"r"(__s1));  __result; })
+#define FTOIS(s1)    ({int __result; float __s1=(s1); __asm__("fimovs  %1,%0" : "=r"(__result):"f"(__s1));  __result; })
+#define ZAPNOT(s,n)  ({long __result; long __n=(n),__s=(s); __asm__("zapnot %2,%1,%0" : "=r"(__result):"r"(__n),"r"(__s));  __result; })
+#define UMULH(s1,s2) ({long __result; long __s2=(s2),__s1=(s1); __asm__("umulh %2,%1,%0" : "=r"(__result):"r"(__s2),"r"(__s1));  __result; })
+#define CTLZ(ra)     ({long __result; long __ra=(ra); __asm__("ctlz   %1,%0" : "=r"(__result):"r"(__ra));  __result; })
+
+#else
+
+#include  <c_asm.h>
+#define BIC(s1,s2)   (asm("bic %a0,%a1,%v0\n",s1,s2))
+#define CPYSE(s1,s2) (dasm("fcpyse %f16,%f17,%f0",s1,s2))  //##sw3mc##
+#define CPYS(s1,s2)  (dasm("fcpys  %f16,%f17,%f0",s1,s2))   //##sw3mc##
+#define CPYSN(s1,s2) (dasm("fcpysn %f16,%f17,%f0",s1,s2))   //##sw3mc##
+#define FCPYSE(s1,s2) (fasm("fcpyse %f16,%f17,%f0",s1,s2))  //##sw3mc##
+#define FCPYS(s1,s2)  (fasm("fcpys  %f16,%f17,%f0",s1,s2))  //##sw3mc##
+#define FCPYSN(s1,s2) (fasm("fcpysn %f16,%f17,%f0",s1,s2))  //##sw3mc##
+//#define ADDTC(s1,s2) (dasm("addtc %f16,%f17,%f0",s1,s2))
+#define SUBTC(s1,s2) (dasm("subtc %f16,%f17,%f0",s1,s2))
+#define MULTC(s1,s2) (dasm("multc %f16,%f17,%f0",s1,s2))
+#define DIVTC(s1,s2) (dasm("divtc %f16,%f17,%f0",s1,s2))
+#define ADDSC(s1,s2) (fasm("addsc %f16,%f17,%f0",s1,s2))
+#define ADDTD(s1,s2) (dasm("addtd %f16,%f17,%f0",s1,s2))
+#define SUBTD(s1,s2) (dasm("subtd %f16,%f17,%f0",s1,s2))
+#define ADDSD(s1,s2) (fasm("addsd %f16,%f17,%f0",s1,s2))
+#define SUBSD(s1,s2) (fasm("subsd %f16,%f17,%f0",s1,s2))
+#define DIVSC(s1,s2) (fasm("divsc %f16,%f17,%f0",s1,s2))
+//#define CVTTQC(s)    (dasm("cvttqc %f16,%f0",s))
+#define FSQRTD(s)     (dasm("fsqrtd %f16,%f0",s))  //##sw3mc##
+#define FSQRTS(s)     (fasm("fsqrts %f16,%f0",s))  //##sw3mc##
+#define ITOFD(s)     (dasm("ifmovd %a0,%f0",s))   //##sw3mc##
+#define FTOID(s)     (asm("fimovd %f16,%v0",s))   //##sw3mc##
+#define ITOFS(s)     (fasm("ifmovs %a0,%f0",s))
+#define FTOIS(s)     (asm("fimovs %f16,%v0",(s)))
+#define ZAPNOT(s,n)  (asm("zapnot %a0,%a1,%v0",s,n))
+#define UMULH(s1,s2) (asm("umulh %a0,%a1,%v0",s1,s2))
+#define CTLZ(ra)     (asm("ctlz   %a0,%v0", (Ulong)(ra)))
+#endif
+
+extern double   _sw5mc___sin_vo(double ,long );
+extern float    _sw5mc___sin_vof(float ,long );
+extern double   _sw5mc___cos_vo(double ,long );
+extern float    _sw5mc___cos_vof(float ,long );
+extern void 	_sw5mc___sincos_vo(double * ,double ,long );
+extern void 	_sw5mc___sincos_vof(float * ,float ,long );
+extern void 	sw7mc_exception(sw_excep *);
+
+extern double _sw5mc___addtc(double,double);
+extern double _sw5mc___cvttqc(double);
+
+#define ADDTC(s1,s2) _sw5mc___addtc(s1,s2)
+#define CVTTQC(s) _sw5mc___cvttqc(s)
+
+/* *****  *****/
+#define D_CQNAN		0xfff8000000000000UL    //
+#define D_PQNAN		0x7fffffffffffffffUL	//
+#define D_MQNAN		0xffffffffffffffffUL	//
+#define D_PSNAN		0x7ff7ffffffffffffUL	//
+#define D_MSNAN		0xfff7ffffffffffffUL	//
+#define D_PINF		0x7ff0000000000000UL	//
+#define D_MINF		0xfff0000000000000UL	//
+#define D_PLARGEST	0x7fefffffffffffffUL	//
+#define D_MLARGEST	0xffefffffffffffffUL	//
+#define D_PZERO		0x0000000000000000UL	//
+#define D_MZERO		0x8000000000000000UL	//
+
+/* *****  *****/
+#define F_CQNAN		0xffc00000U		//
+#define F_PQNAN		0x7fffffffU             // 
+#define F_MQNAN		0xffffffffU             // 
+#define F_PSNAN		0x7fbfffffU             // 
+#define F_MSNAN		0xffbfffffU             // 
+#define F_PINF		0x7f800000U             //     
+#define F_MINF		0xff800000U             //     
+#define F_PLARGEST	0x7f7fffffU             //   
+#define F_MLARGEST	0xff7fffffU             //   
+#define F_PZERO		0x00000000U             //       
+#define F_MZERO		0x80000000U             //       
+
+/* *** errno val *** */
+/*
+#define EDOM	33	// 
+#define ERANGE	34	//
+
+*/
+
+/* FPStatus flags */
+#define FP_INV		0x020000	/* invalid operation */
+#define FP_DZE		0x040000	/* divide by 0 */
+#define FP_OVF		0x080000	/* overflow */
+#define FP_UNF		0x100000	/* underflow */
+#define FP_INE		0x200000	/* inexact */
+#define FP_DNO		0x400000	/* denormal operand */
+#define FP_MASK		0x7e0000	/* mask of all sticky bits */
+
+#define SET_ERRNO(val)		errno=val
+#define SET_FP(val)     	ieee_set_fp_control(val)
+
+/* *** DISP_INFO mecro for debug info Only  *** */
+#ifdef  DISP_INFO
+#define CLEAR_FP()      ieee_set_fp_control(0L)
+#define DISP_FP()	{printf("FP=0x%lx\n",ieee_get_fp_control());ieee_set_fp_control(0L);}
+#define DISP_ERRNO()	{printf("ERRNO=0x%x\n",errno);errno=0;}
+#else
+#define CLEAR_FP()
+#define DISP_FP()
+#define DISP_ERRNO()
+#endif
+
+/* ***** DOUBLE function flags *******/
+#define PUTH32( val)    ((long)(val)<<32)
+#define SIN_   		PUTH32(0x10)
+#define SIND_		PUTH32(0x20)
+#define COS_		PUTH32(0x30)
+#define COSD_		PUTH32(0x40)
+#define TAN_		PUTH32(0x50)
+#define TAND_		PUTH32(0x60)
+#define COT_		PUTH32(0x70)
+#define COTD_		PUTH32(0x80)
+#define ASIN_		PUTH32(0x90)
+#define ASIND_		PUTH32(0x100)
+#define ACOS_		PUTH32(0x110)
+#define ACOSD_		PUTH32(0x120)
+#define ATAN_		PUTH32(0x130)
+#define ATAND_		PUTH32(0x140)
+#define ATAN2_		PUTH32(0x150)
+#define ATAND2_		PUTH32(0x160)
+#define SINH_		PUTH32(0x170)
+#define COSH_		PUTH32(0x180)
+#define TANH_		PUTH32(0x190)
+#define ASINH_		PUTH32(0x200)
+#define ACOSH_		PUTH32(0x210)
+#define ATANH_		PUTH32(0x220)
+#define POW_		PUTH32(0x230)
+#define EXP_		PUTH32(0x240)
+#define EXPM1_		PUTH32(0x250)
+#define EXP2_		PUTH32(0x260)
+#define LOG10_		PUTH32(0x270)
+#define LOG_		PUTH32(0x280)
+#define LOG1P_		PUTH32(0x290)
+#define LOG2_		PUTH32(0x300)
+#define ILOGB_		PUTH32(0x310)
+#define SQRT_		PUTH32(0x320)
+#define CBRT_		PUTH32(0x330)
+#define FLOOR_		PUTH32(0x340)
+#define CEIL_		PUTH32(0x350)
+#define MODF_		PUTH32(0x360)
+#define NINT_		PUTH32(0x370)
+#define NEARBYINT_	PUTH32(0x380)
+#define RINT_		PUTH32(0x390)
+#define ROUND_		PUTH32(0x400)
+#define LRINT_		PUTH32(0x410)
+#define LROUND_		PUTH32(0x420)
+#define TRUNC_		PUTH32(0x430)
+#define FMOD_		PUTH32(0x440)
+#define DREM_		PUTH32(0x450)
+#define REMAINDER_	PUTH32(0x460)
+#define REMQUO_		PUTH32(0x470)
+#define FREXP_		PUTH32(0x480)
+#define LDEXP_		PUTH32(0x490)
+#define SCALB_		PUTH32(0x500)
+#define SCALBLN_	PUTH32(0x510)
+#define SCALBN_		PUTH32(0x520)
+#define LOGB_		PUTH32(0x530)
+#define LGAMMA_		PUTH32(0x540)
+#define J0_		PUTH32(0x550)
+#define J1_		PUTH32(0x560)
+#define JN_		PUTH32(0x570)
+#define Y0_		PUTH32(0x580)
+#define Y1_		PUTH32(0x590)
+#define YN_		PUTH32(0x600)
+#define ERF_		PUTH32(0x610)
+#define ERFC_		PUTH32(0x620)
+#define ISNAN_		PUTH32(0x630)
+#define FINITE_		PUTH32(0x640)
+#define NEXTAFTER_	PUTH32(0x650)
+#define NEXTTOWARD_	PUTH32(0x660)
+#define UNORDERED_	PUTH32(0x670)
+#define FP_CLASS_	PUTH32(0x680)
+#define COPYSIGN_	PUTH32(0x690)
+#define HYPOT_		PUTH32(0x700)
+#define CABS_		PUTH32(0x710)
+#define FABS_		PUTH32(0x720)
+#define FDIM_		PUTH32(0x730)
+#define FMAX_		PUTH32(0x740)
+#define FMIN_		PUTH32(0x750)
+#define FMA_		PUTH32(0x760)
+#define SINCOS_		PUTH32(0x770)
+#define SIN_VO_		PUTH32(0x780)
+#define COS_VO_		PUTH32(0x790)
+#define SINCOS_VO_	PUTH32(0x800)
+
+/* ***** FLOAT function flags *******/
+#define SINF_   	PUTH32(0x11)
+#define SINDF_		PUTH32(0x21)
+#define COSF_		PUTH32(0x31)
+#define COSDF_		PUTH32(0x41)
+#define TANF_		PUTH32(0x51)
+#define TANDF_		PUTH32(0x61)
+#define COTF_		PUTH32(0x71)
+#define COTDF_		PUTH32(0x81)
+#define ASINF_		PUTH32(0x91)
+#define ASINDF_		PUTH32(0x101)
+#define ACOSF_		PUTH32(0x111)
+#define ACOSDF_		PUTH32(0x121)
+#define ATANF_		PUTH32(0x131)
+#define ATANDF_		PUTH32(0x141)
+#define ATAN2F_		PUTH32(0x151)
+#define ATAND2F_	PUTH32(0x161)
+#define SINHF_		PUTH32(0x171)
+#define COSHF_		PUTH32(0x181)
+#define TANHF_		PUTH32(0x191)
+#define ASINHF_		PUTH32(0x201)
+#define ACOSHF_		PUTH32(0x211)
+#define ATANHF_		PUTH32(0x221)
+#define POWF_		PUTH32(0x231)
+#define EXPF_		PUTH32(0x241)
+#define EXPM1F_		PUTH32(0x251)
+#define EXP2F_		PUTH32(0x261)
+#define LOG10F_		PUTH32(0x271)
+#define LOGF_		PUTH32(0x281)
+#define LOG1PF_		PUTH32(0x291)
+#define LOG2F_		PUTH32(0x301)
+#define ILOGBF_		PUTH32(0x311)
+#define SQRTF_		PUTH32(0x321)
+#define CBRTF_		PUTH32(0x331)
+#define FLOORF_		PUTH32(0x341)
+#define CEILF_		PUTH32(0x351)
+#define MODFF_		PUTH32(0x361)
+#define NINTF_		PUTH32(0x371)
+#define NEARBYINTF_	PUTH32(0x381)
+#define RINTF_		PUTH32(0x391)
+#define ROUNDF_		PUTH32(0x401)
+#define LRINTF_		PUTH32(0x411)
+#define LROUNDF_	PUTH32(0x421)
+#define TRUNCF_		PUTH32(0x431)
+#define FMODF_		PUTH32(0x441)
+#define DREMF_		PUTH32(0x451)
+#define REMAINDERF_	PUTH32(0x461)
+#define REMQUOF_	PUTH32(0x471)
+#define FREXPF_		PUTH32(0x481)
+#define LDEXPF_		PUTH32(0x491)
+#define SCALBF_		PUTH32(0x501)
+#define SCALBLNF_	PUTH32(0x511)
+#define SCALBNF_	PUTH32(0x521)
+#define LOGBF_		PUTH32(0x531)
+#define LGAMMAF_	PUTH32(0x541)
+#define J0F_		PUTH32(0x551)
+#define J1F_		PUTH32(0x561)
+#define JNF_		PUTH32(0x571)
+#define Y0F_		PUTH32(0x581)
+#define Y1F_		PUTH32(0x591)
+#define YNF_		PUTH32(0x601)
+#define ERFF_		PUTH32(0x611)
+#define ERFCF_		PUTH32(0x621)
+#define ISNANF_		PUTH32(0x631)
+#define FINITEF_	PUTH32(0x641)
+#define NEXTAFTERF_	PUTH32(0x651)
+#define NEXTTOWARDF_	PUTH32(0x661)
+#define UNORDEREDF_	PUTH32(0x671)
+#define FP_CLASSF_	PUTH32(0x681)
+#define COPYSIGNF_	PUTH32(0x691)
+#define HYPOTF_		PUTH32(0x701)
+#define CABSF_		PUTH32(0x711)
+#define FABSF_		PUTH32(0x721)
+#define FDIMF_		PUTH32(0x731)
+#define FMAXF_		PUTH32(0x741)
+#define FMINF_		PUTH32(0x751)
+#define FMAF_		PUTH32(0x761)
+#define SINCOSF_	PUTH32(0x771)
+#define SIN__VOF_	PUTH32(0x781)
+#define COS__VOF_	PUTH32(0x791)
+#define SINCOS__VOF_	PUTH32(0x801)
+
+
+#endif  // __sw5mc_math_define__
diff --git a/sysdeps/sw_64/include/_sw7mc_regdef.h b/sysdeps/sw_64/include/_sw7mc_regdef.h
new file mode 100644
index 00000000..621f1401
--- /dev/null
+++ b/sysdeps/sw_64/include/_sw7mc_regdef.h
@@ -0,0 +1,45 @@
+#ifndef __sw5mc_regdef_h__
+#define __sw5mc_regdef_h__
+
+#define v0	$0	/* function return value */
+
+#define t0	$1	/* temporary registers (caller-saved) */
+#define t1	$2
+#define t2	$3
+#define t3	$4
+#define t4	$5
+#define t5	$6
+#define t6	$7
+#define t7	$8
+
+#define	s0	$9	/* saved-registers (callee-saved registers) */
+#define	s1	$10
+#define	s2	$11
+#define	s3	$12
+#define	s4	$13
+#define	s5	$14
+#define	s6	$15
+#define	fp	s6	/* frame-pointer (s6 in frame-less procedures) */
+
+#define a0	$16	/* argument registers (caller-saved) */
+#define a1	$17
+#define a2	$18
+#define a3	$19
+#define a4	$20
+#define a5	$21
+
+#define t8	$22	/* more temps (caller-saved) */
+#define t9	$23
+#define t10	$24
+#define t11	$25
+#define ra	$26	/* return address register */
+#define t12	$27
+
+#define pv	t12	/* procedure-variable register */
+#define at	$at	/* assembler temporary */
+#define AT	$at
+#define gp	$29	/* global pointer */
+#define sp	$30	/* stack pointer */
+#define zero	$31	/* reads as zero, writes are noops */
+
+#endif /* __sw2_regdef_h__ */
diff --git a/sysdeps/sw_64/include/test_numdouble.h b/sysdeps/sw_64/include/test_numdouble.h
new file mode 100644
index 00000000..41f1aff1
--- /dev/null
+++ b/sysdeps/sw_64/include/test_numdouble.h
@@ -0,0 +1,101 @@
+
+#ifndef  _TEST_NUMDOUBLE_H
+
+
+typedef double DATATYPE;
+
+typedef unsigned long _TYPE;   //8 byte
+//typedef unsigned int _TYPE;  //4 byte
+
+#define _EXP_BITS 11
+#define _Fraction_BITS 52
+
+// ,QNaNSNaN
+#define FRACTION_HIGH_BIT		(((_TYPE)1)<<(sizeof(_TYPE)*8-_EXP_BITS-2))
+// 
+#define DIGITS_BITS				(sizeof(_TYPE)*8-_EXP_BITS)
+// 
+#define FLOAT_EXP_OFF			( (((int)1)<<(_EXP_BITS-1)) - 1 )
+
+// IEEE
+typedef struct
+{
+	_TYPE m_nFraction : sizeof(_TYPE)*8-_EXP_BITS-1;
+	_TYPE m_nExp	  : _EXP_BITS;
+	_TYPE m_nSign     : 1;
+} _DATA;
+
+//+0.0-0.0
+DATATYPE Zero( int sign )
+{
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = sign;
+	p->m_nExp      = 0;
+	p->m_nFraction = 0;
+
+	return rv;
+}
+
+//+subnormal-subnormal
+DATATYPE SubNormal( int sign )
+{
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = sign;
+	p->m_nExp      = 0;
+	p->m_nFraction = 1;
+
+	return rv;
+}
+
+//quiet NaN
+DATATYPE QNaN()
+{	
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = 0;
+	p->m_nExp      = -1;
+	p->m_nFraction = FRACTION_HIGH_BIT;
+
+	return rv;
+}
+
+//Signal NaN
+DATATYPE CQNaN()
+{	
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = 1;
+	p->m_nExp      = -1;
+	p->m_nFraction = 1;
+
+	return rv;
+}
+
+//
+DATATYPE Infinite( int sign )
+{
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = sign;
+	p->m_nExp      = -1;
+	p->m_nFraction = 0;
+
+	return rv;
+}
+
+//
+/*DATATYPE anyf(int nSign,int nExp,long nFraction)
+{
+	DATATYPE rv=0.0;
+	_DATA *p=(_DATA *)&rv;
+	p->m_nSign	     = nSign;
+	p->m_nExp      = nExp;
+	p->m_nFraction = nFraction;
+
+	return rv;
+	
+}*/
+
+#endif
diff --git a/sysdeps/sw_64/include/test_numfloat.h b/sysdeps/sw_64/include/test_numfloat.h
new file mode 100644
index 00000000..8373fd18
--- /dev/null
+++ b/sysdeps/sw_64/include/test_numfloat.h
@@ -0,0 +1,99 @@
+typedef float DATATYPE;
+
+//typedef unsigned long _TYPE;   //8 byte
+typedef unsigned int _TYPE;  //4 byte
+
+#define _EXP_BITS 8
+#define _Fraction_BITS 23
+
+// ,QNaNSNaN
+#define FRACTION_HIGH_BIT		(((_TYPE)1)<<(sizeof(_TYPE)*8-_EXP_BITS-2))
+// 
+#define DIGITS_BITS				(sizeof(_TYPE)*8-_EXP_BITS)
+// 
+#define FLOAT_EXP_OFF			( (((int)1)<<(_EXP_BITS-1)) - 1 )
+
+// IEEE
+typedef struct
+{
+	_TYPE m_nFraction : sizeof(_TYPE)*8-_EXP_BITS-1;
+	_TYPE m_nExp	  : _EXP_BITS;
+	_TYPE m_nSign     : 1;
+} _DATA;
+
+
+//+0.0-0.0
+DATATYPE Zero( int sign )
+{
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = sign;
+	p->m_nExp      = 0;
+	p->m_nFraction = 0;
+
+	return rv;
+}
+
+
+//+subnormal-subnormal
+DATATYPE SubNormal( int sign )
+{
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = sign;
+	p->m_nExp      = 0;
+	p->m_nFraction = 1;
+
+	return rv;
+}
+
+//quiet NaN
+DATATYPE QNaN()
+{	
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = 0;
+	p->m_nExp      = -1;
+	p->m_nFraction = FRACTION_HIGH_BIT;
+
+	return rv;
+}
+
+//Signal NaN
+DATATYPE CQNaN()
+{	
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = 1;
+	p->m_nExp      = -1;
+	p->m_nFraction = 1;
+
+	return rv;
+}
+
+//
+DATATYPE Infinite( int sign )
+{
+	DATATYPE rv=0.0;
+	_DATA *p = (_DATA *)&rv;
+	p->m_nSign	     = sign;
+	p->m_nExp      = -1;
+	p->m_nFraction = 0;
+
+	return rv;
+}
+
+//
+DATATYPE anyf(int nSign,int nExp,long nFraction)
+{
+	DATATYPE rv=0.0;
+	_DATA *p=(_DATA *)&rv;
+	p->m_nSign	     = nSign;
+	p->m_nExp      = nExp;
+	p->m_nFraction = nFraction;
+
+	return rv;
+	
+}
+
+
diff --git a/sysdeps/sw_64/jmpbuf-offsets.h b/sysdeps/sw_64/jmpbuf-offsets.h
new file mode 100644
index 00000000..d2985a10
--- /dev/null
+++ b/sysdeps/sw_64/jmpbuf-offsets.h
@@ -0,0 +1,35 @@
+/* Private macros for accessing __jmp_buf contents.  Sw_64 version.
+   Copyright (C) 2006-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define JB_S0  0
+#define JB_S1  1
+#define JB_S2  2
+#define JB_S3  3
+#define JB_S4  4
+#define JB_S5  5
+#define JB_PC  6
+#define JB_FP  7
+#define JB_SP  8
+#define JB_F2  9
+#define JB_F3  10
+#define JB_F4  11
+#define JB_F5  12
+#define JB_F6  13
+#define JB_F7  14
+#define JB_F8  15
+#define JB_F9  16
diff --git a/sysdeps/sw_64/jmpbuf-unwind.h b/sysdeps/sw_64/jmpbuf-unwind.h
new file mode 100644
index 00000000..ff95cef9
--- /dev/null
+++ b/sysdeps/sw_64/jmpbuf-unwind.h
@@ -0,0 +1,46 @@
+/* Copyright (C) 2003-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <setjmp.h>
+#include <jmpbuf-offsets.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+#include <pointer_guard.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame containing a local
+   variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(_jmpbuf, _address, _demangle) \
+  ((void *)(_address) < (void *) _demangle ((_jmpbuf)[JB_SP]))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[JB_SP];
+  PTR_DEMANGLE (sp);
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff --git a/sysdeps/sw_64/ldiv.S b/sysdeps/sw_64/ldiv.S
new file mode 100644
index 00000000..5cd9399a
--- /dev/null
+++ b/sysdeps/sw_64/ldiv.S
@@ -0,0 +1,222 @@
+
+/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include "div_libc.h"
+
+#undef FRAME
+#ifdef __sw_64_fix__
+#define FRAME 0
+#else
+#define FRAME 16
+#endif
+
+#undef X
+#undef Y
+#define X $17
+#define Y $18
+
+	.set noat
+
+	.align 4
+	.globl ldiv
+	.ent ldiv
+ldiv:
+	.frame sp, FRAME, ra
+#if FRAME > 0
+	ldi	sp, -FRAME(sp)
+#endif
+#ifdef PROF
+	.set	macro
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set	nomacro
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	beq	Y, $divbyzero
+	mov     Y,t6
+	nop
+	rfpcr	$f10
+
+	_ITOFT2	X, $f0, 0, Y, $f1, 8
+
+	.align	4
+	fcvtld	$f0, $f11
+	fcvtld	$f1, $f12
+	fdivd	$f11, $f12, $f0
+	unop
+
+	/* Check to see if X fit in the double as an exact value.  */
+	sll	X, (64-53), AT
+	sra	AT, (64-53), AT
+	cmpeq	X, AT, AT
+	beq	AT, $x_big
+
+	/* If we get here, we're expecting exact results from the division.
+	   Do nothing else besides convert and clean up.  */
+	fcvtdl_z $f0, $f11
+	nop
+	wfpcr	$f10
+	_FTOIT	$f11, $0, 0
+
+$egress:
+//	mull	$0, Y, $1
+	mull	$0, t6, $1
+	subl	X, $1, $1
+
+	stl	$0, 0($16)
+	stl	$1, 8($16)
+	mov	$16, $0
+
+#if FRAME > 0
+	ldi	sp, FRAME(sp)
+#endif
+	ret
+
+	.align	4
+$x_big:
+	/* If we get here, X is large enough that we don't expect exact
+	   results, and neither X nor Y got mis-translated for the fp
+	   division.  Our task is to take the fp result, figure out how
+	   far it's off from the correct result and compute a fixup.  */
+
+#define Q	v0		/* quotient */
+#define R	t0		/* remainder */
+#define SY	t1		/* scaled Y */
+#define S	t2		/* scalar */
+#define QY	t3		/* Q*Y */
+
+	/* The fixup code below can only handle unsigned values.  */
+	bis	X, Y, AT
+	mov	$31, t5
+	blt	AT, $fix_sign_in
+$fix_sign_in_ret1:
+	fcvtdl_z $f0, $f11
+
+	_FTOIT	$f11, Q, 8
+$fix_sign_in_ret2:
+	mull	Q, Y, QY
+	nop
+	wfpcr	$f10
+
+	.align	4
+	subl	QY, X, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_high
+
+$q_high_ret:
+	subl	X, QY, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_low
+
+$q_low_ret:
+	negl	Q, t4
+	sellbs	t5, t4, Q, Q
+	br	$egress
+
+	.align	4
+	/* The quotient that we computed was too large.  We need to reduce
+	   it by S such that Y*S >= R.  Obviously the closer we get to the
+	   correct value the better, but overshooting high is ok, as we'll
+	   fix that up later.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_high:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	subl	Q, S, Q
+	unop
+	subl	QY, SY, QY
+	br	$q_high_ret
+
+	.align	4
+	/* The quotient that we computed was too small.  Divide Y by the
+	   current remainder (R) and add that to the existing quotient (Q).
+	   The expectation, of course, is that R is much smaller than X.  */
+	/* Begin with a shift-up loop.  Compute S such that Y*S >= R.  We
+	   already have a copy of Y in SY and the value 1 in S.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_low:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	/* Shift-down and subtract loop.  Each iteration compares our scaled
+	   Y (SY) with the remainder (R); if SY <= R then X is divisible by
+	   Y's scalar (S) so add it to the quotient (Q).  */
+2:	addl	Q, S, t3
+	srl	S, 1, S
+	cmpule	SY, R, AT
+	subl	R, SY, t4
+
+	selne	AT, t3, Q, Q
+	selne	AT, t4, R, R
+	srl	SY, 1, SY
+	bne	S, 2b
+
+	br	$q_low_ret
+
+	.align	4
+$fix_sign_in:
+	/* If we got here, then X|Y is negative.  Need to adjust everything
+	   such that we're doing unsigned division in the fixup loop.  */
+	/* T5 is true if result should be negative.  */
+	xor	X, Y, AT
+	cmplt	AT, 0, t5
+	cmplt	X, 0, AT
+	negl	X, t0
+
+	selne	AT, t0, X, X
+	cmplt	Y, 0, AT
+	negl	Y, t0
+
+	selne	AT, t0, Y, Y
+	blbc	t5, $fix_sign_in_ret1
+
+	fcvtdl_z $f0, $f11
+	_FTOIT	$f11, Q, 8
+	.align	3
+	negl	Q, Q
+	br	$fix_sign_in_ret2
+
+$divbyzero:
+	mov	a0, v0
+	ldi	a0, GEN_INTDIV
+	sys_call HMC_gentrap
+	stl	zero, 0(v0)
+	stl	zero, 8(v0)
+
+#if FRAME > 0
+	ldi	sp, FRAME(sp)
+#endif
+	ret
+
+	.end	ldiv
+
+weak_alias (ldiv, lldiv)
+weak_alias (ldiv, imaxdiv)
diff --git a/sysdeps/sw_64/ldsodefs.h b/sysdeps/sw_64/ldsodefs.h
new file mode 100644
index 00000000..159fa79c
--- /dev/null
+++ b/sysdeps/sw_64/ldsodefs.h
@@ -0,0 +1,42 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2012-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __LDSODEFS_H
+
+#include <elf.h>
+
+struct La_sw_64_regs;
+struct La_sw_64_retval;
+
+#define ARCH_PLTENTER_MEMBERS						\
+    Elf64_Addr (*sw_64_gnu_pltenter) (Elf64_Sym *, unsigned int,	\
+				     uintptr_t *, uintptr_t *,		\
+				     struct La_sw_64_regs *,		\
+				     unsigned int *, const char *name,  \
+				     long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS						\
+    unsigned int (*sw_64_gnu_pltexit) (Elf64_Sym *, unsigned int,	\
+				      uintptr_t *, uintptr_t *,		\
+				      const struct La_sw_64_regs *,	\
+				      struct La_sw_64_retval *,		\
+				      const char *);
+
+#include_next <ldsodefs.h>
+
+#endif
diff --git a/sysdeps/sw_64/libc-tls.c b/sysdeps/sw_64/libc-tls.c
new file mode 100644
index 00000000..4758b131
--- /dev/null
+++ b/sysdeps/sw_64/libc-tls.c
@@ -0,0 +1,32 @@
+/* Thread-local storage handling in the ELF dynamic linker.  Sw_64 version.
+   Copyright (C) 2003-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+/* On Sw_64, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + ti->ti_offset;
+}
diff --git a/sysdeps/sw_64/lldiv.S b/sysdeps/sw_64/lldiv.S
new file mode 100644
index 00000000..8a8ef97a
--- /dev/null
+++ b/sysdeps/sw_64/lldiv.S
@@ -0,0 +1 @@
+/* lldiv is the same as ldiv on the Sw_64.  */
diff --git a/sysdeps/sw_64/local-soft-fp.h b/sysdeps/sw_64/local-soft-fp.h
new file mode 100644
index 00000000..d562e082
--- /dev/null
+++ b/sysdeps/sw_64/local-soft-fp.h
@@ -0,0 +1,55 @@
+#include <stdlib.h>
+#include <soft-fp.h>
+#include <quad.h>
+
+/* Helpers for the Ots functions which receive long double arguments
+   in two integer registers, and return values in $16+$17.  */
+
+#define AXP_UNPACK_RAW_Q(X, val)			\
+  do {							\
+    union _FP_UNION_Q _flo;				\
+    _flo.longs.a = val##l;				\
+    _flo.longs.b = val##h;				\
+    FP_UNPACK_RAW_QP(X, &_flo);				\
+  } while (0)
+
+#define AXP_UNPACK_SEMIRAW_Q(X, val)			\
+  do {							\
+    union _FP_UNION_Q _flo;				\
+    _flo.longs.a = val##l;				\
+    _flo.longs.b = val##h;				\
+    FP_UNPACK_SEMIRAW_QP(X, &_flo);			\
+  } while (0)
+
+#define AXP_UNPACK_Q(X, val)				\
+  do {							\
+    AXP_UNPACK_RAW_Q(X, val);				\
+    _FP_UNPACK_CANONICAL(Q, 2, X);			\
+  } while (0)
+
+#define AXP_PACK_RAW_Q(val, X) FP_PACK_RAW_QP(&val##_flo, X)
+
+#define AXP_PACK_SEMIRAW_Q(val, X)			\
+  do {							\
+    _FP_PACK_SEMIRAW(Q, 2, X);				\
+    AXP_PACK_RAW_Q(val, X);				\
+  } while (0)
+
+#define AXP_PACK_Q(val, X)				\
+  do {							\
+    _FP_PACK_CANONICAL(Q, 2, X);			\
+    AXP_PACK_RAW_Q(val, X);				\
+  } while (0)
+
+#define AXP_DECL_RETURN_Q(X) union _FP_UNION_Q X##_flo
+
+/* ??? We don't have a real way to tell the compiler that we're wanting
+   to return values in $16+$17.  Instead use a volatile asm to make sure
+   that the values are live, and just hope that nothing kills the values
+   in between here and the end of the function.  */
+#define AXP_RETURN_Q(X)					\
+  do {							\
+    register long r16 __asm__("16") = X##_flo.longs.a;	\
+    register long r17 __asm__("17") = X##_flo.longs.b;	\
+    asm volatile ("" : : "r"(r16), "r"(r17));		\
+  } while (0)
diff --git a/sysdeps/sw_64/lshift.S b/sysdeps/sw_64/lshift.S
new file mode 100644
index 00000000..8024d633
--- /dev/null
+++ b/sysdeps/sw_64/lshift.S
@@ -0,0 +1,107 @@
+ # Sw_64 1621 __mpn_lshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 4.8 cycles/limb on the 1621.  With infinite unrolling,
+ # it would take 4 cycles/limb.  It should be possible to get down to 3
+ # cycles/limb since both ldl and stl can be paired with the other used
+ # instructions.  But there are many restrictions in the 1621 pipeline that
+ # makes it hard, if not impossible, to get down to 3 cycles/limb:
+
+ # 1. ldl has a 3 cycle delay, srl and sll have a 2 cycle delay.
+ # 2. Only aligned instruction pairs can be paired.
+ # 3. The store buffer or silo might not be able to deal with the bandwidth.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_lshift
+	.ent	__mpn_lshift
+__mpn_lshift:
+	.frame	$30,0,$26,0
+
+	s8addl	$18,$17,$17	# make r17 point at end of s1
+	ldl	$4,-8($17)	# load first limb
+	subl	$17,8,$17
+	subl	$31,$19,$7
+	s8addl	$18,$16,$16	# make r16 point at end of RES
+	subl	$18,1,$18
+	and	$18,4-1,$20	# number of limbs in first loop
+	srl	$4,$7,$0	# compute function result
+
+	beq	$20,.L0
+	subl	$18,$20,$18
+
+	.align	3
+.Loop0:
+	ldl	$3,-8($17)
+	subl	$16,8,$16
+	subl	$17,8,$17
+	subl	$20,1,$20
+	sll	$4,$19,$5
+	srl	$3,$7,$6
+	bis	$3,$3,$4
+	bis	$5,$6,$8
+	stl	$8,0($16)
+	bne	$20,.Loop0
+
+.L0:	beq	$18,.Lend
+
+	.align	3
+.Loop:	ldl	$3,-8($17)
+	subl	$16,32,$16
+	subl	$18,4,$18
+	sll	$4,$19,$5
+	srl	$3,$7,$6
+
+	ldl	$4,-16($17)
+	sll	$3,$19,$1
+	bis	$5,$6,$8
+	stl	$8,24($16)
+	srl	$4,$7,$2
+
+	ldl	$3,-24($17)
+	sll	$4,$19,$5
+	bis	$1,$2,$8
+	stl	$8,16($16)
+	srl	$3,$7,$6
+
+	ldl	$4,-32($17)
+	sll	$3,$19,$1
+	bis	$5,$6,$8
+	stl	$8,8($16)
+	srl	$4,$7,$2
+
+	subl	$17,32,$17
+	bis	$1,$2,$8
+	stl	$8,0($16)
+
+	bgt	$18,.Loop
+
+.Lend:	sll	$4,$19,$8
+	stl	$8,-8($16)
+	ret	$31,($26),1
+	.end	__mpn_lshift
diff --git a/sysdeps/sw_64/machine-gmon.h b/sysdeps/sw_64/machine-gmon.h
new file mode 100644
index 00000000..3a061123
--- /dev/null
+++ b/sysdeps/sw_64/machine-gmon.h
@@ -0,0 +1,25 @@
+/* Machine-specific calling sequence for `mcount' profiling function.  sw_64
+   Copyright (C) 1995-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define _MCOUNT_DECL(from, self) \
+ void __mcount (u_long from, u_long self)
+
+/* Call __mcount with our the return PC for our caller, and the return
+   PC our caller will return to.  Empty since we use an assembly stub
+   instead. */
+#define MCOUNT
diff --git a/sysdeps/sw_64/memchr.c b/sysdeps/sw_64/memchr.c
new file mode 100644
index 00000000..07b6f5fa
--- /dev/null
+++ b/sysdeps/sw_64/memchr.c
@@ -0,0 +1,177 @@
+/* Copyright (C) 2010-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <string.h>
+
+typedef unsigned long word;
+
+static inline word
+ldq_u(const void *s)
+{
+  return *(const word *)((word)s & -8);
+}
+
+#define unlikely(X)	__builtin_expect ((X), 0)
+#define prefetch(X)	__builtin_prefetch ((void *)(X), 0)
+
+#define cmpbeq0(X)	__builtin_sw_64_cmpbge(0, (X))
+#define find(X, Y)	cmpbeq0 ((X) ^ (Y))
+
+/* Search no more than N bytes of S for C.  */
+
+void *
+__memchr (const void *s, int xc, size_t n)
+{
+  const word *s_align;
+  word t, current, found, mask, offset;
+
+  if (unlikely (n == 0))
+    return 0;
+
+  current = ldq_u (s);
+
+  /* Replicate low byte of XC into all bytes of C.  */
+  t = xc & 0xff;			/* 0000000c */
+  t = (t << 8) | t;			/* 000000cc */
+  t = (t << 16) | t;			/* 0000cccc */
+  const word c = (t << 32) | t;		/* cccccccc */
+
+  /* Align the source, and decrement the count by the number
+     of bytes searched in the first word.  */
+  s_align = (const word *)((word)s & -8);
+  {
+    size_t inc = n + ((word)s & 7);
+    n = inc | -(inc < n);
+  }
+
+  /* Deal with misalignment in the first word for the comparison.  */
+  mask = (1ul << ((word)s & 7)) - 1;
+
+  /* If the entire string fits within one word, we may need masking
+     at both the front and the back of the string.  */
+  if (unlikely (n <= 8))
+    {
+      mask |= -1ul << n;
+      goto last_quad;
+    }
+
+  found = find (current, c) & ~mask;
+  if (unlikely (found))
+    goto found_it;
+
+  s_align++;
+  n -= 8;
+
+  /* If the block is sufficiently large, align to cacheline and prefetch.  */
+  if (unlikely (n >= 256))
+    {
+      /* Prefetch 3 cache lines beyond the one we're working on.  */
+      prefetch (s_align + 8);
+      prefetch (s_align + 16);
+      prefetch (s_align + 24);
+
+      while ((word)s_align & 63)
+	{
+	  current = *s_align;
+	  found = find (current, c);
+	  if (found)
+	    goto found_it;
+	  s_align++;
+	  n -= 8;
+	}
+
+	/* Within each cacheline, advance the load for the next word
+	   before the test for the previous word is complete.  This
+	   allows us to hide the 3 cycle L1 cache load latency.  We
+	   only perform this advance load within a cacheline to prevent
+	   reading across page boundary.  */
+#define CACHELINE_LOOP				\
+	do {					\
+	  word i, next = s_align[0];		\
+	  for (i = 0; i < 7; ++i)		\
+	    {					\
+	      current = next;			\
+	      next = s_align[1];		\
+	      found = find (current, c);	\
+	      if (unlikely (found))		\
+		goto found_it;			\
+	      s_align++;			\
+	    }					\
+	  current = next;			\
+	  found = find (current, c);		\
+	  if (unlikely (found))			\
+	    goto found_it;			\
+	  s_align++;				\
+	  n -= 64;				\
+	} while (0)
+
+      /* While there's still lots more data to potentially be read,
+	 continue issuing prefetches for the 4th cacheline out.  */
+      while (n >= 256)
+	{
+	  prefetch (s_align + 24);
+	  CACHELINE_LOOP;
+	}
+
+      /* Up to 3 cache lines remaining.  Continue issuing advanced
+	 loads, but stop prefetching.  */
+      while (n >= 64)
+	CACHELINE_LOOP;
+
+      /* We may have exhausted the buffer.  */
+      if (n == 0)
+	return NULL;
+    }
+
+  /* Quadword aligned loop.  */
+  current = *s_align;
+  while (n > 8)
+    {
+      found = find (current, c);
+      if (unlikely (found))
+	goto found_it;
+      current = *++s_align;
+      n -= 8;
+    }
+
+  /* The last word may need masking at the tail of the compare.  */
+  mask = -1ul << n;
+ last_quad:
+  found = find (current, c) & ~mask;
+  if (found == 0)
+    return NULL;
+
+ found_it:
+#ifdef __sw_64_cix__
+  offset = __builtin_sw_64_cttz (found);
+#else
+  /* Extract LSB.  */
+  found &= -found;
+
+  /* Binary search for the LSB.  */
+  offset  = (found & 0x0f ? 0 : 4);
+  offset += (found & 0x33 ? 0 : 2);
+  offset += (found & 0x55 ? 0 : 1);
+#endif
+
+  return (void *)((word)s_align + offset);
+}
+
+#ifdef weak_alias
+weak_alias (__memchr, memchr)
+#endif
+libc_hidden_builtin_def (memchr)
diff --git a/sysdeps/sw_64/memset.S b/sysdeps/sw_64/memset.S
new file mode 100644
index 00000000..dbe9f085
--- /dev/null
+++ b/sysdeps/sw_64/memset.S
@@ -0,0 +1,223 @@
+/* Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include <sysdep.h>
+
+	.arch sw6b 
+	.set noat
+	.set noreorder
+
+ENTRY(memset)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	/*
+	 * Serious stalling happens.  The only way to mitigate this is to
+	 * undertake a major re-write to interleave the constant materialization
+	 * with other parts of the fall-through code.  This is important, even
+	 * though it makes maintenance tougher.
+	 * Do this later.
+	 */
+	and	$17, 255, $1	# E : 00000000000000ch
+	ins0b	$17, 1, $2	# U : 000000000000ch00
+	mov	$16, $0		# E : return value
+	ble	$18, $end	# U : zero length requested?
+
+	addl	$18, $16, $6	# E : max address to write to
+	or	$1, $2, $17	# E : 000000000000chch
+	ins0b	$1, 2, $3	# U : 0000000000ch0000
+	ins0b	$1, 3, $4	# U : 00000000ch000000
+
+	or	$3, $4, $3	# E : 00000000chch0000
+	ins1b	$17, 4, $5	# U : 0000chch00000000
+	xor	$16, $6, $1	# E : will complete write be within one quadword?
+	ins1b	$17, 6, $2	# U : chch000000000000
+
+	or	$17, $3, $17	# E : 00000000chchchch
+	or	$2, $5, $2	# E : chchchch00000000
+	bic	$1, 7, $1	# E : fit within a single quadword?
+	and	$16, 7, $3	# E : Target addr misalignment
+
+	or	$17, $2, $17	# E : chchchchchchchch
+	beq	$1, $within_quad # U :
+	nop			# E :
+	beq	$3, $aligned	# U : target is 0mod8
+
+	/*
+	 * Target address is misaligned, and won't fit within a quadword.
+	 */
+	ldl_u	$4, 0($16)	# L : Fetch first partial
+	mov	$16, $5		# E : Save the address
+	ins3b	$17, $16, $2	# U : Insert new bytes
+	subl	$3, 8, $3	# E : Invert (for addressing uses)
+
+	addl	$18, $3, $18	# E : $18 is new count ($3 is negative)
+	mask3b	$4, $16, $4	# U : clear relevant parts of the quad
+	subl	$16, $3, $16	# E : $16 is new aligned destination
+	or	$2, $4, $1	# E : Final bytes
+
+	nop
+	stl_u	$1,0($5)	# L : Store result
+	nop
+	nop
+
+	.align 4
+$aligned:
+	/*
+	 * We are now guaranteed to be quad aligned, with at least
+	 * one partial quad to write.
+	 */
+
+	sra	$18, 3, $3	# U : Number of remaining quads to write
+	and	$18, 7, $18	# E : Number of trailing bytes to write
+	mov	$16, $5		# E : Save dest address
+	beq	$3, $no_quad	# U : tail stuff only
+
+	/*
+	 * It's worth the effort to unroll this and use wh64 if possible.
+	 * At this point, entry values are:
+	 * $16	Current destination address
+	 * $5	A copy of $16
+	 * $6	The max quadword address to write to
+	 * $18	Number trailer bytes
+	 * $3	Number quads to write
+	 */
+	and	$16, 0x3f, $2	# E : Forward work (only useful for unrolled loop)
+	subl	$3, 16, $4	# E : Only try to unroll if > 128 bytes
+	subl	$2, 0x40, $1	# E : bias counter (aligning stuff 0mod64)
+	blt	$4, $loop	# U :
+
+	/*
+	 * We know we've got at least 16 quads, minimum of one trip
+	 * through unrolled loop.  Do a quad at a time to get us 0mod64
+	 * aligned.
+	 */
+
+	nop			# E :
+	nop			# E :
+	nop			# E :
+	beq	$1, $bigalign	# U :
+$alignmod32:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : For consistency later
+	addl	$1, 8, $1	# E : Increment towards zero for alignment
+	addl	$5, 8, $4	# E : Initial wh64 address (filler instruction)
+
+	nop
+	nop
+	addl	$5, 8, $5	# E : Inc address
+	blt	$1, $alignmod32 # U :
+
+$bigalign:
+	/*
+	 * $3 - number quads left to go
+	 * $5 - target address (aligned 0mod64)
+	 * $17 - mask of stuff to store
+	 * Scratch registers available: $7, $2, $4, $1
+	 * We know that we'll be taking a minimum of one trip through.
+	 * CWG Section 3.7.6: do not expect a sustained store rate of > 1/cycle
+	 * Assumes the wh64 needs to be for 2 trips through the loop in the future.
+	 * The wh64 is issued on for the starting destination address for trip +2
+	 * through the loop, and if there are less than two trips left, the target
+	 * address will be for the current trip.
+	 */
+
+$do_wh64:
+	wh64	($4)		# L1 : memory subsystem write hint
+	subl	$3, 24, $2	# E : For determining future wh64 addresses
+	stl	$17, 0($5)	# L :
+	nop			# E :
+
+	addl	$5, 128, $4	# E : speculative target of next wh64
+	stl	$17, 8($5)	# L :
+	stl	$17, 16($5)	# L :
+	addl	$5, 64, $7	# E : Fallback address for wh64 (== next trip addr)
+
+	stl	$17, 24($5)	# L :
+	stl	$17, 32($5)	# L :
+	sellt	$2, $7, $4, $4	# E : Latency 2, extra mapping cycle
+	nop
+
+	stl	$17, 40($5)	# L :
+	stl	$17, 48($5)	# L :
+	subl	$3, 16, $2	# E : Repeat the loop at least once more?
+	nop
+
+	stl	$17, 56($5)	# L :
+	addl	$5, 64, $5	# E :
+	subl	$3, 8, $3	# E :
+	bge	$2, $do_wh64	# U :
+
+	nop
+	nop
+	nop
+	beq	$3, $no_quad	# U : Might have finished already
+
+	.align 4
+	/*
+	 * Simple loop for trailing quadwords, or for small amounts
+	 * of data (where we can't use an unrolled loop and wh64)
+	 */
+$loop:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : Decrement number quads left
+	addl	$5, 8, $5	# E : Inc address
+	bne	$3, $loop	# U : more?
+
+$no_quad:
+	/*
+	 * Write 0..7 trailing bytes.
+	 */
+	nop			# E :
+	beq	$18, $end	# U : All done?
+	ldl	$7, 0($5)	# L :
+	mask7b	$7, $6, $2	# U : Mask final quad
+
+	ins7b	$17, $6, $4	# U : New bits
+	or	$2, $4, $1	# E : Put it all together
+	stl	$1, 0($5)	# L : And back to memory
+	ret	$31,($26),1	# L0 :
+
+$within_quad:
+	ldl_u	$1, 0($16)	# L :
+	ins3b	$17, $16, $2	# U : New bits
+	mask3b	$1, $16, $4	# U : Clear old
+	or	$2, $4, $2	# E : New result
+
+	mask3b	$2, $6, $4	# U :
+	mask7b	$1, $6, $2	# U :
+	or	$2, $4, $1	# E :
+	stl_u	$1, 0($16)	# L :
+
+$end:
+	nop
+	nop
+	nop
+	ret $31,($26),1		# L0 :
+
+	END(memset)
+libc_hidden_builtin_def (memset)
+
diff --git a/sysdeps/sw_64/memusage.h b/sysdeps/sw_64/memusage.h
new file mode 100644
index 00000000..858826cc
--- /dev/null
+++ b/sysdeps/sw_64/memusage.h
@@ -0,0 +1,20 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("$30"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
diff --git a/sysdeps/sw_64/mul_1.S b/sysdeps/sw_64/mul_1.S
new file mode 100644
index 00000000..7cd52e4e
--- /dev/null
+++ b/sysdeps/sw_64/mul_1.S
@@ -0,0 +1,83 @@
+ # Sw_64 1621 __mpn_mul_1 -- Multiply a limb vector with a limb and store
+ # the result in a second limb vector.
+
+ # Copyright (C) 1992-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # s2_limb	r19
+
+ # This code runs at 42 cycles/limb on the EV4 and 18 cycles/limb on the EV5.
+
+ # To improve performance for long fmuldiplications, we would use
+ # 'fetch' for S1 and 'fetch_m' for RES.  It's not obvious how to use
+ # these instructions without slowing down the general code: 1. We can
+ # only have two prefetches in operation at any time in the Sw_64
+ # architecture.  2. There will seldom be any special alignment
+ # between RES_PTR and S1_PTR.  Maybe we can simply divide the current
+ # loop into an inner and outer loop, having the inner loop handle
+ # exactly one prefetch block?
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_mul_1
+	.ent	__mpn_mul_1 2
+__mpn_mul_1:
+	.frame	$30,0,$26
+
+	ldl	$2,0($17)	# $2 = s1_limb
+	subl	$18,1,$18	# size--
+	mull	$2,$19,$3	# $3 = prod_low
+	bic	$31,$31,$4	# clear cy_limb
+	umulh	$2,$19,$0	# $0 = prod_high
+	beq	$18,Lend1	# jump if size was == 1
+	ldl	$2,8($17)	# $2 = s1_limb
+	subl	$18,1,$18	# size--
+	stl	$3,0($16)
+	beq	$18,Lend2	# jump if size was == 2
+
+	.align	3
+Loop:	mull	$2,$19,$3	# $3 = prod_low
+	addl	$4,$0,$0	# cy_limb = cy_limb + 'cy'
+	subl	$18,1,$18	# size--
+	umulh	$2,$19,$4	# $4 = cy_limb
+	ldl	$2,16($17)	# $2 = s1_limb
+	addl	$17,8,$17	# s1_ptr++
+	addl	$3,$0,$3	# $3 = cy_limb + prod_low
+	stl	$3,8($16)
+	cmpult	$3,$0,$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$16,8,$16	# res_ptr++
+	bne	$18,Loop
+
+Lend2:	mull	$2,$19,$3	# $3 = prod_low
+	addl	$4,$0,$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,$19,$4	# $4 = cy_limb
+	addl	$3,$0,$3	# $3 = cy_limb + prod_low
+	cmpult	$3,$0,$0	# $0 = carry from (cy_limb + prod_low)
+	stl	$3,8($16)
+	addl	$4,$0,$0	# cy_limb = prod_high + cy
+	ret	$31,($26),1
+Lend1:	stl	$3,0($16)
+	ret	$31,($26),1
+
+	.end	__mpn_mul_1
diff --git a/sysdeps/sw_64/nptl/bits/struct_rwlock.h b/sysdeps/sw_64/nptl/bits/struct_rwlock.h
new file mode 100644
index 00000000..50d2e25e
--- /dev/null
+++ b/sysdeps/sw_64/nptl/bits/struct_rwlock.h
@@ -0,0 +1,43 @@
+/* Sw_64 internal rwlock struct definitions.
+   Copyright (C) 2019-2020 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _RWLOCK_INTERNAL_H
+#define _RWLOCK_INTERNAL_H
+
+struct __pthread_rwlock_arch_t
+{
+  unsigned int __readers;
+  unsigned int __writers;
+  unsigned int __wrphase_futex;
+  unsigned int __writers_futex;
+  unsigned int __pad3;
+  unsigned int __pad4;
+  int __cur_writer;
+  int __shared;
+  unsigned long int __pad1;
+  unsigned long int __pad2;
+  /* FLAGS must stay at this position in the structure to maintain
+     binary compatibility.  */
+  unsigned int __flags;
+};
+
+#define __PTHREAD_RWLOCK_INITIALIZER(__flags) \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, __flags
+
+#endif
diff --git a/sysdeps/sw_64/nptl/pthread-offsets.h b/sysdeps/sw_64/nptl/pthread-offsets.h
new file mode 100644
index 00000000..31f0587b
--- /dev/null
+++ b/sysdeps/sw_64/nptl/pthread-offsets.h
@@ -0,0 +1,3 @@
+#define __PTHREAD_MUTEX_KIND_OFFSET		16
+
+#define __PTHREAD_RWLOCK_FLAGS_OFFSET		48
diff --git a/sysdeps/sw_64/nptl/pthread_spin_lock.S b/sysdeps/sw_64/nptl/pthread_spin_lock.S
new file mode 100644
index 00000000..65520f2d
--- /dev/null
+++ b/sysdeps/sw_64/nptl/pthread_spin_lock.S
@@ -0,0 +1,77 @@
+/* Copyright (C) 2003-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson  <rth@twiddle.net>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+	.text
+	.align	4
+
+	.globl	__pthread_spin_lock
+	.ent	__pthread_spin_lock
+__pthread_spin_lock:
+	.frame	$sp, 0, $26, 0
+	.prologue 0
+
+#ifdef HUANGLM20161018
+0:      ldl_l   $1, 0($16)
+        ldi     $2, 1
+        ldi     $0, 0
+        bne     $1, 1f
+
+        stl_c   $2, 0($16)
+        beq     $2, 1f
+        mb
+        ret
+
+1:      ldl     $1, 0($16)
+        bne     $1, 1b
+        unop
+        br      0b
+#else
+#ifndef XWB20170510
+        memb
+#endif
+0:      lldw    $1, 0($16)
+        xor     $1, 1, $1
+        ldi     $0, 0
+        wr_f    $1
+
+        ldi     $2, 1
+        lstw    $2, 0($16)
+        rd_f    $2
+        beq     $2, 1f
+#ifdef XWB20170510
+        memb
+#endif
+        ret
+
+1:      ldw     $1, 0($16)
+        bne     $1, 1b
+        unop
+        br      0b
+
+#endif
+
+
+
+	.end	__pthread_spin_lock
+versioned_symbol (libc, __pthread_spin_lock, pthread_spin_lock, GLIBC_2_34)
+
+#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_2, GLIBC_2_34)
+compat_symbol (libpthread, __pthread_spin_lock, pthread_spin_lock, GLIBC_2_2)
+#endif
diff --git a/sysdeps/sw_64/nptl/pthread_spin_trylock.S b/sysdeps/sw_64/nptl/pthread_spin_trylock.S
new file mode 100644
index 00000000..7990447d
--- /dev/null
+++ b/sysdeps/sw_64/nptl/pthread_spin_trylock.S
@@ -0,0 +1,76 @@
+/* Copyright (C) 2003-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson  <rth@twiddle.net>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#define _ERRNO_H 1
+#include <bits/errno.h>
+
+	.text
+	.align	4
+
+	.globl	__pthread_spin_trylock
+	.ent	__pthread_spin_trylock
+__pthread_spin_trylock:
+	.frame	$sp, 0, $26, 0
+	.prologue 0
+
+#ifdef HUANGLM20161018
+0:      ldl_l   $1, 0($16)
+        lda     $2, 1
+        lda     $0, EBUSY
+        bne     $1, 1f
+
+        stl_c   $2, 0($16)
+        beq     $2, 2f
+        mb
+        lda     $0, 0
+
+1:      ret
+2:      br      0b
+#else
+#ifndef XWB20170510
+        memb
+#endif
+0:      lldw    $1, 0($16)
+        xor     $1, 1, $1
+        ldi     $2, 1
+        ldi     $0, EBUSY
+        wr_f    $1
+
+        lstw    $2, 0($16)
+        rd_f    $2
+        beq     $1, 1f
+        beq     $2, 2f
+#ifdef XWB20170510
+        memb
+#endif
+        ldi     $0, 0
+
+1:      ret
+2:      br      0b
+#endif
+
+	.end	__pthread_spin_trylock
+versioned_symbol (libc, __pthread_spin_trylock, pthread_spin_trylock,
+		  GLIBC_2_34)
+
+#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_2, GLIBC_2_34)
+compat_symbol (libpthread, __pthread_spin_trylock, pthread_spin_trylock,
+	       GLIBC_2_2)
+#endif
diff --git a/sysdeps/sw_64/nptl/pthreaddef.h b/sysdeps/sw_64/nptl/pthreaddef.h
new file mode 100644
index 00000000..8e4e5f76
--- /dev/null
+++ b/sysdeps/sw_64/nptl/pthreaddef.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 2003-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(4 * 1024 * 1024)
+
+/* Minimum guard size.  */
+#define ARCH_MIN_GUARD_SIZE 0
+
+/* Required stack pointer alignment at beginning.  The ABI requires 16.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	4096
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
diff --git a/sysdeps/sw_64/nptl/tls.h b/sysdeps/sw_64/nptl/tls.h
new file mode 100644
index 00000000..48dc1369
--- /dev/null
+++ b/sysdeps/sw_64/nptl/tls.h
@@ -0,0 +1,114 @@
+/* Definition for thread-local data handling.  NPTL/Alpha version.
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+# include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+# include <dl-dtv.h>
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+# define TLS_TCB_AT_TP	0
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *__private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
+
+/* This is the size of the TCB.  */
+# define TLS_TCB_SIZE		sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE	sizeof (struct pthread)
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(tcbp) \
+  (__builtin_set_thread_pointer ((void *)(tcbp)), true)
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+# define TLS_DEFINE_INIT_TP(tp, pd) void *tp = (pd) + 1
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) __builtin_thread_pointer ())->dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *)__builtin_thread_pointer () - 1)
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  REGISTER (64, 64, 32 * 8, -sizeof (struct pthread))
+
+# include <tcb-access.h>
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_release (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff --git a/sysdeps/sw_64/nscd-types.h b/sysdeps/sw_64/nscd-types.h
new file mode 100644
index 00000000..2be87008
--- /dev/null
+++ b/sysdeps/sw_64/nscd-types.h
@@ -0,0 +1,21 @@
+/* Types for the NSCD implementation.  Sw_64 version.
+   Copyright (c) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
+
+typedef int64_t nscd_ssize_t;
diff --git a/sysdeps/sw_64/ots_add.c b/sysdeps/sw_64/ots_add.c
new file mode 100644
index 00000000..5c6fd682
--- /dev/null
+++ b/sysdeps/sw_64/ots_add.c
@@ -0,0 +1,38 @@
+/* Software floating-point emulation: addition.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+void
+_OtsAddX(long al, long ah, long bl, long bh, long _round)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(C);
+  AXP_DECL_RETURN_Q(c);
+
+  FP_INIT_ROUNDMODE;
+  AXP_UNPACK_SEMIRAW_Q(A, a);
+  AXP_UNPACK_SEMIRAW_Q(B, b);
+  FP_ADD_Q(C, A, B);
+  AXP_PACK_SEMIRAW_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+
+  AXP_RETURN_Q(c);
+}
diff --git a/sysdeps/sw_64/ots_cmp.c b/sysdeps/sw_64/ots_cmp.c
new file mode 100644
index 00000000..77e81613
--- /dev/null
+++ b/sysdeps/sw_64/ots_cmp.c
@@ -0,0 +1,63 @@
+/* Software floating-point emulation: comparison.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+static long
+internal_equality (long al, long ah, long bl, long bh, long neq)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(B);
+  long r;
+
+  AXP_UNPACK_RAW_Q(A, a);
+  AXP_UNPACK_RAW_Q(B, b);
+
+  if ((A_e == _FP_EXPMAX_Q && !_FP_FRAC_ZEROP_2(A))
+       || (B_e == _FP_EXPMAX_Q && !_FP_FRAC_ZEROP_2(B)))
+    {
+      /* EQ and NE signal invalid operation only if either operand is SNaN.  */
+      if (FP_ISSIGNAN_Q(A) || FP_ISSIGNAN_Q(B))
+	{
+	  FP_SET_EXCEPTION(FP_EX_INVALID);
+	  FP_HANDLE_EXCEPTIONS;
+	}
+      return -1;
+    }
+
+  r = (A_e == B_e
+       && _FP_FRAC_EQ_2 (A, B)
+       && (A_s == B_s || (!A_e && _FP_FRAC_ZEROP_2(A))));
+  r ^= neq;
+
+  return r;
+}
+
+long
+_OtsEqlX (long al, long ah, long bl, long bh)
+{
+  return internal_equality (al, ah, bl, bh, 0);
+}
+
+long
+_OtsNeqX (long al, long ah, long bl, long bh)
+{
+  return internal_equality (al, ah, bl, bh, 1);
+}
diff --git a/sysdeps/sw_64/ots_cmpe.c b/sysdeps/sw_64/ots_cmpe.c
new file mode 100644
index 00000000..a1ddcc32
--- /dev/null
+++ b/sysdeps/sw_64/ots_cmpe.c
@@ -0,0 +1,77 @@
+/* Software floating-point emulation: comparison.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+static long
+internal_compare (long al, long ah, long bl, long bh)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(B);
+  long r;
+
+  AXP_UNPACK_RAW_Q(A, a);
+  AXP_UNPACK_RAW_Q(B, b);
+  FP_CMP_Q (r, A, B, 2, 2);
+
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+
+long
+_OtsLssX (long al, long ah, long bl, long bh)
+{
+  long r = internal_compare (al, ah, bl, bh);
+  if (r == 2)
+    return -1;
+  else
+    return r < 0;
+}
+
+long
+_OtsLeqX (long al, long ah, long bl, long bh)
+{
+  long r = internal_compare (al, ah, bl, bh);
+  if (r == 2)
+    return -1;
+  else
+    return r <= 0;
+}
+
+long
+_OtsGtrX (long al, long ah, long bl, long bh)
+{
+  long r = internal_compare (al, ah, bl, bh);
+  if (r == 2)
+    return -1;
+  else
+    return r > 0;
+}
+
+long
+_OtsGeqX (long al, long ah, long bl, long bh)
+{
+  long r = internal_compare (al, ah, bl, bh);
+  if (r == 2)
+    return -1;
+  else
+    return r >= 0;
+}
diff --git a/sysdeps/sw_64/ots_cvtqux.c b/sysdeps/sw_64/ots_cvtqux.c
new file mode 100644
index 00000000..d723c465
--- /dev/null
+++ b/sysdeps/sw_64/ots_cvtqux.c
@@ -0,0 +1,39 @@
+/* Software floating-point emulation: unsigned integer to float conversion.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+/* Should never actually be used, since we've more bits of precision
+   than the incomming long, but needed for linkage.  */
+#undef FP_ROUNDMODE
+#define FP_ROUNDMODE  FP_RND_ZERO
+
+void
+_OtsCvtQUX (unsigned long a)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(C);
+  AXP_DECL_RETURN_Q(c);
+
+  FP_FROM_INT_Q(C, a, 64, unsigned long);
+  AXP_PACK_RAW_Q(c, C);
+
+  AXP_RETURN_Q(c);
+}
diff --git a/sysdeps/sw_64/ots_cvtqx.c b/sysdeps/sw_64/ots_cvtqx.c
new file mode 100644
index 00000000..84151775
--- /dev/null
+++ b/sysdeps/sw_64/ots_cvtqx.c
@@ -0,0 +1,38 @@
+/* Software floating-point emulation: signed integer to float conversion.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+/* Should never actually be used, since we've more bits of precision
+   than the incomming long, but needed for linkage.  */
+#undef FP_ROUNDMODE
+#define FP_ROUNDMODE  FP_RND_ZERO
+
+void
+_OtsCvtQX (long a)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(C);
+  AXP_DECL_RETURN_Q(c);
+
+  FP_FROM_INT_Q(C, a, 64, unsigned long);
+  AXP_PACK_RAW_Q(c, C);
+  AXP_RETURN_Q(c);
+}
diff --git a/sysdeps/sw_64/ots_cvttx.c b/sysdeps/sw_64/ots_cvttx.c
new file mode 100644
index 00000000..561cf617
--- /dev/null
+++ b/sysdeps/sw_64/ots_cvttx.c
@@ -0,0 +1,47 @@
+/* Software floating-point emulation: floating point extension.
+   Copyright (C) 1997-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+#include "double.h"
+
+/* Should never actually be used, since we're extending, but needed
+   for linkage.  */
+#undef FP_ROUNDMODE
+#define FP_ROUNDMODE  FP_RND_ZERO
+
+void
+_OtsConvertFloatTX(double a)
+{
+  FP_DECL_EX;
+  FP_DECL_D(A);
+  FP_DECL_Q(C);
+  AXP_DECL_RETURN_Q(c);
+
+  FP_UNPACK_RAW_D(A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_EXTEND(Q,D,4,2,C,A);
+#else
+  FP_EXTEND(Q,D,2,1,C,A);
+#endif
+  AXP_PACK_RAW_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+
+  AXP_RETURN_Q(c);
+}
diff --git a/sysdeps/sw_64/ots_cvtxq.c b/sysdeps/sw_64/ots_cvtxq.c
new file mode 100644
index 00000000..567008cb
--- /dev/null
+++ b/sysdeps/sw_64/ots_cvtxq.c
@@ -0,0 +1,41 @@
+/* Software floating-point emulation: float to integer conversion.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+long
+_OtsCvtXQ (long al, long ah, long _round)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A);
+  unsigned long r;
+  long s;
+
+  /* If bit 3 is set, then integer overflow detection is requested.  */
+  s = _round & 8 ? 1 : -1;
+  _round = _round & 3;
+
+  FP_INIT_ROUNDMODE;
+  AXP_UNPACK_RAW_Q(A, a);
+  FP_TO_INT_Q(r, A, 64, s);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/sysdeps/sw_64/ots_cvtxt.c b/sysdeps/sw_64/ots_cvtxt.c
new file mode 100644
index 00000000..f7b59595
--- /dev/null
+++ b/sysdeps/sw_64/ots_cvtxt.c
@@ -0,0 +1,43 @@
+/* Software floating-point emulation: floating point truncation.
+   Copyright (C) 1997-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+#include "double.h"
+
+double
+_OtsConvertFloatXT (long al, long ah, long _round)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A);
+  FP_DECL_D(R);
+  double r;
+
+  FP_INIT_ROUNDMODE;
+  AXP_UNPACK_SEMIRAW_Q(A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_TRUNC(D,Q,2,4,R,A);
+#else
+  FP_TRUNC(D,Q,1,2,R,A);
+#endif
+  FP_PACK_SEMIRAW_D(r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/sysdeps/sw_64/ots_div.c b/sysdeps/sw_64/ots_div.c
new file mode 100644
index 00000000..345ae3a7
--- /dev/null
+++ b/sysdeps/sw_64/ots_div.c
@@ -0,0 +1,38 @@
+/* Software floating-point emulation: division.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+void
+_OtsDivX(long al, long ah, long bl, long bh, long _round)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(C);
+  AXP_DECL_RETURN_Q(c);
+
+  FP_INIT_ROUNDMODE;
+  AXP_UNPACK_Q(A, a);
+  AXP_UNPACK_Q(B, b);
+  FP_DIV_Q(C, A, B);
+  AXP_PACK_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+
+  AXP_RETURN_Q(c);
+}
diff --git a/sysdeps/sw_64/ots_mul.c b/sysdeps/sw_64/ots_mul.c
new file mode 100644
index 00000000..f88764d3
--- /dev/null
+++ b/sysdeps/sw_64/ots_mul.c
@@ -0,0 +1,38 @@
+/* Software floating-point emulation: multiplication.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+void
+_OtsMulX(long al, long ah, long bl, long bh, long _round)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(C);
+  AXP_DECL_RETURN_Q(c);
+
+  FP_INIT_ROUNDMODE;
+  AXP_UNPACK_Q(A, a);
+  AXP_UNPACK_Q(B, b);
+  FP_MUL_Q(C, A, B);
+  AXP_PACK_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+
+  AXP_RETURN_Q(c);
+}
diff --git a/sysdeps/sw_64/ots_nintxq.c b/sysdeps/sw_64/ots_nintxq.c
new file mode 100644
index 00000000..0e206dda
--- /dev/null
+++ b/sysdeps/sw_64/ots_nintxq.c
@@ -0,0 +1,51 @@
+/* Software floating-point emulation: convert to fortran nearest.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+long
+_OtsNintXQ (long al, long ah, long _round)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(C);
+  unsigned long r;
+  long s;
+
+  /* If bit 3 is set, then integer overflow detection is requested.  */
+  s = _round & 8 ? 1 : -1;
+  _round = _round & 3;
+
+  FP_INIT_ROUNDMODE;
+  AXP_UNPACK_SEMIRAW_Q(A, a);
+
+  /* Build 0.5 * sign(A) */
+  B_e = _FP_EXPBIAS_Q;
+  __FP_FRAC_SET_2 (B, 0, 0);
+  B_s = A_s;
+
+  FP_ADD_Q(C, A, B);
+  _FP_FRAC_SRL_2(C, _FP_WORKBITS);
+  _FP_FRAC_HIGH_RAW_Q(C) &= ~(_FP_W_TYPE)_FP_IMPLBIT_Q;
+  FP_TO_INT_Q(r, C, 64, s);
+  if (s > 0 && (_fex &= FP_EX_INVALID))
+    FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/sysdeps/sw_64/ots_sub.c b/sysdeps/sw_64/ots_sub.c
new file mode 100644
index 00000000..52662687
--- /dev/null
+++ b/sysdeps/sw_64/ots_sub.c
@@ -0,0 +1,38 @@
+/* Software floating-point emulation: subtraction.
+   Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "local-soft-fp.h"
+
+void
+_OtsSubX(long al, long ah, long bl, long bh, long _round)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(C);
+  AXP_DECL_RETURN_Q(c);
+
+  FP_INIT_ROUNDMODE;
+  AXP_UNPACK_SEMIRAW_Q(A, a);
+  AXP_UNPACK_SEMIRAW_Q(B, b);
+  FP_SUB_Q(C, A, B);
+  AXP_PACK_SEMIRAW_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+
+  AXP_RETURN_Q(c);
+}
diff --git a/sysdeps/sw_64/preconfigure b/sysdeps/sw_64/preconfigure
new file mode 100644
index 00000000..62b74ab5
--- /dev/null
+++ b/sysdeps/sw_64/preconfigure
@@ -0,0 +1,3 @@
+case "$machine" in
+sw_64*)		base_machine=sw_64 machine=sw_64/$machine
+esac
diff --git a/sysdeps/sw_64/rawmemchr.S b/sysdeps/sw_64/rawmemchr.S
new file mode 100644
index 00000000..a45aaee2
--- /dev/null
+++ b/sysdeps/sw_64/rawmemchr.S
@@ -0,0 +1,89 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Return pointer to first occurrence of CH in STR.  */
+
+#include <sysdep.h>
+
+	.set noreorder
+	.set noat
+
+ENTRY(__rawmemchr)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	zapnot	a1, 1, a1	# e0    : zero extend the search character
+	ldl_u   t0, 0(a0)	# .. e1 : load first quadword
+	sll	a1, 8, t5	# e0    : replicate the search character
+	andnot  a0, 7, v0	# .. e1 : align our loop pointer
+
+	or	t5, a1, a1	# e0    :
+	ldi	t4, -1		# .. e1 : build garbage mask
+	sll	a1, 16, t5	# e0    :
+	unop			#	:
+
+	mask7b	t4, a0, t4	# e0    :
+	or	t5, a1, a1	# .. e1 :
+	sll	a1, 32, t5	# e0    :
+	cmpgeb	zero, t4, t4	# .. e1 : bits set iff byte is garbage
+
+	or	t5, a1, a1	# e0    :
+	xor	t0, a1, t1	# .. e1 : make bytes == c zero
+	cmpgeb  zero, t1, t3	# e0    : bits set iff byte == c
+	unop			#	:
+
+	andnot	t3, t4, t0	# e0    : clear garbage bits
+	fnop			# .. fa :
+	unop			#	:
+	bne	t0, $found	# .. e1 (zdb)
+
+	.align 4
+$loop:
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+
+	cmpgeb	zero, t1, t0	# e0	: bits set iff byte == c
+	beq	t0, $loop	# .. e1 (zdb)
+
+$found:
+	negl    t0, t1		# e0    : clear all but least set bit
+	and     t0, t1, t0	# e1 (stall)
+	and     t0, 0xf0, t2	# e0    : binary search for that set bit
+	and	t0, 0xcc, t3	# .. e1 :
+
+	and	t0, 0xaa, t4	# e0    :
+	selne	t2, 4, t2, t2	# .. e1 :
+	selne	t3, 2, t3, t3	# e0    :
+	selne	t4, 1, t4, t4	# .. e1 :
+
+	addl	t2, t3, t2	# e0    :
+	addl	v0, t4, v0	# .. e1 :
+	addl	v0, t2, v0	# e0    :
+	ret			# .. e1 :
+
+	END(__rawmemchr)
+
+libc_hidden_def (__rawmemchr)
+weak_alias (__rawmemchr, rawmemchr)
diff --git a/sysdeps/sw_64/reml.S b/sysdeps/sw_64/reml.S
new file mode 100644
index 00000000..0076735d
--- /dev/null
+++ b/sysdeps/sw_64/reml.S
@@ -0,0 +1,93 @@
+/* Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson  <rth@twiddle.net>
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "div_libc.h"
+
+/* 32-bit signed int remainder.  This is not a normal C function.  Argument
+   registers are t10 and t11, the result goes in t12.  Only t12 and AT may
+   be clobbered.
+
+   The FPU can handle the division for all input values except zero.
+   All we have to do is compute the remainder via multiply-and-subtract.
+
+   The FPCR save/restore is due to the fact that the SW6 _will_ set FPCR_INE
+   for cvttq/c even without /sui being set.  It will not, however, properly
+   raise the exception, so we don't have to worry about FPCR_INED being clear
+   and so dying by SIGFPE.  */
+   /*__reml->__remw HUANGLM20161111*/
+#ifndef EXTEND
+#define EXTEND(S,D)	sextl S, D
+#endif
+
+	.text
+	.align	4
+	.globl	__remw
+	.type	__remw, @funcnoplt
+	.usepv	__remw, no
+
+	cfi_startproc
+	cfi_return_column (RA)
+__remw:
+        ldi     sp, -FRAME(sp)
+        cfi_def_cfa_offset (FRAME)
+        CALL_MCOUNT
+        fstd     $f0, 0(sp)
+        excb
+        beq     Y, DIVBYZERO
+
+        fstd    $f1, 8(sp)
+        fstd    $f2, 16(sp)
+        fstd    $f3, 40(sp)
+        fstd    $f4, 48(sp)
+        cfi_rel_offset ($f0, 0)
+        cfi_rel_offset ($f1, 8)
+        cfi_rel_offset ($f2, 16)
+        cfi_rel_offset ($f3, 40)
+        cfi_rel_offset ($f4, 48)
+
+	rfpcr	$f2 /* HUANGLM20161111 */
+        EXTEND  (X, RV)
+        EXTEND  (Y, AT)
+        _ITOFT2 RV, $f0, 24, AT, $f1, 32
+        fcvtld  $f0, $f3
+        fcvtld  $f1, $f4
+        fdivd   $f3, $f4, $f0
+        fcvtdl_z  $f0, $f3
+
+	wfpcr	$f2 /* HUANGLM20161111 */
+        _FTOIT  $f3, RV, 24
+        fldd    $f0, 0(sp)
+        mulw    RV, Y, RV
+        fldd    $f1, 8(sp)
+        fldd    $f2, 16(sp)
+        fldd    $f3, 40(sp)
+        fldd    $f4, 48(sp)
+        ldi     sp, FRAME(sp)
+        cfi_restore ($f0)
+        cfi_restore ($f1)
+        cfi_restore ($f2)
+        cfi_restore ($f3)
+        cfi_restore ($f4)
+        cfi_def_cfa_offset (0) 
+       	subw	X, RV, RV
+	ret	$31, (RA), 1
+
+	cfi_endproc
+	.size	__remw, .-__remw
+
+	DO_DIVBYZERO
diff --git a/sysdeps/sw_64/remlu.S b/sysdeps/sw_64/remlu.S
new file mode 100644
index 00000000..3c12f7bf
--- /dev/null
+++ b/sysdeps/sw_64/remlu.S
@@ -0,0 +1,4 @@
+#define UNSIGNED
+#define EXTEND(S,D)	zapnot S, 15, D
+#define __remw		__remwu
+#include <reml.S>
diff --git a/sysdeps/sw_64/remq.S b/sysdeps/sw_64/remq.S
new file mode 100644
index 00000000..0e806bc2
--- /dev/null
+++ b/sysdeps/sw_64/remq.S
@@ -0,0 +1,283 @@
+/* Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "div_libc.h"
+
+
+/* 64-bit signed long remainder.  These are not normal C functions.  Argument
+   registers are t10 and t11, the result goes in t12.  Only t12 and AT may
+   be clobbered.
+
+   Theory of operation here is that we can use the FPU divider for virtually
+   all operands that we see: all dividend values between -2**53 and 2**53-1
+   can be computed directly.  Note that divisor values need not be checked
+   against that range because the rounded fp value will be close enough such
+   that the quotient is < 1, which will properly be truncated to zero when we
+   convert back to integer.
+
+   When the dividend is outside the range for which we can compute exact
+   results, we use the fp quotent as an estimate from which we begin refining
+   an exact integral value.  This reduces the number of iterations in the
+   shift-and-subtract loop significantly.
+
+   The FPCR save/restore is due to the fact that the SW6 _will_ set FPCR_INE
+   for cvttq/c even without /sui being set.  It will not, however, properly
+   raise the exception, so we don't have to worry about FPCR_INED being clear
+   and so dying by SIGFPE.  */
+   /*__remq -> __reml HUANGLM20161111*/
+	.text
+	.align	4
+	.globl	__reml
+	.type	__reml, @funcnoplt
+	.usepv	__reml, no
+
+	cfi_startproc
+	cfi_return_column (RA)
+__reml:
+	ldi	sp, -FRAME(sp)
+	cfi_def_cfa_offset (FRAME)
+	CALL_MCOUNT
+
+	/* Get the fp divide insn issued as quickly as possible.  After
+	   that's done, we have at least 22 cycles until its results are
+	   ready -- all the time in the world to figure out how we're
+	   going to use the results.  */
+	fstd	$f0, 0(sp)
+	excb
+	beq	Y, DIVBYZERO
+
+	fstd	$f1, 8(sp)
+	fstd	$f3, 48(sp)
+	fstd	$f4, 56(sp)
+	fstd	$f5, 64(sp)
+	cfi_rel_offset ($f0, 0)
+	cfi_rel_offset ($f1, 8)
+	cfi_rel_offset ($f3, 48)
+	cfi_rel_offset ($f4, 56)
+	cfi_rel_offset ($f5, 64)
+
+	rfpcr	$f3 /* HUANGLM20161111 */
+	_ITOFT2	X, $f0, 16, Y, $f1, 24
+	fcvtld	$f0, $f4
+	fcvtld	$f1, $f5
+	fdivd	$f4, $f5, $f0
+
+	/* Check to see if X fit in the double as an exact value.  */
+	sll	X, (64-53), AT
+	fldd	$f1, 8(sp)
+	sra	AT, (64-53), AT
+	cmpeq	X, AT, AT
+	beq	AT, $x_big
+        fcvtdl_z $f0, $f4
+
+	wfpcr	$f3 /* HUANGLM20161111 */
+	_FTOIT	$f4, AT, 16
+	mull	AT, Y, AT
+	fldd	$f0, 0(sp)
+	fldd	$f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+	cfi_restore ($f1)
+	cfi_remember_state
+	cfi_restore ($f0)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+	ldi	sp, FRAME(sp)
+	subl	X, AT, RV
+	ret	$31, (RA), 1
+
+	.align	4
+	cfi_restore_state
+$x_big:
+	/* If we get here, X is large enough that we don't expect exact
+	   results, and neither X nor Y got mis-translated for the fp
+	   division.  Our task is to take the fp result, figure out how
+	   far it's off from the correct result and compute a fixup.  */
+	stl	t0, 32(sp)
+	stl	t1, 40(sp)
+	stl	t2, 16(sp)
+	stl	t5, 24(sp)
+	cfi_rel_offset (t0, 32)
+	cfi_rel_offset (t1, 40)
+	cfi_rel_offset (t2, 16)
+	cfi_rel_offset (t5, 24)
+
+#define Q	t0		/* quotient */
+#define R	RV		/* remainder */
+#define SY	t1		/* scaled Y */
+#define S	t2		/* scalar */
+#define QY	t3		/* Q*Y */
+
+	/* The fixup code below can only handle unsigned values.  */
+	or	X, Y, AT
+	mov	$31, t5
+	blt	AT, $fix_sign_in
+$fix_sign_in_ret1:
+#ifdef HUANGLM20161111 
+	cvttq/c	$f0, $f0
+#else
+	fcvtdl_z $f0, $f4
+#endif
+	_FTOIT	$f4, Q, 8
+	.align	3
+$fix_sign_in_ret2:
+	fldd	$f0, 0(sp)
+	stl	t3, 0(sp)
+	cfi_restore ($f0)
+	cfi_rel_offset (t3, 0)
+
+	mull	Q, Y, QY
+	stl	t4, 8(sp)
+	wfpcr	$f3 /* HUANGLM20161111 */
+	cfi_rel_offset (t4, 8)
+
+	subl	QY, X, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_high
+
+$q_high_ret:
+	subl	X, QY, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_low
+
+$q_low_ret:
+	ldl	t0, 32(sp)
+	ldl	t1, 40(sp)
+	ldl	t2, 16(sp)
+	bne	t5, $fix_sign_out
+
+$fix_sign_out_ret:
+	ldl	t3, 0(sp)
+	ldl	t4, 8(sp)
+	ldl	t5, 24(sp)
+	fldd	$f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+	ldi	sp, FRAME(sp)
+	cfi_remember_state
+	cfi_restore (t0)
+	cfi_restore (t1)
+	cfi_restore (t2)
+	cfi_restore (t3)
+	cfi_restore (t4)
+	cfi_restore (t5)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+
+	.align	4
+	cfi_restore_state
+	/* The quotient that we computed was too large.  We need to reduce
+	   it by S such that Y*S >= R.  Obviously the closer we get to the
+	   correct value the better, but overshooting high is ok, as we'll
+	   fix that up later.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_high:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	subl	Q, S, Q
+	unop
+	subl	QY, SY, QY
+	br	$q_high_ret
+
+	.align	4
+	/* The quotient that we computed was too small.  Divide Y by the
+	   current remainder (R) and add that to the existing quotient (Q).
+	   The expectation, of course, is that R is much smaller than X.  */
+	/* Begin with a shift-up loop.  Compute S such that Y*S >= R.  We
+	   already have a copy of Y in SY and the value 1 in S.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_low:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	/* Shift-down and subtract loop.  Each iteration compares our scaled
+	   Y (SY) with the remainder (R); if SY <= R then X is divisible by
+	   Y's scalar (S) so add it to the quotient (Q).  */
+2:	addl	Q, S, t3
+	srl	S, 1, S
+	cmpule	SY, R, AT
+	subl	R, SY, t4
+
+	selne	AT, t3, Q, Q
+	selne	AT, t4, R, R
+	srl	SY, 1, SY
+	bne	S, 2b
+
+	br	$q_low_ret
+
+	.align	4
+$fix_sign_in:
+	/* If we got here, then X|Y is negative.  Need to adjust everything
+	   such that we're doing unsigned division in the fixup loop.  */
+	/* T5 records the changes we had to make:
+		bit 0:	set if X was negated.  Note that the sign of the
+			remainder follows the sign of the divisor.
+		bit 2:	set if Y was negated.
+	*/
+	xor	X, Y, t1
+	cmplt	X, 0, t5
+	negl	X, t0
+	selne	t5, t0, X, X
+
+	cmplt	Y, 0, AT
+	negl	Y, t0
+	s4addl	AT, t5, t5
+	selne	AT, t0, Y, Y
+
+	bge	t1, $fix_sign_in_ret1
+#ifdef HUANGLM20161111 
+	cvttq/c	$f0, $f4
+#else
+	fcvtdl_z $f0, $f4
+#endif
+	_FTOIT	$f4, Q, 8
+	.align	3
+	negl	Q, Q
+	br	$fix_sign_in_ret2
+
+	.align	4
+$fix_sign_out:
+	/* Now we get to undo what we did above.  */
+	/* ??? Is this really faster than just increasing the size of
+	   the stack frame and storing X and Y in memory?  */
+	and	t5, 4, AT
+	negl	Y, t4
+	selne	AT, t4, Y, Y
+
+	negl	X, t4
+	sellbs	t5, t4, X, X
+	negl	RV, t4
+	sellbs	t5, t4, RV, RV
+
+	br	$fix_sign_out_ret
+
+	cfi_endproc
+	.size	__reml, .-__reml
+
+	DO_DIVBYZERO
diff --git a/sysdeps/sw_64/remqu.S b/sysdeps/sw_64/remqu.S
new file mode 100644
index 00000000..7d300549
--- /dev/null
+++ b/sysdeps/sw_64/remqu.S
@@ -0,0 +1,340 @@
+/* Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "div_libc.h"
+
+
+/* 64-bit unsigned long remainder.  These are not normal C functions.  Argument
+   registers are t10 and t11, the result goes in t12.  Only t12 and AT may be
+   clobbered.
+
+   Theory of operation here is that we can use the FPU divider for virtually
+   all operands that we see: all dividend values between -2**53 and 2**53-1
+   can be computed directly.  Note that divisor values need not be checked
+   against that range because the rounded fp value will be close enough such
+   that the quotient is < 1, which will properly be truncated to zero when we
+   convert back to integer.
+
+   When the dividend is outside the range for which we can compute exact
+   results, we use the fp quotent as an estimate from which we begin refining
+   an exact integral value.  This reduces the number of iterations in the
+   shift-and-subtract loop significantly.
+
+   The FPCR save/restore is due to the fact that the SW6 _will_ set FPCR_INE
+   for cvttq/c even without /sui being set.  It will not, however, properly
+   raise the exception, so we don't have to worry about FPCR_INED being clear
+   and so dying by SIGFPE.  */
+   /*__remqu -> __remlu  HUANGLM20161111*/
+	.text
+	.align	4
+	.globl	__remlu
+	.type	__remlu, @funcnoplt
+	.usepv	__remlu, no
+
+	cfi_startproc
+	cfi_return_column (RA)
+__remlu:
+	ldi	sp, -FRAME(sp)
+	cfi_def_cfa_offset (FRAME)
+	CALL_MCOUNT
+
+	/* Get the fp divide insn issued as quickly as possible.  After
+	   that's done, we have at least 22 cycles until its results are
+	   ready -- all the time in the world to figure out how we're
+	   going to use the results.  */
+	subl	Y, 1, AT
+#	fstd	$f0, 0(sp)      /* LIJM20201110 */
+	and	Y, AT, AT
+	beq	AT, $powerof2
+	fstd	$f0, 0(sp)
+
+
+	fstd	$f1, 8(sp)
+	fstd	$f3, 48(sp)
+	fstd	$f4, 56(sp)
+	fstd	$f5, 64(sp)
+#	beq	AT, $powerof2
+	cfi_rel_offset ($f0, 0)
+	cfi_rel_offset ($f1, 8)
+	cfi_rel_offset ($f3, 48)
+	cfi_rel_offset ($f4, 56)
+	cfi_rel_offset ($f5, 64)
+
+        rfpcr $f3   /* HUANGLM20161111 */
+	_ITOFT2	X, $f0, 16, Y, $f1, 24
+
+	fcvtld	$f0, $f4
+	fcvtld	$f1, $f5
+
+	blt	X, $x_is_neg
+setfpec1
+	fdivd	$f4, $f5, $f0
+
+	/* Check to see if Y was mis-converted as signed value.  */
+	fldd	$f1, 8(sp)
+	blt	Y, $y_is_neg
+
+	/* Check to see if X fit in the double as an exact value.  */
+	srl	X, 53, AT
+	bne	AT, $x_big
+
+	/* If we get here, we're expecting exact results from the division.
+	   Do nothing else besides convert, compute remainder, clean up.  */
+        fcvtdl_z  $f0, $f4
+        wfpcr $f3 /* HUANGLM20161111 */
+	_FTOIT	$f4, AT, 16
+	mull	AT, Y, AT
+	fldd	$f0, 0(sp)
+	fldd	$f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+	ldi	sp, FRAME(sp)
+	cfi_remember_state
+	cfi_restore ($f0)
+	cfi_restore ($f1)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+
+	.align	4
+	subl	X, AT, RV
+	ret	$31, (RA), 1
+	.align	4
+	cfi_restore_state
+$x_is_neg:
+	/* If we get here, X is so big that bit 63 is set, which made the
+	   conversion come out negative.  Fix it up lest we not even get
+	   a good estimate.  */
+	ldih	AT, 0x5f80		/* 2**64 as float.  */
+	fstd	$f2, 24(sp)
+	fstd	$f6, 72(sp)
+	cfi_rel_offset ($f2, 24)
+	cfi_rel_offset ($f6, 72)
+	_ITOFS	AT, $f2, 16
+	.align	4          /* LIJM20201110 */
+	faddd	$f4, $f2, $f6
+	fdivd	$f6, $f5, $f0
+
+	/* Ok, we've now the divide issued.  Continue with other checks.  */
+#	.align	4
+	fldd	$f1, 8(sp)
+	unop
+	fldd	$f2, 24(sp)
+	fldd	$f6, 72(sp)
+	blt	Y, $y_is_neg
+	cfi_restore ($f1)
+	cfi_restore ($f2)
+	cfi_restore ($f6)
+	cfi_remember_state	/* for y_is_neg */
+
+	.align	4
+#ifdef HUANGLM20161111       
+$x_big:
+	/* If we get here, X is large enough that we don't expect exact
+	   results, and neither X nor Y got mis-translated for the fp
+	   division.  Our task is to take the fp result, figure out how
+	   far it's off from the correct result and compute a fixup.  */
+#	stq	t0, 32(sp)
+#	stq	t1, 40(sp)
+	stq	t2, 16(sp)
+	stq	t3, 24(sp)
+#	cfi_rel_offset (t0, 32)
+#	cfi_rel_offset (t1, 40)
+	cfi_rel_offset (t2, 16)
+	cfi_rel_offset (t3, 24)
+
+#define Q	t0		/* quotient */
+#define R	RV		/* remainder */
+#define SY	t1		/* scaled Y */
+#define S	t2		/* scalar */
+#define QY	t3		/* Q*Y */
+
+	cvttq/c	$f0, $f0
+#else
+$x_big:
+	/* If we get here, X is large enough that we don't expect exact
+	   results, and neither X nor Y got mis-translated for the fp
+	   division.  Our task is to take the fp result, figure out how
+	   far it's off from the correct result and compute a fixup.  */
+	stl	t0, 32(sp)
+	stl	t1, 40(sp)
+	stl	t2, 16(sp)
+	stl	t3, 24(sp)
+	cfi_rel_offset (t0, 32)
+	cfi_rel_offset (t1, 40)
+	cfi_rel_offset (t2, 16)
+	cfi_rel_offset (t3, 24)
+
+#define Q	t0		/* quotient */
+#define R	RV		/* remainder */
+#define SY	t1		/* scaled Y */
+#define S	t2		/* scalar */
+#define QY	t3		/* Q*Y */
+
+	fcvtdl_z $f0, $f4
+#endif
+	_FTOIT	$f4, Q, 8
+	mull	Q, Y, QY
+
+	.align	4
+	stl	t4, 8(sp)
+	excb
+	fldd	$f0, 0(sp)
+	wfpcr	$f3 /* HUANGLM20161111 */
+	cfi_rel_offset (t4, 8)
+	cfi_restore ($f0)
+
+	subl	QY, X, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_high
+
+$q_high_ret:
+	subl	X, QY, R
+	mov	Y, SY
+	mov	1, S
+	bgt	R, $q_low
+
+$q_low_ret:
+	ldl	t4, 8(sp)
+	ldl	t0, 32(sp)
+	ldl	t1, 40(sp)
+	ldl	t2, 16(sp)
+
+	ldl	t3, 24(sp)
+	fldd	$f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+	ldi	sp, FRAME(sp)
+	cfi_remember_state
+	cfi_restore (t0)
+	cfi_restore (t1)
+	cfi_restore (t2)
+	cfi_restore (t3)
+	cfi_restore (t4)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+
+	.align	4
+	cfi_restore_state
+	/* The quotient that we computed was too large.  We need to reduce
+	   it by S such that Y*S >= R.  Obviously the closer we get to the
+	   correct value the better, but overshooting high is ok, as we'll
+	   fix that up later.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_high:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	subl	Q, S, Q
+	unop
+	subl	QY, SY, QY
+	br	$q_high_ret
+
+	.align	4
+	/* The quotient that we computed was too small.  Divide Y by the
+	   current remainder (R) and add that to the existing quotient (Q).
+	   The expectation, of course, is that R is much smaller than X.  */
+	/* Begin with a shift-up loop.  Compute S such that Y*S >= R.  We
+	   already have a copy of Y in SY and the value 1 in S.  */
+0:
+	addl	SY, SY, SY
+	addl	S, S, S
+$q_low:
+	cmpult	SY, R, AT
+	bne	AT, 0b
+
+	/* Shift-down and subtract loop.  Each iteration compares our scaled
+	   Y (SY) with the remainder (R); if SY <= R then X is divisible by
+	   Y's scalar (S) so add it to the quotient (Q).  */
+2:	addl	Q, S, t3
+	srl	S, 1, S
+	cmpule	SY, R, AT
+	subl	R, SY, t4
+
+	selne	AT, t3, Q, Q
+	selne	AT, t4, R, R
+	srl	SY, 1, SY
+	bne	S, 2b
+
+	br	$q_low_ret
+
+	.align	4
+	cfi_restore_state
+#ifdef HUANGLM20161111
+$y_is_neg:
+	/* If we get here, Y is so big that bit 63 is set.  The results
+	   from the divide will be completely wrong.  Fortunately, the
+	   quotient must be either 0 or 1, so the remainder must be X
+	   or X-Y, so just compute it directly.  */
+	cmpule	Y, X, AT
+	subq	X, Y, RV
+	ldt	$f0, 0(sp)
+	cmoveq	AT, X, RV
+
+	ldq	t0, 32(sp)
+	ldq	t1, 40(sp)
+	lda	sp, FRAME(sp)
+	cfi_restore ($f0)
+	cfi_restore (t0)
+	cfi_restore (t1)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+#else
+$y_is_neg:
+	/* If we get here, Y is so big that bit 63 is set.  The results
+	   from the divide will be completely wrong.  Fortunately, the
+	   quotient must be either 0 or 1, so the remainder must be X
+	   or X-Y, so just compute it directly.  */
+	cmpule	Y, X, AT
+	nop
+	wfpcr	$f3
+	subl	X, Y, RV
+	fldd	$f0, 0(sp)
+	fldd    $f3, 48(sp)
+	fldd	$f4, 56(sp)
+	fldd	$f5, 64(sp)
+	seleq	AT, X, RV, RV
+
+	ldi	sp, FRAME(sp)
+	cfi_restore ($f0)
+	cfi_restore ($f3)
+	cfi_restore ($f4)
+	cfi_restore ($f5)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+#endif
+	.align	4
+	cfi_def_cfa_offset (FRAME)
+$powerof2:
+	subl	Y, 1, AT
+	beq	Y, DIVBYZERO
+	and	X, AT, RV
+	ldi	sp, FRAME(sp)
+	cfi_def_cfa_offset (0)
+	ret	$31, (RA), 1
+
+	cfi_endproc
+	.size	__remlu, .-__remlu
+
+	DO_DIVBYZERO
diff --git a/sysdeps/sw_64/rshift.S b/sysdeps/sw_64/rshift.S
new file mode 100644
index 00000000..f399771c
--- /dev/null
+++ b/sysdeps/sw_64/rshift.S
@@ -0,0 +1,105 @@
+ # Sw_64 1621 __mpn_rshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 4.8 cycles/limb on the 1621.  With infinite unrolling,
+ # it would take 4 cycles/limb.  It should be possible to get down to 3
+ # cycles/limb since both ldl and stl can be paired with the other used
+ # instructions.  But there are many restrictions in the 1621 pipeline that
+ # makes it hard, if not impossible, to get down to 3 cycles/limb:
+
+ # 1. ldl has a 3 cycle delay, srl and sll have a 2 cycle delay.
+ # 2. Only aligned instruction pairs can be paired.
+ # 3. The store buffer or silo might not be able to deal with the bandwidth.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_rshift
+	.ent	__mpn_rshift
+__mpn_rshift:
+	.frame	$30,0,$26,0
+
+	ldl	$4,0($17)	# load first limb
+	addl	$17,8,$17
+	subl	$31,$19,$7
+	subl	$18,1,$18
+	and	$18,4-1,$20	# number of limbs in first loop
+	sll	$4,$7,$0	# compute function result
+
+	beq	$20,.L0
+	subl	$18,$20,$18
+
+	.align	3
+.Loop0:
+	ldl	$3,0($17)
+	addl	$16,8,$16
+	addl	$17,8,$17
+	subl	$20,1,$20
+	srl	$4,$19,$5
+	sll	$3,$7,$6
+	bis	$3,$3,$4
+	bis	$5,$6,$8
+	stl	$8,-8($16)
+	bne	$20,.Loop0
+
+.L0:	beq	$18,.Lend
+
+	.align	3
+.Loop:	ldl	$3,0($17)
+	addl	$16,32,$16
+	subl	$18,4,$18
+	srl	$4,$19,$5
+	sll	$3,$7,$6
+
+	ldl	$4,8($17)
+	srl	$3,$19,$1
+	bis	$5,$6,$8
+	stl	$8,-32($16)
+	sll	$4,$7,$2
+
+	ldl	$3,16($17)
+	srl	$4,$19,$5
+	bis	$1,$2,$8
+	stl	$8,-24($16)
+	sll	$3,$7,$6
+
+	ldl	$4,24($17)
+	srl	$3,$19,$1
+	bis	$5,$6,$8
+	stl	$8,-16($16)
+	sll	$4,$7,$2
+
+	addl	$17,32,$17
+	bis	$1,$2,$8
+	stl	$8,-8($16)
+
+	bgt	$18,.Loop
+
+.Lend:	srl	$4,$19,$8
+	stl	$8,0($16)
+	ret	$31,($26),1
+	.end	__mpn_rshift
diff --git a/sysdeps/sw_64/setjmp.S b/sysdeps/sw_64/setjmp.S
new file mode 100644
index 00000000..ec1b548d
--- /dev/null
+++ b/sysdeps/sw_64/setjmp.S
@@ -0,0 +1,121 @@
+/* Copyright (C) 1992-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ASSEMBLY__
+
+#include <sysdep.h>
+#include <pointer_guard.h>
+#include <jmpbuf-offsets.h>
+
+	.ent __sigsetjmp
+	.global __sigsetjmp
+__sigsetjmp:
+	ldgp    gp, 0(pv)
+
+$sigsetjmp_local:
+#ifndef PIC
+#define FRAME	16
+	subl    sp, FRAME, sp
+	.frame  sp, FRAME, ra, 0
+	stl     ra, 0(sp)
+	.mask   0x04000000, -FRAME
+#else
+#define FRAME	0
+	.frame	sp, FRAME, ra, 0
+#endif
+#ifdef PROF
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	stl	s0, JB_S0*8(a0)
+	stl	s1, JB_S1*8(a0)
+	stl	s2, JB_S2*8(a0)
+	stl	s3, JB_S3*8(a0)
+	stl	s4, JB_S4*8(a0)
+	stl	s5, JB_S5*8(a0)
+#ifdef PTR_MANGLE
+	PTR_MANGLE(t1, ra, t0)
+	stl	t1, JB_PC*8(a0)
+#else
+	stl	ra, JB_PC*8(a0)
+#endif
+#if defined(PTR_MANGLE) && FRAME == 0
+	PTR_MANGLE2(t1, sp, t0)
+#else
+	addl	sp, FRAME, t1
+# ifdef PTR_MANGLE
+	PTR_MANGLE2(t1, t1, t0)
+# endif
+#endif
+	stl	t1, JB_SP*8(a0)
+#ifdef PTR_MANGLE
+	PTR_MANGLE2(t1, fp, t0)
+	stl	t1, JB_FP*8(a0)
+#else
+	stl	fp, JB_FP*8(a0)
+#endif
+	fstd	$f2, JB_F2*8(a0)
+	fstd	$f3, JB_F3*8(a0)
+	fstd	$f4, JB_F4*8(a0)
+	fstd	$f5, JB_F5*8(a0)
+	fstd	$f6, JB_F6*8(a0)
+	fstd	$f7, JB_F7*8(a0)
+	fstd	$f8, JB_F8*8(a0)
+	fstd	$f9, JB_F9*8(a0)
+
+#ifndef PIC
+	/* Call to C to (potentially) save our signal mask.  */
+	call	ra, __sigjmp_save
+	ldl	ra, 0(sp)
+	addl	sp, 16, sp
+	ret
+#elif IS_IN (rtld)
+	/* In ld.so we never save the signal mask.  */
+	mov	0, v0
+	ret
+#else
+	/* Tailcall to save the signal mask.  */
+	br	$31, __sigjmp_save	!samegp
+#endif
+
+END(__sigsetjmp)
+hidden_def (__sigsetjmp)
+
+/* Put these traditional entry points in the same file so that we can
+   elide much of the nonsense in trying to jmp to the real function.  */
+
+ENTRY(_setjmp)
+	ldgp	gp, 0(pv)
+	.prologue 1
+	mov	0, a1
+	br	$sigsetjmp_local
+END(_setjmp)
+libc_hidden_def (_setjmp)
+
+ENTRY(setjmp)
+	ldgp	gp, 0(pv)
+	.prologue 1
+	mov	1, a1
+	br	$sigsetjmp_local
+END(setjmp)
+
+weak_extern(_setjmp)
+weak_extern(setjmp)
diff --git a/sysdeps/sw_64/sfp-machine.h b/sysdeps/sw_64/sfp-machine.h
new file mode 100644
index 00000000..bd11b719
--- /dev/null
+++ b/sysdeps/sw_64/sfp-machine.h
@@ -0,0 +1,99 @@
+/* Machine-dependent software floating-point definitions.
+   Sw_64 userland IEEE 128-bit version.
+   Copyright (C) 2004-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com),
+		  Jakub Jelinek (jj@ultra.linux.cz) and
+		  David S. Miller (davem@redhat.com).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv_libc.h>
+
+#define _FP_W_TYPE_SIZE		64
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)					\
+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)
+#define _FP_MUL_MEAT_D(R,X,Y)					\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)					\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_2_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+#define _FP_QNANNEGATEDP 0
+
+/* Sw_64 Architecture Handbook, 4.7.10.4 sez that we should prefer any
+   type of NaN in Fb, then Fa.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)                      \
+  do {                                                          \
+    R##_s = Y##_s;                                              \
+    _FP_FRAC_COPY_##wc(R,X);                                    \
+    R##_c = FP_CLS_NAN;                                         \
+  } while (0)
+
+/* Rounding mode settings.  */
+#define FP_RND_NEAREST		FE_TONEAREST
+#define FP_RND_ZERO		FE_TOWARDZERO
+#define FP_RND_PINF		FE_UPWARD
+#define FP_RND_MINF		FE_DOWNWARD
+
+/* Obtain the current rounding mode.  It's given as an argument to
+   all the Ots functions, with 4 meaning "dynamic".  */
+#define FP_ROUNDMODE		_round
+
+/* Exception flags. */
+#define FP_EX_INVALID		FE_INVALID
+#define FP_EX_OVERFLOW		FE_OVERFLOW
+#define FP_EX_UNDERFLOW		FE_UNDERFLOW
+#define FP_EX_DIVZERO		FE_DIVBYZERO
+#define FP_EX_INEXACT		FE_INEXACT
+
+#define _FP_TININESS_AFTER_ROUNDING 1
+
+#define FP_INIT_ROUNDMODE					\
+do {								\
+  if (__builtin_expect (_round == 4, 0))			\
+    {								\
+      unsigned long t;						\
+      __asm__ __volatile__("excb; rfpcr %0" : "=f"(t));	\
+      _round = (t >> FPCR_ROUND_SHIFT) & 3;			\
+    }								\
+} while (0)
+
+/* We copy the libm function into libc for soft-fp.  */
+extern int __feraiseexcept (int __excepts) attribute_hidden;
+
+#define FP_HANDLE_EXCEPTIONS					\
+do {								\
+  if (__builtin_expect (_fex, 0))				\
+    __feraiseexcept (_fex);					\
+} while (0)
+
+#define FP_TRAPPING_EXCEPTIONS					\
+  ((__ieee_get_fp_control () & SWCR_ENABLE_MASK) << SWCR_ENABLE_SHIFT)
diff --git a/sysdeps/sw_64/sotruss-lib.c b/sysdeps/sw_64/sotruss-lib.c
new file mode 100644
index 00000000..39073c3a
--- /dev/null
+++ b/sysdeps/sw_64/sotruss-lib.c
@@ -0,0 +1,50 @@
+/* Override generic sotruss-lib.c to define actual functions for Sw_64.
+   Copyright (C) 2012-2020 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define HAVE_ARCH_PLTENTER
+#define HAVE_ARCH_PLTEXIT
+
+#include <elf/sotruss-lib.c>
+
+ElfW(Addr)
+la_sw_64_gnu_pltenter (ElfW(Sym) *sym __attribute__ ((unused)),
+		       unsigned int ndx __attribute__ ((unused)),
+		       uintptr_t *refcook, uintptr_t *defcook,
+		       La_sw_64_regs *regs, unsigned int *flags,
+		       const char *symname, long int *framesizep)
+{
+  print_enter (refcook, defcook, symname,
+	       regs->lr_r16, regs->lr_r17, regs->lr_r18, *flags);
+
+  /* No need to copy anything, we will not need the parameters in any case.  */
+  *framesizep = 0;
+
+  return sym->st_value;
+}
+
+unsigned int
+la_sw_64_gnu_pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
+		      uintptr_t *defcook,
+		      const struct La_sw_64_regs *inregs,
+		      struct La_sw_64_retval *outregs, const char *symname)
+{
+  print_exit (refcook, defcook, symname, outregs->lrv_r0);
+
+  return 0;
+}
diff --git a/sysdeps/sw_64/stackinfo.h b/sysdeps/sw_64/stackinfo.h
new file mode 100644
index 00000000..db0e5882
--- /dev/null
+++ b/sysdeps/sw_64/stackinfo.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 2001-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+/* On Sw_64 the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Default to an executable stack.  PF_X can be overridden if PT_GNU_STACK is
+ * present, but it is presumed absent.  */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
+
+#endif	/* stackinfo.h */
diff --git a/sysdeps/sw_64/start.S b/sysdeps/sw_64/start.S
new file mode 100644
index 00000000..7736531e
--- /dev/null
+++ b/sysdeps/sw_64/start.S
@@ -0,0 +1,108 @@
+/* Startup code for Sw_64/ELF.
+   Copyright (C) 1993-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+	.text
+	.align 3
+	.globl _start
+	.ent _start, 0
+	.type _start,@function
+_start:
+	.frame	$15, 0, $15
+	br	gp, 1f
+1:	ldgp	gp, 0(gp)
+	subl	sp, 16, sp
+	mov	0, $15
+	.prologue 0
+
+//set fpcr 45 =1
+        rfpcr $f0
+        fimovd $f0,a1
+        ldi a2,1($31)
+        sll a2,45,a2
+        bis a1,a2,a1
+        ifmovd a1,$f0
+        wfpcr $f0
+
+  /* Load address of the user's main function.  */
+#ifndef XIEWB20190926_MIEEE
+//whether setfpec0 or setfpec1 ?
+       // setfpec0
+        setfpec1
+#endif
+	ldi	a0, main
+
+	ldw	a1, 16(sp)	/* get argc */
+	ldi	a2, 24(sp)	/* get argv */
+
+  /* Load address of our own entry points to .fini and .init.  */
+	mov	$r31, a3
+	mov	$r31, a4
+
+  /* Store address of the shared library termination function.  */
+	mov	v0, a5
+
+  /* Provide the highest stack address to the user code.  */
+	stl	sp, 0(sp)
+
+/* For 256 simd, we should change the value of $SP to 32 bytes align */
+       and     sp, 0x1f, s0
+       beq     s0, 2f
+       subl    sp, 0x10, sp
+2:
+  /* Call the user's main function, and exit with its value.
+     But let the libc call main.  */
+	call	ra, __libc_start_main
+
+/* Reload sp */
+        beq     s0, 3f
+        addl    sp, 0x10, sp
+3:
+  /* Die very horribly if exit returns.  Call_pal hlt is callable from
+     kernel mode only; this will result in an illegal instruction trap.  */
+	sys_call 0
+	.end _start
+
+/* For ECOFF backwards compatibility. */
+weak_alias (_start, __start)
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.weak data_start
+	data_start = __data_start
diff --git a/sysdeps/sw_64/stpcpy.S b/sysdeps/sw_64/stpcpy.S
new file mode 100644
index 00000000..55702b20
--- /dev/null
+++ b/sysdeps/sw_64/stpcpy.S
@@ -0,0 +1,55 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy a null-terminated string from SRC to DST.  Return a pointer
+   to the null-terminator in the source.  */
+
+#include <sysdep.h>
+
+	.text
+
+ENTRY(__stpcpy)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	call	t9, __stxcpy	# do the work of the copy
+
+	and	t8, 0xf0, t2	# binary search for byte offset of the
+	and	t8, 0xcc, t1	# last byte written.
+	and	t8, 0xaa, t0
+	andnot	a0, 7, a0
+	selne	t2, 4, t2, t2
+	selne	t1, 2, t1, t1
+	selne	t0, 1, t0, t0
+	addl	a0, t2, v0
+	addl	t0, t1, t0
+	addl	v0, t0, v0
+
+	ret
+
+	END(__stpcpy)
+
+weak_alias (__stpcpy, stpcpy)
+libc_hidden_def (__stpcpy)
+libc_hidden_builtin_def (stpcpy)
diff --git a/sysdeps/sw_64/stpncpy.S b/sysdeps/sw_64/stpncpy.S
new file mode 100644
index 00000000..3a2989a9
--- /dev/null
+++ b/sysdeps/sw_64/stpncpy.S
@@ -0,0 +1,106 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@tamu.edu)
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy no more than COUNT bytes of the null-terminated string from
+   SRC to DST.  If SRC does not cover all of COUNT, the balance is
+   zeroed.  Return the address of the terminating null in DEST, if
+   any, else DEST + COUNT.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+	.text
+
+ENTRY(__stpncpy)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+#endif
+	.prologue 1
+
+	beq	a2, $zerocount
+	call	t9, __stxncpy	# do the work of the copy
+
+	and	t8, 0xf0, t3	# binary search for byte offset of the
+	and	t8, 0xcc, t2	# last byte written.
+	and	t8, 0xaa, t1
+	andnot	a0, 7, v0
+	selne	t3, 4, t3, t3
+	selne	t2, 2, t2, t2
+	selne	t1, 1, t1, t1
+	addl	v0, t3, v0
+	addl	t1, t2, t1
+	addl	v0, t1, v0
+
+	bne	a2, $multiword	# do we have full words left?
+
+	.align 3
+	zapnot	t0, t8, t4	# e0    : was last byte a null?
+	subl	t8, 1, t2	# .. e1 :
+	addl	v0, 1, t5	# e0    :
+	subl	t10, 1, t3	# .. e1 :
+	or	t2, t8, t2	# e0    : clear the bits between the last
+	or	t3, t10, t3	# .. e1 : written byte and the last byte in
+	andnot	t3, t2, t3	# e0    : COUNT
+	selne	t4, t5, v0, v0	# .. e1 : if last written wasnt null, inc v0
+	zap	t0, t3, t0	# e0    :
+	stl_u	t0, 0(a0)	# e1    :
+	ret			# .. e1 :
+
+	.align 3
+$multiword:
+	subl	t8, 1, t7	# e0    : clear the final bits in the prev
+	or	t7, t8, t7	# e1    : word
+	zapnot	t0, t7, t0	# e0    :
+	subl	a2, 1, a2	# .. e1 :
+	stl_u	t0, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+
+	beq	a2, 1f		# e1    :
+	blbc	a2, 0f		# e1    :
+
+	stl_u	zero, 0(a0)	# e0    : zero one word
+	subl	a2, 1, a2	# .. e1 :
+	addl	a0, 8, a0	# e0    :
+	beq	a2, 1f		# .. e1 :
+
+0:	stl_u	zero, 0(a0)	# e0    : zero two words
+	subl	a2, 2, a2	# .. e1 :
+	stl_u	zero, 8(a0)	# e0    :
+	addl	a0, 16, a0	# .. e1 :
+	bne	a2, 0b		# e1    :
+	unop
+
+1:	ldl_u	t0, 0(a0)	# e0    : clear the leading bits in the final
+	subl	t10, 1, t7	# .. e1 : word
+	or	t7, t10, t7	# e0    :
+	zap	t0, t7, t0	# e1 (stall)
+	stl_u	t0, 0(a0)	# e0    :
+	ret			# .. e1 :
+
+$zerocount:
+	mov	a0, v0
+	ret
+
+	END(__stpncpy)
+
+libc_hidden_def (__stpncpy)
+weak_alias (__stpncpy, stpncpy)
diff --git a/sysdeps/sw_64/strcat.S b/sysdeps/sw_64/strcat.S
new file mode 100644
index 00000000..a6ce0abb
--- /dev/null
+++ b/sysdeps/sw_64/strcat.S
@@ -0,0 +1,71 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Append a null-terminated string from SRC to DST.  */
+
+#include <sysdep.h>
+
+	.text
+
+ENTRY(strcat)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	mov	a0, v0		# set up return value
+
+	/* Find the end of the string.  */
+
+	ldl_u   t0, 0(a0)	# load first quadword (a0 may be misaligned)
+	ldi     t1, -1(zero)
+	ins7b   t1, a0, t1
+	andnot  a0, 7, a0
+	or      t1, t0, t0
+	cmpgeb  zero, t0, t1	# t1 <- bitmask: bit i == 1 <==> i-th byte == 0
+	bne     t1, $found
+
+$loop:	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	beq     t1, $loop
+
+$found:	negl    t1, t2		# clear all but least set bit
+	and     t1, t2, t1
+
+	and     t1, 0xf0, t2	# binary search for that set bit
+	and	t1, 0xcc, t3
+	and	t1, 0xaa, t4
+	selne	t2, 4, t2, t2
+	selne	t3, 2, t3, t3
+	selne	t4, 1, t4, t4
+	addl	t2, t3, t2
+	addl	a0, t4, a0
+	addl	a0, t2, a0
+
+	/* Now do the append.  */
+
+	mov	ra, t9
+	jmp	$31, __stxcpy
+
+	END(strcat)
+libc_hidden_builtin_def (strcat)
diff --git a/sysdeps/sw_64/strchr.S b/sysdeps/sw_64/strchr.S
new file mode 100644
index 00000000..2a62b64b
--- /dev/null
+++ b/sysdeps/sw_64/strchr.S
@@ -0,0 +1,94 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@tamu.edu)
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Return the address of a given character within a null-terminated
+   string, or null if it is not found.
+
+   This is generally scheduled for the EV5 (got to look out for my own
+   interefsts :-), but with EV4 needs in mind.  There *should* be no more
+   stalls for the EV4 than there are for the EV5.
+*/
+
+#include <sysdep.h>
+
+	.set noreorder
+	.set noat
+
+ENTRY(strchr)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	zapnot	a1, 1, a1	# e0    : zero extend the search character
+	ldl_u   t0, 0(a0)	# .. e1 : load first quadword
+	sll	a1, 8, t5	# e0    : replicate the search character
+	andnot  a0, 7, v0	# .. e1 : align our loop pointer
+	or	t5, a1, a1	# e0    :
+	ldi	t4, -1		# .. e1 : build garbage mask
+	sll	a1, 16, t5	# e0    :
+	cmpgeb  zero, t0, t2	# .. e1 : bits set iff byte == zero
+	mask7b	t4, a0, t4	# e0    :
+	or	t5, a1, a1	# .. e1 :
+	sll	a1, 32, t5	# e0    :
+	cmpgeb	zero, t4, t4	# .. e1 : bits set iff byte is garbage
+	or	t5, a1, a1	# e0    :
+	xor	t0, a1, t1	# .. e1 : make bytes == c zero
+	cmpgeb  zero, t1, t3	# e0    : bits set iff byte == c
+	or	t2, t3, t0	# e1    : bits set iff char match or zero match
+	andnot	t0, t4, t0	# e0    : clear garbage bits
+	bne	t0, $found	# .. e1 (zdb)
+
+$loop:	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	beq	t0, $loop	# .. e1 (zdb)
+
+$found:	negl    t0, t1		# e0    : clear all but least set bit
+	and     t0, t1, t0	# e1 (stall)
+
+	and	t0, t3, t1	# e0    : bit set iff byte was the char
+	beq	t1, $retnull	# .. e1 (zdb)
+
+	and     t0, 0xf0, t2	# e0    : binary search for that set bit
+	and	t0, 0xcc, t3	# .. e1 :
+	and	t0, 0xaa, t4	# e0    :
+	selne	t2, 4, t2, t2	# .. e1 :
+	selne	t3, 2, t3, t3	# e0    :
+	selne	t4, 1, t4, t4	# .. e1 :
+	addl	t2, t3, t2	# e0    :
+	addl	v0, t4, v0	# .. e1 :
+	addl	v0, t2, v0	# e0    :
+	ret			# .. e1 :
+
+$retnull:
+	mov	zero, v0	# e0    :
+	ret			# .. e1 :
+
+	END(strchr)
+
+weak_alias (strchr, index)
+libc_hidden_builtin_def (strchr)
diff --git a/sysdeps/sw_64/strcmp.S b/sysdeps/sw_64/strcmp.S
new file mode 100644
index 00000000..efdc6e55
--- /dev/null
+++ b/sysdeps/sw_64/strcmp.S
@@ -0,0 +1,194 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Bytewise compare two null-terminated strings.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+	.text
+
+ENTRY(strcmp)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	jmp	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	ldl_u	t0, 0(a0)	# e0    : give cache time to catch up
+	xor	a0, a1, t2	# .. e1 : are s1 and s2 co-aligned?
+	ldl_u	t1, 0(a1)	# e0    :
+	and	t2, 7, t2	# .. e1 :
+	ldi	t3, -1		# e0    :
+	bne	t2, $unaligned	# .. e1 :
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.
+	   t3 == -1.  */
+
+$aligned:
+	mask7b	t3, a0, t3	# e0    :
+	nop			# .. e1 :
+	ornot	t1, t3, t1	# e0    :
+	ornot	t0, t3, t0	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0    : bits set iff null found
+	bne	t7, $eos	# e1 (zdb)
+
+	/* Aligned compare main loop.
+	   On entry to this basic block:
+	   t0 == an s1 word.
+	   t1 == an s2 word not containing a null.  */
+
+$a_loop:
+	xor	t0, t1, t2	# e0	:
+	bne	t2, $wordcmp	# .. e1 (zdb)
+	ldl_u	t1, 8(a1)	# e0    :
+	ldl_u	t0, 8(a0)	# .. e1 :
+	addl	a1, 8, a1	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0    :
+	beq	t7, $a_loop	# .. e1 (zdb)
+	br	$eos		# e1    :
+
+	/* The two strings are not co-aligned.  Align s1 and cope.  */
+
+$unaligned:
+	and	a0, 7, t4	# e0    : find s1 misalignment
+	and	a1, 7, t5	# .. e1 : find s2 misalignment
+	subl	a1, t4, a1	# e0    :
+
+	/* If s2 misalignment is larger than s2 misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+
+	cmplt	t4, t5, t8	# .. e1 :
+	beq	t8, $u_head	# e1    :
+
+	mask7b	t3, t5, t3	# e0    :
+	ornot	t1, t3, t3	# e0    :
+	cmpgeb	zero, t3, t7	# e1    : is there a zero?
+	beq	t7, $u_head	# e1    :
+
+	/* We've found a zero in the first partial word of s2.  Align
+	   our current s1 and s2 words and compare what we've got.  */
+
+	ext3b	t1, t5, t1	# e0    :
+	ext3b	t0, a0, t0	# e0    :
+	cmpgeb	zero, t1, t7	# .. e1 : find that zero again
+	br	$eos		# e1    : and finish up
+
+	.align 3
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full word of s2.  We can still find a zero at the end of it.
+
+	   On entry to this basic block:
+	   t0 == first word of s1
+	   t1 == first partial word of s2.  */
+
+	ldl_u	t2, 8(a1)	# e0    : load second partial s2 word
+	ldi	t3, -1		# .. e1 : create leading garbage mask
+	ext3b	t1, a1, t1	# e0    : create first s2 word
+	mask7b	t3, a0, t3	# e0    :
+	ext7b	t2, a1, t4	# e0    :
+	ornot	t0, t3, t0	# .. e1 : kill s1 garbage
+	or	t1, t4, t1	# e0    : s2 word now complete
+	cmpgeb	zero, t0, t7	# .. e1 : find zero in first s1 word
+	ornot	t1, t3, t1	# e0    : kill s2 garbage
+	ldi	t3, -1		# .. e1 :
+	mask3b	t3, a1, t3	# e0    : mask for s2[1] bits we have seen
+	bne	t7, $eos	# .. e1 :
+	xor	t0, t1, t4	# e0    : compare aligned words
+	bne	t4, $wordcmp	# .. e1 (zdb)
+	or	t2, t3, t3	# e0    :
+	cmpgeb	zero, t3, t7	# e1    :
+	bne	t7, $u_final	# e1    :
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned words from s2.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t2 == the unshifted low-bits from the next s2 word.  */
+
+	.align 3
+$u_loop:
+	ext3b	t2, a1, t3	# e0    :
+	ldl_u	t2, 16(a1)	# .. e1 : load next s2 high bits
+	ldl_u	t0, 8(a0)	# e0    : load next s1 word
+	addl	a1, 8, a1	# .. e1 :
+	addl	a0, 8, a0	# e0    :
+	nop			# .. e1 :
+	ext7b	t2, a1, t1	# e0    :
+	cmpgeb	zero, t0, t7	# .. e1 : find zero in current s1 word
+	or	t1, t3, t1	# e0    :
+	bne	t7, $eos	# .. e1 :
+	xor	t0, t1, t4	# e0    : compare the words
+	bne	t4, $wordcmp	# .. e1 (zdb)
+	cmpgeb	zero, t2, t4	# e0    : find zero in next low bits
+	beq	t4, $u_loop	# .. e1 (zdb)
+
+	/* We've found a zero in the low bits of the last s2 word.  Get
+	   the next s1 word and align them.  */
+$u_final:
+	ldl_u	t0, 8(a0)	# e1    :
+	ext3b	t2, a1, t1	# .. e0 :
+	cmpgeb	zero, t1, t7	# e0    :
+
+	/* We've found a zero somewhere in a word we just read.
+	   On entry to this basic block:
+	   t0 == s1 word
+	   t1 == s2 word
+	   t7 == cmpgeb mask containing the zero.  */
+
+	.align 3
+$eos:
+	negl	t7, t6		# e0    : create bytemask of valid data
+	and	t6, t7, t8	# e1    :
+	subl	t8, 1, t6	# e0    :
+	or	t6, t8, t7	# e1    :
+	zapnot	t0, t7, t0	# e0    : kill the garbage
+	zapnot	t1, t7, t1	# .. e1 :
+	xor	t0, t1, v0	# e0    : and compare
+	beq	v0, $done	# .. e1 :
+
+	/* Here we have two differing co-aligned words in t0 & t1.
+	   Bytewise compare them and return (t0 > t1 ? 1 : -1).  */
+$wordcmp:
+	cmpgeb	t0, t1, t2	# e0    : comparison yieflds bit mask of ge
+	cmpgeb	t1, t0, t3	# .. e1 :
+	xor	t2, t3, t0	# e0    : bits set iff t0/t1 bytes differ
+	negl	t0, t1		# e1    : clear all but least bit
+	and	t0, t1, t0	# e0    :
+	ldi	v0, -1		# .. e1 :
+	and	t0, t2, t1	# e0    : was bit set in t0 > t1?
+	selne	t1, 1, v0, v0	# .. e1 (zdb)
+
+$done:
+	ret			# e1    :
+
+	END(strcmp)
+libc_hidden_builtin_def (strcmp)
diff --git a/sysdeps/sw_64/strcpy.S b/sysdeps/sw_64/strcpy.S
new file mode 100644
index 00000000..803f303c
--- /dev/null
+++ b/sysdeps/sw_64/strcpy.S
@@ -0,0 +1,41 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy a null-terminated string from SRC to DST.  Return a pointer
+   to the null-terminator in the source.  */
+
+#include <sysdep.h>
+
+	.text
+
+ENTRY(strcpy)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	mov	a0, v0		# set up return value
+	mov	ra, t9
+	jmp	$31, __stxcpy	# do the copy
+
+	END(strcpy)
+libc_hidden_builtin_def (strcpy)
diff --git a/sysdeps/sw_64/strlen.S b/sysdeps/sw_64/strlen.S
new file mode 100644
index 00000000..2551fd80
--- /dev/null
+++ b/sysdeps/sw_64/strlen.S
@@ -0,0 +1,76 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by David Mosberger (davidm@cs.arizona.edu).
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Finds length of a 0-terminated string.  Optimized for the Sw_64
+   architecture:
+
+      - memory accessed as aligned quadwords only
+      - uses cmpgeb to compare 8 bytes in parallel
+      - does binary search to find 0 byte in last quadword (HAKMEM
+	needed 12 instructions to do this instead of the 8 instructions
+	that the binary search needs).
+*/
+
+#include <sysdep.h>
+
+	.set noreorder
+	.set noat
+
+ENTRY(strlen)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	ldl_u   t0, 0(a0)	# load first quadword (a0 may be misaligned)
+	ldi     t1, -1(zero)
+	ins7b   t1, a0, t1
+	andnot  a0, 7, v0
+	or      t1, t0, t0
+	nop			# dual issue the next two on ev5
+	cmpgeb  zero, t0, t1	# t1 <- bitmask: bit i == 1 <==> i-th byte == 0
+	bne     t1, $found
+
+$loop:	ldl     t0, 8(v0)
+	addl    v0, 8, v0	# addr += 8
+	cmpgeb  zero, t0, t1
+	beq     t1, $loop
+
+$found:	negl    t1, t2		# clear all but least set bit
+	and     t1, t2, t1
+
+	and     t1, 0xf0, t2	# binary search for that set bit
+	and	t1, 0xcc, t3
+	and	t1, 0xaa, t4
+	selne	t2, 4, t2, t2
+	selne	t3, 2, t3, t3
+	selne	t4, 1, t4, t4
+	addl	t2, t3, t2
+	addl	v0, t4, v0
+	addl	v0, t2, v0
+	nop			# dual issue next two on ev4 and ev5
+
+	subl    v0, a0, v0
+	ret
+
+	END(strlen)
+libc_hidden_builtin_def (strlen)
diff --git a/sysdeps/sw_64/strncat.S b/sysdeps/sw_64/strncat.S
new file mode 100644
index 00000000..56c07d85
--- /dev/null
+++ b/sysdeps/sw_64/strncat.S
@@ -0,0 +1,94 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Append no more than COUNT characters from the null-terminated string SRC
+   to the null-terminated string DST.  Always null-terminate the new DST.  */
+
+#include <sysdep.h>
+
+	.text
+
+ENTRY(strncat)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	mov	a0, v0		# set up return value
+	beq	a2, $zerocount
+
+	/* Find the end of the string.  */
+
+	ldl_u   t0, 0(a0)	# load first quadword (a0 may be misaligned)
+	ldi     t1, -1(zero)
+	ins7b   t1, a0, t1
+	andnot  a0, 7, a0
+	or      t1, t0, t0
+	cmpgeb  zero, t0, t1	# t1 <- bitmask: bit i == 1 <==> i-th byte == 0
+	bne     t1, $found
+
+$loop:	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	beq     t1, $loop
+
+$found:	negl    t1, t2		# clear all but least set bit
+	and     t1, t2, t1
+
+	and     t1, 0xf0, t2	# binary search for that set bit
+	and	t1, 0xcc, t3
+	and	t1, 0xaa, t4
+	selne	t2, 4, t2, t2
+	selne	t3, 2, t3, t3
+	selne	t4, 1, t4, t4
+	addl	t2, t3, t2
+	addl	a0, t4, a0
+	addl	a0, t2, a0
+
+	/* Now do the append.  */
+
+	call	t9, __stxncpy
+
+	/* Worry about the null termination.  */
+
+	zapnot	t0, t8, t1	# was last byte a null?
+	bne	t1, 0f
+	ret
+
+0:	and	t10, 0x80, t1
+	bne	t1, 1f
+
+	/* Here there are bytes left in the current word.  Clear one.  */
+	addl	t10, t10, t10	# end-of-count bit <<= 1
+	zap	t0, t10, t0
+	stl_u	t0, 0(a0)
+	ret
+
+1:	/* Here we must read the next DST word and clear the first byte.  */
+	ldl_u	t0, 8(a0)
+	zap	t0, 1, t0
+	stl_u	t0, 8(a0)
+
+$zerocount:
+	ret
+
+	END(strncat)
diff --git a/sysdeps/sw_64/strncmp.S b/sysdeps/sw_64/strncmp.S
new file mode 100644
index 00000000..4cc499a2
--- /dev/null
+++ b/sysdeps/sw_64/strncmp.S
@@ -0,0 +1,277 @@
+/* Copyright (C) 1996-2020 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Bytewise compare two null-terminated strings of length no longer than N.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+/* EV6 only predicts one branch per octaword.  We'll use these to push
+   fsubsequent branches back to the next bundle.  This will generally add
+   a fetch+decode cycle to older machines, so skip in that case.  */
+#ifdef __sw_64_fix__
+# define sw6_unop	unop
+#else
+# define sw6_unop
+#endif
+
+	.text
+
+ENTRY(strncmp)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	xor	a0, a1, t2	# are s1 and s2 co-aligned?
+	beq	a2, $zerolength
+	ldl_u	t0, 0(a0)	# load asap to give cache time to catch up
+	ldl_u	t1, 0(a1)
+	ldi	t3, -1
+	and	t2, 7, t2
+	srl	t3, 1, t6
+	and	a0, 7, t4	# find s1 misalignment
+	and	a1, 7, t5	# find s2 misalignment
+	sellt	a2, t6, a2, a2	# bound neg count to LONG_MAX
+	addl	a1, a2, a3	# s2+count
+	addl	a2, t4, a2	# bias count by s1 misalignment
+	and	a2, 7, t10	# ofs of last byte in s1 last word
+	srl	a2, 3, a2	# remaining full words in s1 count
+	bne	t2, $unaligned
+
+	/* On entry to this basic block:
+	   t0 == the first word of s1.
+	   t1 == the first word of s2.
+	   t3 == -1.  */
+$aligned:
+	mask7b	t3, a1, t8	# mask off leading garbage
+	ornot	t1, t8, t1
+	ornot	t0, t8, t0
+	cmpgeb	zero, t1, t7	# bits set iff null found
+	beq	a2, $eoc	# check end of count
+	bne	t7, $eos
+	beq	t10, $ant_loop
+
+	/* Aligned compare main loop.
+	   On entry to this basic block:
+	   t0 == an s1 word.
+	   t1 == an s2 word not containing a null.  */
+
+	.align 4
+$a_loop:
+	xor	t0, t1, t2	# e0	:
+	bne	t2, $wordcmp	# .. e1 (zdb)
+	ldl_u	t1, 8(a1)	# e0    :
+	ldl_u	t0, 8(a0)	# .. e1 :
+
+	subl	a2, 1, a2	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	addl	a0, 8, a0	# e0    :
+	beq	a2, $eoc	# .. e1 :
+
+	cmpgeb	zero, t1, t7	# e0    :
+	beq	t7, $a_loop	# .. e1 :
+
+	br	$eos
+
+	/* Alternate aligned compare loop, for when there's no trailing
+	   bytes on the count.  We have to avoid reading too much data.  */
+	.align 4
+$ant_loop:
+	xor	t0, t1, t2	# e0	:
+	sw6_unop
+	sw6_unop
+	bne	t2, $wordcmp	# .. e1 (zdb)
+
+	subl	a2, 1, a2	# e0    :
+	beq	a2, $zerolength	# .. e1 :
+	ldl_u	t1, 8(a1)	# e0    :
+	ldl_u	t0, 8(a0)	# .. e1 :
+
+	addl	a1, 8, a1	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0    :
+	beq	t7, $ant_loop	# .. e1 :
+
+	br	$eos
+
+	/* The two strings are not co-aligned.  Align s1 and cope.  */
+	/* On entry to this basic block:
+	   t0 == the first word of s1.
+	   t1 == the first word of s2.
+	   t3 == -1.
+	   t4 == misalignment of s1.
+	   t5 == misalignment of s2.
+	  t10 == misalignment of s1 end.  */
+	.align	4
+$unaligned:
+	/* If s1 misalignment is larger than s2 misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+	subl	a1, t4, a1	# adjust s2 for s1 misalignment
+	cmpult	t4, t5, t9
+	subl	a3, 1, a3	# last byte of s2
+	bic	a1, 7, t8
+	mask7b	t3, t5, t7	# mask garbage in s2
+	subl	a3, t8, a3
+	ornot	t1, t7, t7
+	srl	a3, 3, a3	# remaining full words in s2 count
+	beq	t9, $u_head
+
+	/* Failing that, we need to look for both eos and eoc within the
+	   first word of s2.  If we find either, we can continue by
+	   pretending that the next word of s2 is all zeros.  */
+	ldi	t2, 0		# next = zero
+	cmpeq	a3, 0, t8	# eoc in the first word of s2?
+	cmpgeb	zero, t7, t7	# eos in the first word of s2?
+	or	t7, t8, t8
+	bne	t8, $u_head_nl
+
+	/* We know just enough now to be able to assemble the first
+	   full word of s2.  We can still find a zero at the end of it.
+
+	   On entry to this basic block:
+	   t0 == first word of s1
+	   t1 == first partial word of s2.
+	   t3 == -1.
+	   t10 == ofs of last byte in s1 last word.
+	   t11 == ofs of last byte in s2 last word.  */
+$u_head:
+	ldl_u	t2, 8(a1)	# load second partial s2 word
+	subl	a3, 1, a3
+$u_head_nl:
+	ext3b	t1, a1, t1	# create first s2 word
+	mask7b	t3, a0, t8
+	ext7b	t2, a1, t4
+	ornot	t0, t8, t0	# kill s1 garbage
+	or	t1, t4, t1	# s2 word now complete
+	cmpgeb	zero, t0, t7	# find eos in first s1 word
+	ornot	t1, t8, t1	# kill s2 garbage
+	beq	a2, $eoc
+	subl	a2, 1, a2
+	bne	t7, $eos
+	mask3b	t3, a1, t8	# mask out s2[1] bits we have seen
+	xor	t0, t1, t4	# compare aligned words
+	or	t2, t8, t8
+	bne	t4, $wordcmp
+	cmpgeb	zero, t8, t7	# eos in high bits of s2[1]?
+	cmpeq	a3, 0, t8	# eoc in s2[1]?
+	or	t7, t8, t7
+	bne	t7, $u_final
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned words from s2.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t2 == the unshifted low-bits from the next s2 word.
+	   t10 == ofs of last byte in s1 last word.
+	   t11 == ofs of last byte in s2 last word.  */
+	.align 4
+$u_loop:
+	ext3b	t2, a1, t3	# e0    :
+	ldl_u	t2, 16(a1)	# .. e1 : load next s2 high bits
+	ldl_u	t0, 8(a0)	# e0    : load next s1 word
+	addl	a1, 8, a1	# .. e1 :
+
+	addl	a0, 8, a0	# e0    :
+	subl	a3, 1, a3	# .. e1 :
+	ext7b	t2, a1, t1	# e0    :
+	cmpgeb	zero, t0, t7	# .. e1 : eos in current s1 word
+
+	or	t1, t3, t1	# e0    :
+	beq	a2, $eoc	# .. e1 : eoc in current s1 word
+	subl	a2, 1, a2	# e0    :
+	cmpgeb	zero, t2, t4	# .. e1 : eos in s2[1]
+
+	xor	t0, t1, t3	# e0    : compare the words
+	sw6_unop
+	sw6_unop
+	bne	t7, $eos	# .. e1 :
+
+	cmpeq	a3, 0, t5	# e0    : eoc in s2[1]
+	sw6_unop
+	sw6_unop
+	bne	t3, $wordcmp	# .. e1 :
+
+	or	t4, t5, t4	# e0    : eos or eoc in s2[1].
+	beq	t4, $u_loop	# .. e1 (zdb)
+
+	/* We've found a zero in the low bits of the last s2 word.  Get
+	   the next s1 word and align them.  */
+	.align 3
+$u_final:
+	ldl_u	t0, 8(a0)
+	ext3b	t2, a1, t1
+	cmpgeb	zero, t1, t7
+	bne	a2, $eos
+
+	/* We've hit end of count.  Zero everything after the count
+	   and compare whats left.  */
+	.align 3
+$eoc:
+	mask3b	t0, t10, t0
+	mask3b	t1, t10, t1
+	cmpgeb	zero, t1, t7
+
+	/* We've found a zero somewhere in a word we just read.
+	   On entry to this basic block:
+	   t0 == s1 word
+	   t1 == s2 word
+	   t7 == cmpgeb mask containing the zero.  */
+	.align 3
+$eos:
+	negl	t7, t6		# create bytemask of valid data
+	and	t6, t7, t8
+	subl	t8, 1, t6
+	or	t6, t8, t7
+	zapnot	t0, t7, t0	# kill the garbage
+	zapnot	t1, t7, t1
+	xor	t0, t1, v0	# ... and compare
+	beq	v0, $done
+
+	/* Here we have two differing co-aligned words in t0 & t1.
+	   Bytewise compare them and return (t0 > t1 ? 1 : -1).  */
+	.align 3
+$wordcmp:
+	cmpgeb	t0, t1, t2	# comparison yieflds bit mask of ge
+	cmpgeb	t1, t0, t3
+	xor	t2, t3, t0	# bits set iff t0/t1 bytes differ
+	negl	t0, t1		# clear all but least bit
+	and	t0, t1, t0
+	ldi	v0, -1
+	and	t0, t2, t1	# was bit set in t0 > t1?
+	selne	t1, 1, v0, v0
+$done:
+	ret
+
+	.align 3
+$zerolength:
+	clr	v0
+	ret
+
+	END(strncmp)
+libc_hidden_builtin_def (strncmp)
diff --git a/sysdeps/sw_64/strncpy.S b/sysdeps/sw_64/strncpy.S
new file mode 100644
index 00000000..8aa5a5e6
--- /dev/null
+++ b/sysdeps/sw_64/strncpy.S
@@ -0,0 +1,87 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy no more than COUNT bytes of the null-terminated string from
+   SRC to DST.  If SRC does not cover all of COUNT, the balance is
+   zeroed.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+	.text
+
+ENTRY(strncpy)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+#endif
+	.prologue 1
+
+	mov	a0, v0		# set return value now
+	beq	a2, $zerocount
+	call	t9, __stxncpy	# do the work of the copy
+
+	bne	a2, $multiword	# do we have full words left?
+
+	.align 3
+	subl	t8, 1, t2	# e0    : guess not
+	subl	t10, 1, t3	# .. e1 :
+	or	t2, t8, t2	# e0    : clear the bits between the last
+	or	t3, t10, t3	# .. e1 : written byte and the last byte in
+	andnot	t3, t2, t3	# e0    : COUNT
+	zap	t0, t3, t0	# e1    :
+	stl_u	t0, 0(a0)	# e0    :
+	ret			# .. e1 :
+
+$multiword:
+	subl	t8, 1, t7	# e0    : clear the final bits in the prev
+	or	t7, t8, t7	# e1    : word
+	zapnot	t0, t7, t0	# e0    :
+	subl	a2, 1, a2	# .. e1 :
+	stl_u	t0, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+
+	beq	a2, 1f		# e1    :
+	blbc	a2, 0f		# e1    :
+
+	stl_u	zero, 0(a0)	# e0    : zero one word
+	subl	a2, 1, a2	# .. e1 :
+	addl	a0, 8, a0	# e0    :
+	beq	a2, 1f		# .. e1 :
+
+0:	stl_u	zero, 0(a0)	# e0    : zero two words
+	subl	a2, 2, a2	# .. e1 :
+	stl_u	zero, 8(a0)	# e0    :
+	addl	a0, 16, a0	# .. e1 :
+	bne	a2, 0b		# e1    :
+	unop
+
+1:	ldl_u	t0, 0(a0)	# e0    : clear the leading bits in the final
+	subl	t10, 1, t7	# .. e1 : word
+	or	t7, t10, t7	# e0    :
+	zap	t0, t7, t0	# e1 (stall)
+	stl_u	t0, 0(a0)	# e0    :
+
+$zerocount:
+	ret			# .. e1 :
+
+	END(strncpy)
+libc_hidden_builtin_def (strncpy)
diff --git a/sysdeps/sw_64/strrchr.S b/sysdeps/sw_64/strrchr.S
new file mode 100644
index 00000000..66253466
--- /dev/null
+++ b/sysdeps/sw_64/strrchr.S
@@ -0,0 +1,110 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Return the address of the last occurrence of a given character
+   within a null-terminated string, or null if it is not found.
+
+   This is generally scheduled for the EV5 (got to look out for my own
+   interefsts :-), but with EV4 needs in mind.  There are, in fact, fewer
+   stalls on the EV4 than there are on the EV5.
+*/
+
+#include <sysdep.h>
+
+	.set noreorder
+	.set noat
+
+ENTRY(strrchr)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	and	a1, 0xff, a1	# e0    : zero extend our test character
+	mov	zero, t6	# .. e1 : t6 is last match aligned addr
+	sll	a1, 8, t5	# e0    : replicate our test character
+	mov	zero, t7	# .. e1 : t7 is last match byte compare mask
+	or	t5, a1, a1	# e0    :
+	ldl_u   t0, 0(a0)	# .. e1 : load first quadword
+	sll	a1, 16, t5	# e0    :
+	andnot  a0, 7, v0	# .. e1 : align source addr
+	or	t5, a1, a1	# e0    :
+	ldi	t4, -1		# .. e1 : build garbage mask
+	sll	a1, 32, t5	# e0    :
+	cmpgeb  zero, t0, t1	# .. e1 : bits set iff byte == zero
+	mask7b	t4, a0, t4	# e0    :
+	or	t5, a1, a1	# .. e1 : character replication complete
+	xor	t0, a1, t2	# e0    : make bytes == c zero
+	cmpgeb	zero, t4, t4	# .. e1 : bits set iff byte is garbage
+	cmpgeb  zero, t2, t3	# e0    : bits set iff byte == c
+	andnot	t1, t4, t1	# .. e1 : clear garbage from null test
+	andnot	t3, t4, t3	# e0    : clear garbage from char test
+	bne	t1, $eos	# .. e1 : did we already hit the terminator?
+
+	/* Character search main loop */
+$loop:
+	ldl	t0, 8(v0)	# e0    : load next quadword
+	selne	t3, v0, t6, t6	# .. e1 : save previous comparisons match
+	selne	t3, t3, t7, t7	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	xor	t0, a1, t2	# e0    :
+	cmpgeb	zero, t0, t1	# .. e1 : bits set iff byte == zero
+	cmpgeb	zero, t2, t3	# e0    : bits set iff byte == c
+	beq	t1, $loop	# .. e1 : if we havnt seen a null, loop
+
+	/* Mask out character matches after terminator */
+$eos:
+	negl	t1, t4		# e0    : isolate first null byte match
+	and	t1, t4, t4	# e1    :
+	subl	t4, 1, t5	# e0    : build a mask of the bytes upto...
+	or	t4, t5, t4	# e1    : ... and including the null
+
+	and	t3, t4, t3	# e0    : mask out char matches after null
+	selne	t3, t3, t7, t7	# .. e1 : save it, if match found
+	selne	t3, v0, t6, t6	# e0    :
+
+	/* Locate the address of the last matched character */
+
+	/* Retain the early exit for the ev4 -- the ev5 mispredict penalty
+	   is 5 cycles -- the same as just falling through.  */
+	beq	t7, $retnull	# .. e1 :
+
+	and	t7, 0xf0, t2	# e0    : binary search for the high bit set
+	selne	t2, t2, t7, t7	# .. e1 (zdb)
+	selne	t2, 4, t2, t2	# e0    :
+	and	t7, 0xcc, t1	# .. e1 :
+	selne	t1, t1, t7, t7	# e0    :
+	selne	t1, 2, t1, t1	# .. e1 :
+	and	t7, 0xaa, t0	# e0    :
+	selne	t0, 1, t0, t0	# .. e1 (zdb)
+	addl	t2, t1, t1	# e0    :
+	addl	t6, t0, v0	# .. e1 : add our aligned base ptr to the mix
+	addl	v0, t1, v0	# e0    :
+	ret			# .. e1 :
+
+$retnull:
+	mov	zero, v0	# e0    :
+	ret			# .. e1 :
+
+	END(strrchr)
+
+weak_alias (strrchr, rindex)
+libc_hidden_builtin_def (strrchr)
diff --git a/sysdeps/sw_64/stxcpy.S b/sysdeps/sw_64/stxcpy.S
new file mode 100644
index 00000000..942f1fd2
--- /dev/null
+++ b/sysdeps/sw_64/stxcpy.S
@@ -0,0 +1,294 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy a null-terminated string from SRC to DST.
+
+   This is an internal routine used by strcpy, stpcpy, and strcat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+
+   On output:
+	t8  = bitmask (with one bit set) indicating the last byte written
+	a0  = unaligned address of the last *word* written
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+/* This is generally scheduled for the EV5, but should still be pretty
+   good for the EV4 too.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxcpy, @function
+	.globl	__stxcpy
+	.usepv	__stxcpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 3
+stxcpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# e1    : build a mask against false zero
+	mask7b	t2, a1, t2	# e0    :   detection in the src word
+	mask7b	t1, a1, t3	# e0    :
+	ornot	t1, t2, t2	# .. e1 :
+	mask3b	t0, a1, t0	# e0    : assemble the first output word
+	cmpgeb	zero, t2, t7	# .. e1 : bits set iff null found
+	or	t0, t3, t1	# e0    :
+	bne	t7, $a_eos	# .. e1 :
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == a source word not containing a null.  */
+$a_loop:
+	stl_u	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl_u	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	beq	t7, $a_loop	# .. e1 (zdb)
+
+	/* Take care of the final (partial) word store.
+	   On entry to this basic block we have:
+	   t1 == the source word containing the null
+	   t7 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t7, t6		# e0    : find low bit set
+	and	t7, t6, t8	# e1 (stall)
+
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# e0    :
+	bne	t6, 1f		# .. e1 (zdb)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t0, 0(a0)	# e0    :
+	subl	t8, 1, t6	# .. e1 :
+	zapnot	t1, t6, t1	# e0    : clear src bytes >= null
+	or	t8, t6, t7	# .. e1 :
+	zap	t0, t7, t0	# e0    : clear dst bytes <= null
+	or	t0, t1, t1	# e1    :
+
+1:	stl_u	t1, 0(a0)	# e0    :
+	ret	(t9)		# .. e1 :
+
+	.align 3
+__stxcpy:
+	/* Are source and destination co-aligned?  */
+	xor	a0, a1, t0	# e0    :
+	unop			#       :
+	and	t0, 7, t0	# e0    :
+	bne	t0, $unaligned	# .. e1 :
+
+	/* We are co-aligned; take care of a partial first word.  */
+	ldl_u	t1, 0(a1)	# e0    : load first src word
+	and	a0, 7, t0	# .. e1 : take care not to load a word ...
+	addl	a1, 8, a1		# e0    :
+	beq	t0, stxcpy_aligned	# .. e1 : ... if we wont need it
+	ldl_u	t0, 0(a0)	# e0    :
+	br	stxcpy_aligned	# .. e1 :
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 3
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, for masking back in, if needed else 0
+	   t1 == the low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+
+	ext3b	t1, a1, t1	# e0    :
+	ext7b	t2, a1, t4	# e0    :
+	mask3b	t0, a0, t0	# e0    :
+	or	t1, t4, t1	# .. e1 :
+	mask7b	t1, a0, t1	# e0    :
+	or	t0, t1, t1	# e1    :
+
+	or	t1, t6, t6	# e0    :
+	cmpgeb	zero, t6, t7	# .. e1 :
+	ldi	t6, -1		# e0    : for masking just below
+	bne	t7, $u_final	# .. e1 :
+
+	mask3b	t6, a1, t6		# e0    : mask out the bits we have
+	or	t6, t2, t2		# e1    :   already extracted before
+	cmpgeb	zero, t2, t7		# e0    :   testing eos
+	bne	t7, $u_late_head_exit	# .. e1 (zdb)
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+
+	stl_u	t1, 0(a0)	# e0    : store first output word
+	addl	a0, 8, a0	# .. e1 :
+	ext3b	t2, a1, t0	# e0    : position ho-bits of lo word
+	ldl_u	t2, 8(a1)	# .. e1 : read next high-order source word
+	addl	a1, 8, a1	# e0    :
+	cmpgeb	zero, t2, t7	# .. e1 :
+	nop			# e0    :
+	bne	t7, $u_eos	# .. e1 :
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 3
+$u_loop:
+	ext7b	t2, a1, t1	# e0    : extract high bits for current word
+	addl	a1, 8, a1	# .. e1 :
+	ext3b	t2, a1, t3	# e0    : extract low bits for next time
+	addl	a0, 8, a0	# .. e1 :
+	or	t0, t1, t1	# e0    : current dst word now complete
+	ldl_u	t2, 0(a1)	# .. e1 : load high word for next time
+	stl_u	t1, -8(a0)	# e0    : save the current word
+	mov	t3, t0		# .. e1 :
+	cmpgeb	zero, t2, t7	# e0    : test new word for eos
+	beq	t7, $u_loop	# .. e1 :
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	ext7b	t2, a1, t1	# e0    :
+	or	t0, t1, t1	# e1    : first (partial) source word complete
+
+	cmpgeb	zero, t1, t7	# e0    : is the null in this first bit?
+	bne	t7, $u_final	# .. e1 (zdb)
+
+$u_late_head_exit:
+	stl_u	t1, 0(a0)	# e0    : the null was in the high-order bits
+	addl	a0, 8, a0	# .. e1 :
+	ext3b	t2, a1, t1	# e0    :
+	cmpgeb	zero, t1, t7	# .. e1 :
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t1 == assembled source word
+	   t7 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t7, t6		# e0    : isolate low bit set
+	and	t6, t7, t8	# e1    :
+
+	and	t8, 0x80, t6	# e0    : avoid dest word load if we can
+	bne	t6, 1f		# .. e1 (zdb)
+
+	ldl_u	t0, 0(a0)	# e0    :
+	subl	t8, 1, t6	# .. e1 :
+	or	t6, t8, t7	# e0    :
+	zapnot	t1, t6, t1	# .. e1 : kill source bytes >= null
+	zap	t0, t7, t0	# e0    : kill dest bytes <= null
+	or	t0, t1, t1	# e1    :
+
+1:	stl_u	t1, 0(a0)	# e0    :
+	ret	(t9)		# .. e1 :
+
+	/* Unaligned copy entry point.  */
+	.align 3
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# e0    : load first source word
+
+	and	a0, 7, t4	# .. e1 : find dest misalignment
+	and	a1, 7, t5	# e0    : find src misalignment
+
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+
+	mov	zero, t0	# .. e1 :
+	mov	zero, t6	# e0    :
+	beq	t4, 1f		# .. e1 :
+	ldl_u	t0, 0(a0)	# e0    :
+	ldi	t6, -1		# .. e1 :
+	mask3b	t6, a0, t6	# e0    :
+1:
+	subl	a1, t4, a1	# .. e1 : sub dest misalignment from src addr
+
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+
+	cmplt	t4, t5, t8	# e0    :
+	beq	t8, $u_head	# .. e1 (zdb)
+
+	ldi	t2, -1		# e1    : mask out leading garbage in source
+	mask7b	t2, t5, t2	# e0    :
+	nop			# e0    :
+	ornot	t1, t2, t3	# .. e1 :
+	cmpgeb	zero, t3, t7	# e0    : is there a zero?
+	beq	t7, $u_head	# .. e1 (zdb)
+
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+
+	ldl_u	t0, 0(a0)	# e0    :
+
+	negl	t7, t6		# .. e1 : build bitmask of bytes <= zero
+	and	t6, t7, t8	# e0    :
+	and	a1, 7, t5	# .. e1 :
+	subl	t8, 1, t6	# e0    :
+	or	t6, t8, t7	# e1    :
+	srl	t8, t5, t8	# e0    : adjust final null return value
+
+	zapnot	t2, t7, t2	# .. e1 : prepare source word; mirror changes
+	and	t1, t2, t1	# e1    : to source validity mask
+	ext3b	t2, a1, t2	# .. e0 :
+	ext3b	t1, a1, t1	# e0    :
+
+	andnot	t0, t2, t0	# .. e1 : zero place for source to reside
+	or	t0, t1, t1	# e1    : and put it there
+	stl_u	t1, 0(a0)	# .. e0 :
+	ret	(t9)
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/stxncpy.S b/sysdeps/sw_64/stxncpy.S
new file mode 100644
index 00000000..cc45a215
--- /dev/null
+++ b/sysdeps/sw_64/stxncpy.S
@@ -0,0 +1,352 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy no more than COUNT bytes of the null-terminated string from
+   SRC to DST.
+
+   This is an internal routine used by strncpy, stpncpy, and strncat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+	a2 = COUNT
+
+   Furthermore, COUNT may not be zero.
+
+   On output:
+	t0  = last word written
+	t8  = bitmask (with one bit set) indicating the last byte written
+	t10 = bitmask (with one bit set) indicating the byte position of
+	      the end of the range specified by COUNT
+	a0  = unaligned address of the last *word* written
+	a2  = the number of full words left in COUNT
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+
+/* This is generally scheduled for the EV5, but should still be pretty
+   good for the EV4 too.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxncpy, @function
+	.globl	__stxncpy
+	.usepv	__stxncpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 3
+stxncpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# e1    : build a mask against false zero
+	mask7b	t2, a1, t2	# e0    :   detection in the src word
+	mask7b	t1, a1, t3	# e0    :
+	ornot	t1, t2, t2	# .. e1 :
+	mask3b	t0, a1, t0	# e0    : assemble the first output word
+	cmpgeb	zero, t2, t7	# .. e1 : bits set iff null found
+	or	t0, t3, t0	# e0    :
+	beq	a2, $a_eoc	# .. e1 :
+	bne	t7, $a_eos	# .. e1 :
+
+	/* On entry to this basic block:
+	   t0 == a source word not containing a null.  */
+$a_loop:
+	stl_u	t0, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl_u	t0, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	subl	a2, 1, a2	# e0    :
+	cmpgeb	zero, t0, t7	# .. e1 (stall)
+	beq	a2, $a_eoc      # e1    :
+	beq	t7, $a_loop	# e1    :
+
+	/* Take care of the final (partial) word store.  At this point
+	   the end-of-count bit is set in t7 iff it applies.
+
+	   On entry to this basic block we have:
+	   t0 == the source word containing the null
+	   t7 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t7, t8		# e0    : find low bit set
+	and	t7, t8, t8	# e1 (stall)
+
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# e0    :
+	bne	t6, 1f		# .. e1 (zdb)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t1, 0(a0)	# e0    :
+	subl	t8, 1, t6	# .. e1 :
+	or	t8, t6, t7	# e0    :
+	unop			#
+	zapnot	t0, t7, t0	# e0    : clear src bytes > null
+	zap	t1, t7, t1	# .. e1 : clear dst bytes <= null
+	or	t0, t1, t0	# e1    :
+
+1:	stl_u	t0, 0(a0)	# e0    :
+	ret	(t9)		# e1    :
+
+	/* Add the end-of-count bit to the eos detection bitmask.  */
+$a_eoc:
+	or	t10, t7, t7
+	br	$a_eos
+
+	.align 3
+__stxncpy:
+	/* Are source and destination co-aligned?  */
+	ldi	t2, -1
+	xor	a0, a1, t1
+	srl	t2, 1, t2
+	and	a0, 7, t0		# find dest misalignment
+	sellt	a2, t2, a2, a2		# bound neg count to LONG_MAX
+	and	t1, 7, t1
+	addl	a2, t0, a2		# bias count by dest misalignment
+	subl	a2, 1, a2
+	and	a2, 7, t2
+	srl	a2, 3, a2		# a2 = loop counter = (count - 1)/8
+	addl	zero, 1, t10
+	sll	t10, t2, t10		# t10 = bitmask of last count byte
+	bne	t1, $unaligned
+
+	/* We are co-aligned; take care of a partial first word.  */
+
+	ldl_u	t1, 0(a1)	# e0    : load first src word
+	addl	a1, 8, a1	# .. e1 :
+
+	beq	t0, stxncpy_aligned     # avoid loading dest word if not needed
+	ldl_u	t0, 0(a0)	# e0    :
+	br	stxncpy_aligned	# .. e1 :
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 3
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, unmasked
+	   t1 == the shifted low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# e0    : load second src word
+	addl	a1, 8, a1	# .. e1 :
+	mask3b	t0, a0, t0	# e0    : mask trailing garbage in dst
+	ext7b	t2, a1, t4	# e0    :
+	or	t1, t4, t1	# e1    : first aligned src word complete
+	mask7b	t1, a0, t1	# e0    : mask leading garbage in src
+	or	t0, t1, t0	# e0    : first output word complete
+	or	t0, t6, t6	# e1    : mask original data for zero test
+	cmpgeb	zero, t6, t7	# e0    :
+	beq	a2, $u_eocfin	# .. e1 :
+	ldi	t6, -1		# e0    :
+	bne	t7, $u_final	# .. e1 :
+
+	mask3b	t6, a1, t6		# e0    : mask out bits already seen
+	nop				# .. e1 :
+	stl_u	t0, 0(a0)		# e0    : store first output word
+	or      t6, t2, t2		# .. e1 :
+	cmpgeb	zero, t2, t7		# e0    : find nulls in second partial
+	addl	a0, 8, a0		# .. e1 :
+	subl	a2, 1, a2		# e0    :
+	bne	t7, $u_late_head_exit	# .. e1 :
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+
+	ext3b	t2, a1, t1	# e0    : position hi-bits of lo word
+	beq	a2, $u_eoc	# .. e1 :
+	ldl_u	t2, 8(a1)	# e0    : read next high-order source word
+	addl	a1, 8, a1	# .. e1 :
+	ext7b	t2, a1, t0	# e0    : position lo-bits of hi word
+	cmpgeb	zero, t2, t7	# .. e1 : test new word for eos
+	nop			# e0    :
+	bne	t7, $u_eos	# .. e1 :
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 3
+$u_loop:
+	or	t0, t1, t0	# e0    : current dst word now complete
+	subl	a2, 1, a2	# .. e1 : decrement word count
+	stl_u	t0, 0(a0)	# e0    : save the current word
+	addl	a0, 8, a0	# .. e1 :
+	ext3b	t2, a1, t1	# e0    : extract high bits for next time
+	beq	a2, $u_eoc	# .. e1 :
+	ldl_u	t2, 8(a1)	# e0    : load high word for next time
+	addl	a1, 8, a1	# .. e1 :
+	nop			# e0    :
+	cmpgeb	zero, t2, t7	# .. e1 : test new word for eos
+	ext7b	t2, a1, t0	# e0    : extract low bits for current word
+	beq	t7, $u_loop	# .. e1 :
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	or	t0, t1, t0	# e0    : first (partial) source word complete
+	cmpgeb	zero, t0, t7	# e0    : is the null in this first bit?
+	bne	t7, $u_final	# .. e1 (zdb)
+
+	stl_u	t0, 0(a0)	# e0    : the null was in the high-order bits
+	addl	a0, 8, a0	# .. e1 :
+	subl	a2, 1, a2	# e0    :
+
+$u_late_head_exit:
+	ext3b	t2, a1, t0	# e0    :
+	cmpgeb	zero, t0, t7	# e0    :
+	or	t7, t10, t6	# e1    :
+	seleq	a2, t6, t7, t7	# e0    :
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t0 == assembled source word
+	   t7 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t7, t6		# e0    : isolate low bit set
+	and	t6, t7, t8	# e1    :
+
+	and	t8, 0x80, t6	# e0    : avoid dest word load if we can
+	bne	t6, 1f		# .. e1 (zdb)
+
+	ldl_u	t1, 0(a0)	# e0    :
+	subl	t8, 1, t6	# .. e1 :
+	or	t6, t8, t7	# e0    :
+	zapnot	t0, t7, t0	# .. e1 : kill source bytes > null
+	zap	t1, t7, t1	# e0    : kill dest bytes <= null
+	or	t0, t1, t0	# e1    :
+
+1:	stl_u	t0, 0(a0)	# e0    :
+	ret	(t9)		# .. e1 :
+
+	/* Got to end-of-count before end of string.
+	   On entry to this basic block:
+	   t1 == the shifted high-order bits from the previous source word  */
+$u_eoc:
+	and	a1, 7, t6	# e1    :
+	sll	t10, t6, t6	# e0    :
+	and	t6, 0xff, t6	# e0	:
+	bne	t6, 1f		# e1    : avoid src word load if we can
+
+	ldl_u	t2, 8(a1)	# e0    : load final src word
+	nop			# .. e1 :
+	ext7b	t2, a1, t0	# e0    : extract high bits for last word
+	or	t1, t0, t1	# e1    :
+
+1:	cmpgeb	zero, t1, t7
+	mov	t1, t0
+
+$u_eocfin:			# end-of-count, final word
+	or	t10, t7, t7
+	br	$u_final
+
+	/* Unaligned copy entry point.  */
+	.align 3
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# e0    : load first source word
+
+	and	a0, 7, t4	# .. e1 : find dest misalignment
+	and	a1, 7, t5	# e0    : find src misalignment
+
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+
+	mov	zero, t0	# .. e1 :
+	mov	zero, t6	# e0    :
+	beq	t4, 1f		# .. e1 :
+	ldl_u	t0, 0(a0)	# e0    :
+	ldi	t6, -1		# .. e1 :
+	mask3b	t6, a0, t6	# e0    :
+1:
+	subl	a1, t4, a1	# .. e1 : sub dest misalignment from src addr
+
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+
+	cmplt	t4, t5, t8	# e1    :
+	ext3b	t1, a1, t1	# .. e0 : shift src into place
+	ldi	t2, -1		# e0    : for creating masks later
+	beq	t8, $u_head	# e1    :
+
+	mask7b	t2, t5, t2	# e0    : begin src byte validity mask
+	cmpgeb	zero, t1, t7	# .. e1 : is there a zero?
+	ext3b	t2, a1, t2	# e0    :
+	or	t7, t10, t5	# .. e1 : test for end-of-count too
+	cmpgeb	zero, t2, t3	# e0    :
+	seleq	a2, t5, t7, t7	# .. e1 :
+	andnot	t7, t3, t7	# e0    :
+	beq	t7, $u_head	# .. e1 (zdb)
+
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+
+	ldl_u	t0, 0(a0)	# e0    :
+	negl	t7, t6		# .. e1 : build bitmask of bytes <= zero
+	mask7b	t1, t4, t1	# e0    :
+	and	t6, t7, t8	# .. e1 :
+	subl	t8, 1, t6	# e0    :
+	or	t6, t8, t7	# e1    :
+
+	zapnot	t2, t7, t2	# e0    : prepare source word; mirror changes
+	zapnot	t1, t7, t1	# .. e1 : to source validity mask
+
+	andnot	t0, t2, t0	# e0    : zero place for source to reside
+	or	t0, t1, t0	# e1    : and put it there
+	stl_u	t0, 0(a0)	# e0    :
+	ret	(t9)		# .. e1 :
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/sub_n.S b/sysdeps/sw_64/sub_n.S
new file mode 100644
index 00000000..fb537014
--- /dev/null
+++ b/sysdeps/sw_64/sub_n.S
@@ -0,0 +1,118 @@
+ # Sw_64 __mpn_sub_n -- Subtract two limb vectors of the same length > 0 and
+ # store difference in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_sub_n
+	.ent	__mpn_sub_n
+__mpn_sub_n:
+	.frame	$30,0,$26,0
+
+	ldl	$3,0($17)
+	ldl	$4,0($18)
+
+	subl	$19,1,$19
+	and	$19,4-1,$2	# number of limbs in first loop
+	bis	$31,$31,$0
+	beq	$2,.L0		# if fmuldiple of 4 limbs, skip first loop
+
+	subl	$19,$2,$19
+
+.Loop0:	subl	$2,1,$2
+	ldl	$5,8($17)
+	addl	$4,$0,$4
+	ldl	$6,8($18)
+	cmpult	$4,$0,$1
+	subl	$3,$4,$4
+	cmpult	$3,$4,$0
+	stl	$4,0($16)
+	or	$0,$1,$0
+
+	addl	$17,8,$17
+	addl	$18,8,$18
+	bis	$5,$5,$3
+	bis	$6,$6,$4
+	addl	$16,8,$16
+	bne	$2,.Loop0
+
+.L0:	beq	$19,.Lend
+
+	.align	3
+.Loop:	subl	$19,4,$19
+
+	ldl	$5,8($17)
+	addl	$4,$0,$4
+	ldl	$6,8($18)
+	cmpult	$4,$0,$1
+	subl	$3,$4,$4
+	cmpult	$3,$4,$0
+	stl	$4,0($16)
+	or	$0,$1,$0
+
+	ldl	$3,16($17)
+	addl	$6,$0,$6
+	ldl	$4,16($18)
+	cmpult	$6,$0,$1
+	subl	$5,$6,$6
+	cmpult	$5,$6,$0
+	stl	$6,8($16)
+	or	$0,$1,$0
+
+	ldl	$5,24($17)
+	addl	$4,$0,$4
+	ldl	$6,24($18)
+	cmpult	$4,$0,$1
+	subl	$3,$4,$4
+	cmpult	$3,$4,$0
+	stl	$4,16($16)
+	or	$0,$1,$0
+
+	ldl	$3,32($17)
+	addl	$6,$0,$6
+	ldl	$4,32($18)
+	cmpult	$6,$0,$1
+	subl	$5,$6,$6
+	cmpult	$5,$6,$0
+	stl	$6,24($16)
+	or	$0,$1,$0
+
+	addl	$17,32,$17
+	addl	$18,32,$18
+	addl	$16,32,$16
+	bne	$19,.Loop
+
+.Lend:	addl	$4,$0,$4
+	cmpult	$4,$0,$1
+	subl	$3,$4,$4
+	cmpult	$3,$4,$0
+	stl	$4,0($16)
+	or	$0,$1,$0
+	ret	$31,($26),1
+
+	.end	__mpn_sub_n
diff --git a/sysdeps/sw_64/submul_1.S b/sysdeps/sw_64/submul_1.S
new file mode 100644
index 00000000..06a64235
--- /dev/null
+++ b/sysdeps/sw_64/submul_1.S
@@ -0,0 +1,90 @@
+ # Sw_64 1621 __mpn_submul_1 -- Multiply a limb vector with a limb and
+ # fsubdract the result from a second limb vector.
+
+ # Copyright (C) 1992-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # s2_limb	r19
+
+ # This code runs at 42 cycles/limb on EV4 and 18 cycles/limb on EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_submul_1
+	.ent	__mpn_submul_1 2
+__mpn_submul_1:
+	.frame	$30,0,$26
+
+	ldl	$2,0($17)	# $2 = s1_limb
+	addl	$17,8,$17	# s1_ptr++
+	subl	$18,1,$18	# size--
+	mull	$2,$19,$3	# $3 = prod_low
+	ldl	$5,0($16)	# $5 = *res_ptr
+	umulh	$2,$19,$0	# $0 = prod_high
+	beq	$18,.Lend1	# jump if size was == 1
+	ldl	$2,0($17)	# $2 = s1_limb
+	addl	$17,8,$17	# s1_ptr++
+	subl	$18,1,$18	# size--
+	subl	$5,$3,$3
+	cmpult	$5,$3,$4
+	stl	$3,0($16)
+	addl	$16,8,$16	# res_ptr++
+	beq	$18,.Lend2	# jump if size was == 2
+
+	.align	3
+.Loop:	mull	$2,$19,$3	# $3 = prod_low
+	ldl	$5,0($16)	# $5 = *res_ptr
+	addl	$4,$0,$0	# cy_limb = cy_limb + 'cy'
+	subl	$18,1,$18	# size--
+	umulh	$2,$19,$4	# $4 = cy_limb
+	ldl	$2,0($17)	# $2 = s1_limb
+	addl	$17,8,$17	# s1_ptr++
+	addl	$3,$0,$3	# $3 = cy_limb + prod_low
+	cmpult	$3,$0,$0	# $0 = carry from (cy_limb + prod_low)
+	subl	$5,$3,$3
+	cmpult	$5,$3,$5
+	stl	$3,0($16)
+	addl	$16,8,$16	# res_ptr++
+	addl	$5,$0,$0	# combine carries
+	bne	$18,.Loop
+
+.Lend2:	mull	$2,$19,$3	# $3 = prod_low
+	ldl	$5,0($16)	# $5 = *res_ptr
+	addl	$4,$0,$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,$19,$4	# $4 = cy_limb
+	addl	$3,$0,$3	# $3 = cy_limb + prod_low
+	cmpult	$3,$0,$0	# $0 = carry from (cy_limb + prod_low)
+	subl	$5,$3,$3
+	cmpult	$5,$3,$5
+	stl	$3,0($16)
+	addl	$5,$0,$0	# combine carries
+	addl	$4,$0,$0	# cy_limb = prod_high + cy
+	ret	$31,($26),1
+.Lend1:	subl	$5,$3,$3
+	cmpult	$5,$3,$5
+	stl	$3,0($16)
+	addl	$0,$5,$0
+	ret	$31,($26),1
+
+	.end	__mpn_submul_1
diff --git a/sysdeps/sw_64/sw6a/Implies b/sysdeps/sw_64/sw6a/Implies
new file mode 100644
index 00000000..b34962bb
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/Implies
@@ -0,0 +1 @@
+sw_64/sw6a
diff --git a/sysdeps/sw_64/sw6a/add_n.S b/sysdeps/sw_64/sw6a/add_n.S
new file mode 100644
index 00000000..26e9c698
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/add_n.S
@@ -0,0 +1,146 @@
+ # Sw_64 __mpn_add_n -- Add two limb vectors of the same length > 0 and
+ # store sum in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_add_n
+	.ent	__mpn_add_n
+__mpn_add_n:
+	.frame	$30,0,$26,0
+
+	or	$31,$31,$25		# clear cy
+	subl	$19,4,$19		# decr loop cnt
+	blt	$19,.Lend2		# if less than 4 limbs, goto 2nd loop
+ # Start software pipeline for 1st loop
+	ldl	$0,0($18)
+	ldl	$1,8($18)
+	ldl	$4,0($17)
+	ldl	$5,8($17)
+	addl	$17,32,$17		# update s1_ptr
+	ldl	$2,16($18)
+	addl	$0,$4,$20		# 1st main add
+	ldl	$3,24($18)
+	subl	$19,4,$19		# decr loop cnt
+	ldl	$6,-16($17)
+	cmpult	$20,$0,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	addl	$1,$25,$28		# cy add
+	addl	$18,32,$18		# update s2_ptr
+	addl	$5,$28,$21		# 2nd main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	blt	$19,.Lend1		# if less than 4 limbs remain, jump
+ # 1st loop handles groups of 4 limbs in a software pipeline
+	.align	4
+.Loop:	cmpult	$21,$28,$25		# compute cy from last add
+	ldl	$0,0($18)
+	or	$8,$25,$25		# combine cy from the two fadds
+	ldl	$1,8($18)
+	addl	$2,$25,$28		# cy add
+	ldl	$4,0($17)
+	addl	$28,$6,$22		# 3rd main add
+	ldl	$5,8($17)
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$22,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	addl	$28,$7,$23		# 4th main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$23,$28,$25		# compute cy from last add
+	addl	$17,32,$17		# update s1_ptr
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	addl	$0,$25,$28		# cy add
+	ldl	$2,16($18)
+	addl	$4,$28,$20		# 1st main add
+	ldl	$3,24($18)
+	cmpult	$28,$25,$8		# compute cy from last add
+	ldl	$6,-16($17)
+	cmpult	$20,$28,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	or	$8,$25,$25		# combine cy from the two fadds
+	subl	$19,4,$19		# decr loop cnt
+	stl	$22,-16($16)
+	addl	$1,$25,$28		# cy add
+	stl	$23,-8($16)
+	addl	$5,$28,$21		# 2nd main add
+	addl	$18,32,$18		# update s2_ptr
+	cmpult	$28,$25,$8		# compute cy from last add
+	bge	$19,.Loop
+ # Finish software pipeline for 1st loop
+.Lend1:	cmpult	$21,$28,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$2,$25,$28		# cy add
+	addl	$28,$6,$22		# 3rd main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$22,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	addl	$28,$7,$23		# 4th main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$23,$28,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	stl	$22,-16($16)
+	stl	$23,-8($16)
+.Lend2:	addl	$19,4,$19		# restore loop cnt
+	beq	$19,.Lret
+ # Start software pipeline for 2nd loop
+	ldl	$0,0($18)
+	ldl	$4,0($17)
+	subl	$19,1,$19
+	beq	$19,.Lend0
+ # 2nd loop handles remaining 1-3 limbs
+	.align	4
+.Loop0:	addl	$0,$25,$28		# cy add
+	ldl	$0,8($18)
+	addl	$4,$28,$20		# main add
+	ldl	$4,8($17)
+	addl	$18,8,$18
+	cmpult	$28,$25,$8		# compute cy from last add
+	addl	$17,8,$17
+	stl	$20,0($16)
+	cmpult	$20,$28,$25		# compute cy from last add
+	subl	$19,1,$19		# decr loop cnt
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,8,$16
+	bne	$19,.Loop0
+.Lend0:	addl	$0,$25,$28		# cy add
+	addl	$4,$28,$20		# main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$20,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+
+.Lret:	or	$25,$31,$0		# return cy
+	ret	$31,($26),1
+	.end	__mpn_add_n
diff --git a/sysdeps/sw_64/sw6a/addmul_1.S b/sysdeps/sw_64/sw6a/addmul_1.S
new file mode 100644
index 00000000..c8a8a35f
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/addmul_1.S
@@ -0,0 +1,477 @@
+ # Sw_64 ev6 mpn_addmul_1 -- Multiply a limb vector with a limb and add
+ # the result to a second limb vector.
+ #
+ #  Copyright (C) 2000-2018 Free Software Foundation, Inc.
+ #
+ #  This file is part of the GNU MP Library.
+ #
+ #  The GNU MP Library is free software; you can redistribute it and/or modify
+ #  it under the terms of the GNU Lesser General Public License as published
+ #  by the Free Software Foundation; either version 2.1 of the License, or (at
+ #  your option) any later version.
+ #
+ #  The GNU MP Library is distributed in the hope that it will be useful, but
+ #  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ #  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ #  License for more details.
+ #
+ #  You should have received a copy of the GNU Lesser General Public License
+ #  along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+ #  INPUT PARAMETERS
+ #  res_ptr	$16
+ #  s1_ptr	$17
+ #  size	$18
+ #  s2_limb	$19
+ #
+ #  This code runs at 42 cycles/limb on EV4, 18 cycles/limb on EV5, and
+ #  exactly 3.625 cycles/limb on EV6...
+ #
+ # This code was written in close cooperation with ev6 pipeline expert
+ # Steve Root (root@toober.hlo.dec.com).  Any errors are tege's fault, though.
+ #
+ #   Register usages for unrolled loop:
+ #	  0-3     mul's
+ #	  4-7     acc's
+ #	  8-15    mul results
+ #	  20,21   carry's
+ #	  22,23   save for stores
+ #
+ #   Sustains 8 mul-fadds in 29 cycles in the unrolled inner loop.
+ #
+ #   The stores can issue a cycle late so we have paired no-op's to 'catch'
+ #   them, so that further disturbance to the schedule is damped.
+ #
+ #   We couldn't pair the loads, because the entangled schedule of the
+ #   carry's has to happen on one side {0} of the machine. Note, the total
+ #   use of U0, and the total use of L0 (after attending to the stores).
+ #   which is part of the reason why....
+ #
+ #   This is a great schedule for the d_cache, a poor schedule for the
+ #   b_cache. The lockup on U0 means that any stall can't be recovered
+ #   from. Consider a ldl in L1.  say that load gets stalled because it
+ #   collides with a fill from the b_Cache. On the next cycle, this load
+ #   gets priority. If first looks at L0, and goes there. The instruction
+ #   we intended for L0 gets to look at L1, which is NOT where we want
+ #   it. It either stalls 1, because it can't go in L0, or goes there, and
+ #   causes a further instruction to stall.
+ #
+ #   So for b_cache, we're likely going to want to put one or more cycles
+ #   back into the code! And, of course, put in prefetches. For the
+ #   accumulator, flds, intent to modify.  For the fmuldiplier, you might
+ #   want ldl, evict next, if you're not wanting to use it again soon. Use
+ #   256 ahead of present pointer value. At a place where we have an mt
+ #   followed by a bookkeeping, put the bookkeeping in upper, and the
+ #   prefetch into lower.
+ #
+ #   Note, the usage of physical registers per cycle is smoothed off, as
+ #   much as possible.
+ #
+ #   Note, the ldl's and stl's are at the end of the quadpacks.  note, we'd
+ #   like not to have a ldl or stl to preceded a conditional branch in a
+ #   quadpack. The conditional branch moves the retire pointer one cycle
+ #   later.
+ #
+ #   Optimization notes:
+ #   Callee-saves regs: $9 $10 $11 $12 $13 $14 $15 $26 ?$27?
+ #   Reserved regs:	 $29 $30 $31
+ #   Free caller-saves regs in unrolled code: $24 $25 $28
+ #   We should swap some of the callee-saves regs for some of the free
+ #   caller-saves regs, saving some overhead cycles.
+ #   Most importantly, we should write fast code for the 0-7 case.
+ #   The code we use there are for the 21164, and runs at 7 cycles/limb
+ #   on the 21264.  Should not be hard, if we write specialized code for
+ #   1-7 limbs (the one for 0 limbs should be straightforward).  We then just
+ #   need a jump table indexed by the low 3 bits of the count argument.
+
+	.set	noreorder
+	.set	noat
+	.text
+
+	.globl	__mpn_addmul_1
+	.ent	__mpn_addmul_1
+__mpn_addmul_1:
+	.frame	$30,0,$26,0
+	.prologue 0
+
+	cmpult	$18,	8,	$1
+	beq	$1,	$Large
+
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$18,	1,	$18	# size--
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	umulh	$2,	$19,	$0	# $0 = prod_high
+	beq	$18,	$Lend0b		# jump if size was == 1
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$18,	1,	$18	# size--
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$4
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	beq	$18,	$Lend0a		# jump if size was == 2
+
+	.align 3
+$Loop0:	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	subl	$18,	1,	$18	# size--
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	bne	$18,	$Loop0
+$Lend0a:
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$5,	$0,	$0	# combine carries
+	addl	$4,	$0,	$0	# cy_limb = prod_high + cy
+	ret	$31,	($26),	1
+$Lend0b:
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$0,	$5,	$0
+	ret	$31,	($26),	1
+
+$Large:
+	ldi	$30,	-240($30)
+	stl	$9,	8($30)
+	stl	$10,	16($30)
+	stl	$11,	24($30)
+	stl	$12,	32($30)
+	stl	$13,	40($30)
+	stl	$14,	48($30)
+	stl	$15,	56($30)
+
+	and	$18,	7,	$20	# count for the first loop, 0-7
+	srl	$18,	3,	$18	# count for unrolled loop
+	bis	$31,	$31,	$0
+	beq	$20,	$Lunroll
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$20,	1,	$20	# size--
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	umulh	$2,	$19,	$0	# $0 = prod_high
+	beq	$20,	$Lend1b		# jump if size was == 1
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$20,	1,	$20	# size--
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$4
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	beq	$20,	$Lend1a		# jump if size was == 2
+
+	.align 3
+$Loop1:	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	subl	$20,	1,	$20	# size--
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	bne	$20,	$Loop1
+
+$Lend1a:
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	addl	$4,	$0,	$0	# cy_limb = prod_high + cy
+	br	$31,	$Lunroll
+$Lend1b:
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$0,	$5,	$0
+
+$Lunroll:
+	ldi	$17,	-16($17)	# L1 bookkeeping
+	ldi	$16,	-16($16)	# L1 bookkeeping
+	bis	$0,	$31,	$12
+
+ # ____ UNROLLED LOOP SOFTWARE PIPELINE STARTUP ____
+
+	ldl	$2,	16($17)		# L1
+	ldl	$3,	24($17)		# L1
+	ldi	$18,	-1($18)		# L1 bookkeeping
+	ldl	$6,	16($16)		# L1
+	ldl	$7,	24($16)		# L1
+	ldl	$0,	32($17)		# L1
+	mull	$19,	$2,	$13	# U1
+	ldl	$1,	40($17)		# L1
+	umulh	$19,	$2,	$14	# U1
+	mull	$19,	$3,	$15	# U1
+	ldi	$17,	64($17)		# L1 bookkeeping
+	ldl	$4,	32($16)		# L1
+	ldl	$5,	40($16)		# L1
+	umulh	$19,	$3,	$8	# U1
+	ldl	$2,	-16($17)	# L1
+	mull	$19,	$0,	$9	# U1
+	ldl	$3,	-8($17)		# L1
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	mull	$19,	$1,	$11	# U1
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	ldi	$16,	64($16)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	-16($16)	# L1
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	-8($16)		# L1
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	0($17)		# L1
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	8($17)		# L1
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# L0 lo + acc
+	stl	$22,	-48($16)	# L0
+	stl	$23,	-40($16)	# L1
+	mull	$19,	$3,	$15	# U1
+	addl	$8,	$21,	$8	# U0 hi mul + carry
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	ble	$18,	$Lend		# U1 bookkeeping
+
+ # ____ MAIN UNROLLED LOOP ____
+	.align 4
+$Loop:
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	0($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	8($16)		# L1
+
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	ldl	$2,	16($17)		# L1
+
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	ldl	$3,	24($17)		# L1
+
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	-32($16)	# L0
+	stl	$23,	-24($16)	# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$1,	$11	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$18,	-1($18)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	16($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	24($16)		# L1
+
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	32($17)		# L1
+
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	40($17)		# L1
+
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# U0 lo + acc
+	stl	$22,	-16($16)	# L0
+	stl	$23,	-8($16)		# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$3,	$15	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$8,	$21,	$8	# L0 hi mul + carry
+
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$17,	64($17)		# L1 bookkeeping
+	addl	$4,	$8,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	32($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	40($16)		# L1
+
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	ldl	$2,	-16($17)	# L1
+
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	ldl	$3,	-8($17)		# L1
+
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	0($16)		# L0
+	stl	$23,	8($16)		# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$1,	$11	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$16,	64($16)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	-16($16)	# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	-8($16)		# L1
+
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	0($17)		# L1
+
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	8($17)		# L1
+
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# L0 lo + acc
+	stl	$22,	-48($16)	# L0
+	stl	$23,	-40($16)	# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$3,	$15	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$8,	$21,	$8	# U0 hi mul + carry
+
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	bis	$31,	$31,	$31	# L1 mt
+	bgt	$18,	$Loop		# U1 bookkeeping
+
+# ____ UNROLLED LOOP SOFTWARE PIPELINE FINISH ____
+$Lend:
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	0($16)		# L1
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	8($16)		# L1
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	-32($16)	# L0
+	stl	$23,	-24($16)	# L1
+	mull	$19,	$1,	$11	# U1
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	addl	$6,	$12,	$22	# U0 hi add => answer
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	addl	$4,	$9,	$4	# U0 lo + acc
+	stl	$22,	-16($16)	# L0
+	stl	$23,	-8($16)		# L1
+	bis	$31,	$31,	$31	# L0 st slosh
+	addl	$8,	$21,	$8	# L0 hi mul + carry
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	stl	$22,	0($16)		# L0
+	stl	$23,	8($16)		# L1
+	addl	$12,	$21,	$0	# U0 hi mul + carry
+
+	ldl	$9,	8($30)
+	ldl	$10,	16($30)
+	ldl	$11,	24($30)
+	ldl	$12,	32($30)
+	ldl	$13,	40($30)
+	ldl	$14,	48($30)
+	ldl	$15,	56($30)
+	ldi	$30,	240($30)
+	ret	$31,	($26),	1
+
+	.end	__mpn_addmul_1
diff --git a/sysdeps/sw_64/sw6a/lshift.S b/sysdeps/sw_64/sw6a/lshift.S
new file mode 100644
index 00000000..1b7f3f98
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/lshift.S
@@ -0,0 +1,172 @@
+ # Sw_64 EV5 __mpn_lshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 3.25 cycles/limb on the EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_lshift
+	.ent	__mpn_lshift
+__mpn_lshift:
+	.frame	$30,0,$26,0
+
+	s8addl	$18,$17,$17	# make r17 point at end of s1
+	ldl	$4,-8($17)	# load first limb
+	subl	$31,$19,$20
+	s8addl	$18,$16,$16	# make r16 point at end of RES
+	subl	$18,1,$18
+	and	$18,4-1,$28	# number of limbs in first loop
+	srl	$4,$20,$0	# compute function result
+
+	beq	$28,.L0
+	subl	$18,$28,$18
+
+	.align	3
+.Loop0:	ldl	$3,-16($17)
+	subl	$16,8,$16
+	sll	$4,$19,$5
+	subl	$17,8,$17
+	subl	$28,1,$28
+	srl	$3,$20,$6
+	or	$3,$3,$4
+	or	$5,$6,$8
+	stl	$8,0($16)
+	bne	$28,.Loop0
+
+.L0:	sll	$4,$19,$24
+	beq	$18,.Lend
+ # warm up phase 1
+	ldl	$1,-16($17)
+	subl	$18,4,$18
+	ldl	$2,-24($17)
+	ldl	$3,-32($17)
+	ldl	$4,-40($17)
+	beq	$18,.Lend1
+ # warm up phase 2
+	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	ldl	$1,-48($17)
+	sll	$2,$19,$22
+	ldl	$2,-56($17)
+	srl	$3,$20,$5
+	or	$7,$24,$7
+	sll	$3,$19,$23
+	or	$8,$21,$8
+	srl	$4,$20,$6
+	ldl	$3,-64($17)
+	sll	$4,$19,$24
+	ldl	$4,-72($17)
+	subl	$18,4,$18
+	beq	$18,.Lend2
+	.align  4
+ # main loop
+.Loop:	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+
+	srl	$1,$20,$7
+	subl	$18,4,$18
+	sll	$1,$19,$21
+	unop	# ldl	$31,-96($17)
+
+	srl	$2,$20,$8
+	ldl	$1,-80($17)
+	sll	$2,$19,$22
+	ldl	$2,-88($17)
+
+	stl	$5,-24($16)
+	or	$7,$24,$7
+	stl	$6,-32($16)
+	or	$8,$21,$8
+
+	srl	$3,$20,$5
+	unop	# ldl	$31,-96($17)
+	sll	$3,$19,$23
+	subl	$16,32,$16
+
+	srl	$4,$20,$6
+	ldl	$3,-96($17)
+	sll	$4,$19,$24
+	ldl	$4,-104($17)
+
+	subl	$17,32,$17
+	bne	$18,.Loop
+ # cool down phase 2/1
+.Lend2:	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	sll	$2,$19,$22
+	stl	$5,-24($16)
+	or	$7,$24,$7
+	stl	$6,-32($16)
+	or	$8,$21,$8
+	srl	$3,$20,$5
+	sll	$3,$19,$23
+	srl	$4,$20,$6
+	sll	$4,$19,$24
+ # cool down phase 2/2
+	stl	$7,-40($16)
+	or	$5,$22,$5
+	stl	$8,-48($16)
+	or	$6,$23,$6
+	stl	$5,-56($16)
+	stl	$6,-64($16)
+ # cool down phase 2/3
+	stl	$24,-72($16)
+	ret	$31,($26),1
+
+ # cool down phase 1/1
+.Lend1:	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	sll	$2,$19,$22
+	srl	$3,$20,$5
+	or	$7,$24,$7
+	sll	$3,$19,$23
+	or	$8,$21,$8
+	srl	$4,$20,$6
+	sll	$4,$19,$24
+ # cool down phase 1/2
+	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+	stl	$5,-24($16)
+	stl	$6,-32($16)
+	stl	$24,-40($16)
+	ret	$31,($26),1
+
+.Lend:	stl	$24,-8($16)
+	ret	$31,($26),1
+	.end	__mpn_lshift
diff --git a/sysdeps/sw_64/sw6a/memcpy.S b/sysdeps/sw_64/sw6a/memcpy.S
new file mode 100644
index 00000000..7d440119
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/memcpy.S
@@ -0,0 +1,840 @@
+/*
+ * Inputs:
+ *      length in $18
+ *      destination address in $16
+ *      source address in $17
+ *      return address in $26
+ *
+ * Outputs:
+ *      bytes copied in $18
+ *
+ * Clobbers:
+ *      $1,$2,$3,$4,$5,$16,$17
+ *	$f10, $f11, $f12, $f13, $f15, $f17, $f22, $f23
+ */
+
+#ifndef STRING_NOOPT
+#include <sysdep.h>
+
+        .arch sw6a
+        .set noreorder
+        .set noat
+
+ENTRY(memcpy)
+        .prologue 0
+
+        mov     $16, $0                 # E : copy dest to return
+        ble     $18, $nomoredata        # U : done with the copy?
+        xor     $16, $17, $1            # E : are source and dest alignments the same?
+        and     $1, 7, $1               # E : are they the same mod 8?
+
+        bne     $1, $misaligned         # U : Nope - gotta do this the slow way
+        /* source and dest are same mod 8 address */
+        and     $16, 7, $1              # E : Are both 0mod8?
+        beq     $1, $both_0mod8         # U : Yes
+        nop                             # E :
+
+        /*
+         * source and dest are same misalignment.  move a byte at a time
+         * until a 0mod8 alignment for both is reached.
+   * At least one byte more to move
+         */
+
+$head_align:
+        ldbu    $1, 0($17)              # L : grab a byte
+        subl    $18, 1, $18             # E : count--
+        addl    $17, 1, $17             # E : src++
+        stb     $1, 0($16)              # L :
+        addl    $16, 1, $16             # E : dest++
+        and     $16, 7, $1              # E : Are we at 0mod8 yet?
+        ble     $18, $nomoredata        # U : done with the copy?
+        bne     $1, $head_align         # U :
+
+$both_0mod8:
+        cmple   $18, 127, $1            # E : Can we unroll the loop?
+        bne     $1, $no_unroll          # U :
+        and     $16, 63, $1             # E : get mod64 alignment
+        beq     $1, $do_unroll          # U : no single quads to fiddle
+
+$single_head_quad:
+        ldl     $1, 0($17)              # L : get 8 bytes
+        subl    $18, 8, $18             # E : count -= 8
+        addl    $17, 8, $17             # E : src += 8
+        nop                             # E :
+
+        stl     $1, 0($16)              # L : store
+        addl    $16, 8, $16             # E : dest += 8
+        and     $16, 63, $1             # E : get mod64 alignment
+        bne     $1, $single_head_quad   # U : still not fully aligned
+
+$do_unroll:
+        addl    $16, 64, $7             # E : Initial (+1 trip) wh64 address
+        cmple   $18, 127, $1            # E : Can we go through the unrolled loop?
+        bne     $1, $tail_quads         # U : Nope
+        nop                             # E :
+
+$unroll_body:
+        wh64    ($7)                    # L1 : memory subsystem hint: 64 bytes at
+                                        # ($7) are about to be over-written
+        ldl     $6, 0($17)              # L0 : bytes 0..7
+        nop                             # E :
+        nop                             # E :
+
+        ldl     $4, 8($17)              # L : bytes 8..15
+        ldl     $5, 16($17)             # L : bytes 16..23
+        addl    $7, 64, $7              # E : Update next wh64 address
+        nop                             # E :
+
+        ldl     $3, 24($17)             # L : bytes 24..31
+        addl    $16, 64, $1             # E : fallback value for wh64
+        nop                             # E :
+        nop                             # E :
+
+        addl    $17, 32, $17            # E : src += 32 bytes
+        stl     $6, 0($16)              # L : bytes 0..7
+        nop                             # E :
+        nop                             # E :
+
+        stl     $4, 8($16)              # L : bytes 8..15
+        stl     $5, 16($16)             # L : bytes 16..23
+        subl    $18, 192, $2            # E : At least two more trips to go?
+        nop                             # E :
+
+        stl     $3, 24($16)             # L : bytes 24..31
+        addl    $16, 32, $16            # E : dest += 32 bytes
+        nop                             # E :
+        nop                             # E :
+
+        ldl     $6, 0($17)              # L : bytes 0..7
+        ldl     $4, 8($17)              # L : bytes 8..15
+        sellt   $2, $1, $7, $7          # E : Latency 2, extra map slot - Use
+                                        # fallback wh64 address if < 2 more trips
+        nop                             # E :
+
+        ldl     $5, 16($17)             # L : bytes 16..23
+        ldl     $3, 24($17)             # L : bytes 24..31
+        addl    $16, 32, $16            # E : dest += 32
+        subl    $18, 64, $18            # E : count -= 64
+        addl    $17, 32, $17            # E : src += 32
+        stl     $6, -32($16)            # L : bytes 0..7
+        stl     $4, -24($16)            # L : bytes 8..15
+        cmple   $18, 63, $1             # E : At least one more trip?
+
+        stl     $5, -16($16)            # L : bytes 16..23
+        stl     $3, -8($16)             # L : bytes 24..31
+        nop                             # E :
+        beq     $1, $unroll_body
+
+$tail_quads:
+$no_unroll:
+        .align 4
+        subl    $18, 8, $18             # E : At least a quad left?
+        blt     $18, $less_than_8       # U : Nope
+        nop                             # E :
+        nop                             # E :
+
+$move_a_quad:
+        ldl     $1, 0($17)              # L : fetch 8
+        subl    $18, 8, $18             # E : count -= 8
+        addl    $17, 8, $17             # E : src += 8
+        nop                             # E :
+
+        stl     $1, 0($16)              # L : store 8
+        addl    $16, 8, $16             # E : dest += 8
+        bge     $18, $move_a_quad       # U :
+        nop                             # E :
+
+$less_than_8:
+        .align 4
+        addl    $18, 8, $18             # E : add back for trailing bytes
+        ble     $18, $nomoredata        # U : All-done
+        nop                             # E :
+        nop                             # E :
+
+        /* Trailing bytes */
+$tail_bytes:
+        subl    $18, 1, $18             # E : count--
+        ldbu    $1, 0($17)              # L : fetch a byte
+        addl    $17, 1, $17             # E : src++
+        nop                             # E :
+
+        stb     $1, 0($16)              # L : store a byte
+        addl    $16, 1, $16             # E : dest++
+        bgt     $18, $tail_bytes        # U : more to be done?
+        nop                             # E :
+
+        /* branching to exit takes 3 extra cycles, so replicate exit here */
+        ret     $31, ($26), 1           # L0 :
+        nop                             # E :
+        nop                             # E :
+        nop                             # E :
+
+$misaligned:
+        mov     $0, $4                  # E : dest temp
+        and     $0, 7, $1               # E : dest alignment mod8
+        beq     $1, $dest_0mod8         # U : life doesnt totally suck
+        nop
+
+$aligndest:
+        ble     $18, $nomoredata        # U :
+        ldbu    $1, 0($17)              # L : fetch a byte
+        subl    $18, 1, $18             # E : count--
+        addl    $17, 1, $17             # E : src++
+
+        stb     $1, 0($4)               # L : store it
+        addl    $4, 1, $4               # E : dest++
+        and     $4, 7, $1               # E : dest 0mod8 yet?
+        bne     $1, $aligndest          # U : go until we are aligned.
+
+        /* Source has unknown alignment, but dest is known to be 0mod8 */
+$dest_0mod8:
+        subl    $18, 8, $18             # E : At least a quad left?
+        blt     $18, $misalign_tail     # U : Nope
+        ldl_u   $3, 0($17)              # L : seed (rotating load) of 8 bytes
+        nop                             # E :
+
+$mis_quad:
+        ldl_u   $16, 8($17)             # L : Fetch next 8
+        ext3b   $3, $17, $3             # U : masking
+        ext7b   $16, $17, $1            # U : masking
+        bis     $3, $1, $1              # E : merged bytes to store
+
+        subl    $18, 8, $18             # E : count -= 8
+        addl    $17, 8, $17             # E : src += 8
+        stl     $1, 0($4)               # L : store 8 (aligned)
+        mov     $16, $3                 # E : "rotate" source data
+
+        addl    $4, 8, $4               # E : dest += 8
+        bge     $18, $mis_quad          # U : More quads to move
+        nop
+        nop
+
+$misalign_tail:
+        addl    $18, 8, $18             # E : account for tail stuff
+        ble     $18, $nomoredata        # U :
+        nop
+        nop
+
+$misalign_byte:
+        ldbu    $1, 0($17)              # L : fetch 1
+        subl    $18, 1, $18             # E : count--
+        addl    $17, 1, $17             # E : src++
+        nop                             # E :
+
+        stb     $1, 0($4)               # L : store
+        addl    $4, 1, $4               # E : dest++
+        bgt     $18, $misalign_byte     # U : more to go?
+        nop
+
+
+$nomoredata:
+        ret     $31, ($26), 1           # L0 :
+        nop                             # E :
+        nop                             # E :
+        nop                             # E :
+
+END(memcpy)
+libc_hidden_builtin_def (memcpy)
+
+#else
+
+#include <sysdep.h>
+#define NOCACHE
+        .set noreorder
+        .align  4
+        .globl memcpy
+        .ent memcpy
+	
+	.type $jmppointh,@object
+$jumppointh:
+        .gprel32        $dest_0mod32
+        .gprel32        J$H01
+        .gprel32        J$H02
+        .gprel32        J$H03
+        .gprel32        J$H04
+        .gprel32        J$H05
+        .gprel32        J$H06
+        .gprel32        J$H07
+        .gprel32        J$H08
+        .gprel32        J$H09
+        .gprel32        J$H10
+        .gprel32        J$H11
+        .gprel32        J$H12
+        .gprel32        J$H13
+        .gprel32        J$H14
+        .gprel32        J$H15
+        .gprel32        J$H16
+        .gprel32        J$H17
+        .gprel32        J$H18
+        .gprel32        J$H19
+        .gprel32        J$H20
+        .gprel32        J$H21
+        .gprel32        J$H22
+        .gprel32        J$H23
+        .gprel32        J$H24
+        .gprel32        J$H25
+        .gprel32        J$H26
+        .gprel32        J$H27
+        .gprel32        J$H28
+        .gprel32        J$H29
+        .gprel32        J$H30
+        .gprel32        J$H31
+
+
+#memcpy:
+ENTRY(memcpy)
+        .prologue 1
+
+	ldgp $29, 0($27)
+	mov $16, $0
+	cmplt $18, 32, $1
+	bne $1, $less_than_32
+	nop
+	nop
+
+        and $16, 31, $1 # E : Are we at dest 0mod32 yet?
+        beq $1, $dest_0mod32 # U :
+
+$judge_align:
+        subl  $16, $17, $1
+        and   $1, 31,  $1
+        bne   $1,$align_32bytes   #  (src-dest)%32=0 ?
+        ldi   $2, 32
+        and   $16, 31, $1
+        subl  $2, $1, $1
+        cmplt $18, $1, $3
+        bne   $3,$align_32bytes
+
+$Headalign:
+        addl   $16, $1, $16
+        addl   $17, $1, $17
+        subl   $18, $1, $18
+        ldih    $2, $jumppointh($29)    !gprelhigh
+        s4addl $1, $2, $2
+        ldw    $2, $jumppointh($2)      !gprellow
+        addl   $2, $29, $2
+        jmp    ($2)
+
+
+$align_32bytes:
+        ldbu $1, 0($17) # L : grab a byte
+        addl $17, 1, $17 # E : src++
+        stb $1, 0($16) # L :
+        subl $18, 1, $18 # E : count--
+        addl $16, 1, $16 # E : dest++
+        and $16, 31, $1 # E : Are we at 0mod32 yet?
+	ble $18, $nomoredata # U : done with the copy?
+	.align 4
+        bne $1, $align_32bytes # U :
+
+	.align 4
+$dest_0mod32:
+        and $17, 31, $1 # E : Are we both at 0mod32 yet?
+	bne $1, $misalign
+
+        cmple $18, 63, $1 # E
+        bne $1, $tail_simd # U :
+
+#ifdef NOCACHE
+	.align 4
+	ldih	$1, 8($31)
+        cmple $18, $1, $1 	# small than 512K
+        beq $1, $big_body_simd # U :
+#endif
+
+$body_simd:
+	fillcs  128*5($17)
+
+	vldd   $f12, 0($17)
+	vldd   $f13, 32($17)
+
+	vstd   $f12, 0($16)
+	vstd   $f13, 32($16)
+
+	#fillde  128*5($16)    #gxw
+	
+	addl	$16, 64, $16
+	addl	$17, 64, $17
+	subl	$18, 64, $18
+
+	cmple 	$18, 63, $1 # E : At least one more trip?
+        beq 	$1, $body_simd
+
+	br	$tail_simd
+
+#ifdef NOCACHE
+$big_body_simd:
+	fillcs  128*5($17)
+
+	vldd   $f12, 0($17)
+	vldd   $f13, 32($17)
+
+	vstd_nc	$f12, 0($16)
+	vstd_nc	$f13, 32($16)
+
+	addl	$16, 64, $16
+	addl	$17, 64, $17
+	subl	$18, 64, $18
+
+	cmple 	$18, 63, $1 # E : At least one more trip?
+        beq 	$1, $big_body_simd
+
+	memb
+#endif
+
+	.align 4
+$tail_simd:
+	cmple 	$18, 31, $1 # E : At least one more trip?
+        bne 	$1, $before_tail_quads
+
+	vldd   $f12, 0($17)
+	vstd   $f12, 0($16)
+
+	subl	$18, 32, $18
+	addl	$16, 32, $16
+	addl	$17, 32, $17
+
+$before_tail_quads:
+	ble	$18, $nomoredata
+	vldd   $f12, 0($17)
+
+	br	$tail_quads
+
+$misalign:
+	ldi	$2, 256($31)
+	andnot $17, 31, $3
+	vldd   $f10, 0($3)
+	and	$17, 31, $5
+	sll	$5, 3, $5
+	subw	$2, $5, $4
+	ifmovs	$5, $f15
+	ifmovs	$4, $f17
+
+        cmple $18, 63, $1 # E
+        bne $1, $misalign_tail_simd # U :
+
+#ifdef NOCACHE
+	.align 4
+	ldih	$1, 8($31) 
+        cmple $18, $1, $1 	# small than 512K
+        beq $1, $big_misalign_body_simd # U :
+#endif
+
+$misalign_body_simd:
+	vldd   $f11, 32($3)
+	fillcs  128*5($3)
+
+	srlow	$f10, $f15, $f12
+	sllow	$f11, $f17, $f13
+	fillde  128*5($16)
+	vlogfc  $f12, $f13, $f31, $f12
+
+	vldd   $f10, 64($3)
+	srlow	$f11, $f15, $f22
+	sllow	$f10, $f17, $f23
+	vlogfc  $f22, $f23, $f31, $f22
+
+	vstd	$f12, 0($16)
+	vstd	$f22, 32($16)
+
+	addl	$16, 64, $16
+	addl	$3, 64, $3
+	subl	$18, 64, $18
+
+	cmple 	$18, 63, $1 # E : At least one more trip?
+        beq 	$1, $misalign_body_simd
+	br	$misalign_tail_simd
+
+#ifdef NOCACHE
+$big_misalign_body_simd:
+	vldd   $f11, 32($3)
+	fillcs  128*5($3)
+
+	srlow	$f10, $f15, $f12
+	sllow	$f11, $f17, $f13
+	vlogfc  $f12, $f13, $f31, $f12
+
+	vldd   $f10, 64($3)
+	srlow	$f11, $f15, $f22
+	sllow	$f10, $f17, $f23
+	vlogfc  $f22, $f23, $f31, $f22
+
+	vstd_nc	$f12, 0($16)
+	vstd_nc	$f22, 32($16)
+
+	addl	$16, 64, $16
+	addl	$3, 64, $3
+	subl	$18, 64, $18
+
+	cmple $18, 63, $1 # E : At least one more trip?
+        beq $1, $big_misalign_body_simd
+	memb
+#endif		
+
+	.align 4
+$misalign_tail_simd:
+	cmple $18, 31, $1 # E : At least one more trip?
+        bne $1, $before_misalign_tail_quads
+
+	vldd $f11, 32($3)
+	srlow	$f10, $f15, $f12
+	sllow	$f11, $f17, $f13
+	vlogfc  $f12, $f13, $f31, $f12
+
+	vstd $f12, 0($16)
+
+	subl	$18, 32, $18
+	addl	$16, 32, $16
+	addl	$3, 32, $3
+	vfmov   $f11, $f10
+
+$before_misalign_tail_quads:
+	srlow	$f10, $f15, $f12
+	s8subl  $18, $4, $1
+	ble	$1, $tail_quads
+
+	vldd   $f11, 32($3)
+	sllow	$f11, $f17, $f13
+	vlogfc  $f12, $f13, $f31, $f12
+
+$tail_quads:
+        subl $18, 8, $1 # E : At least a quad left?
+        blt $1, $less_than_8 # U : Nope
+        nop # E :
+        nop # E :
+
+$move_a_quad:
+	fimovd  $f12, $1
+        srlow $f12, 64, $f12 # E : src += 8
+
+        stl $1, 0($16) # L : store 8
+        subl $18, 8, $18 # E : count -= 8
+        addl $16, 8, $16 # E : dest += 8
+	subl $18, 8, $1
+        bge $1, $move_a_quad # U :
+        nop # E :
+
+$less_than_8:
+        .align 4
+        beq $18, $nomoredata # U : All-done
+	fimovd  $f12, $1
+
+
+$tail_bytes:
+        stb $1, 0($16) # L : store a byte
+        subl $18, 1, $18 # E : count--
+	srl  $1, 8, $1
+        addl $16, 1, $16 # E : dest++
+        bgt $18, $tail_bytes # U : more to be done?
+        nop # E :
+
+
+$nomoredata:
+        ret $31, ($26), 1 # L0 :
+
+$less_than_32:
+	ble $18, $nomoredata # U : done with the copy?
+
+$tail_32bytes:
+        ldbu $1, 0($17) # L : grab a byte
+        addl $17, 1, $17 # E : src++
+        stb $1, 0($16) # L :
+        subl $18, 1, $18 # E : count--
+        addl $16, 1, $16 # E : dest++
+	bgt $18, $tail_32bytes  # U : done with the copy?
+	br $nomoredata 
+	
+
+J$H01:
+        ldbu    $1,-1($17)
+        stb     $1,-1($16)
+        br      $dest_0mod32
+
+J$H02:
+        ldh     $1,-2($17)
+        sth     $1,-2($16)
+        br      $dest_0mod32
+
+J$H03:
+        ldh     $1,-2($17)
+        ldbu    $2,-3($17)
+        sth     $1,-2($16)
+        stb     $2,-3($16)
+        br      $dest_0mod32
+
+J$H04:
+        ldw     $1,-4($17)
+        stw     $1,-4($16)
+        br      $dest_0mod32
+
+J$H05:
+        ldw     $1,-4($17)
+        ldbu    $2,-5($17)
+        stw     $1,-4($16)
+        stb     $2,-5($16)
+        br      $dest_0mod32
+
+J$H06:
+        ldw     $1,-4($17)
+        ldh     $2,-6($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+        br      $dest_0mod32
+
+J$H07:
+        ldw     $1,-4($17)
+        ldh     $2,-6($17)
+        ldbu    $3,-7($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+        stb     $3,-7($16)
+        br      $dest_0mod32
+
+J$H08:
+        ldl     $1,-8($17)
+        stl     $1,-8($16)
+        br      $dest_0mod32
+
+J$H09:
+        ldl     $1,-8($17)
+        ldbu    $2,-9($17)
+        stl     $1,-8($16)
+        stb     $2,-9($16)
+        br      $dest_0mod32
+
+J$H10:
+        ldl     $1,-8($17)
+        ldh     $2,-10($17)
+        stl     $1,-8($16)
+        sth     $2,-10($16)
+        br      $dest_0mod32
+
+J$H11:
+        ldl     $1,-8($17)
+        ldh     $2,-10($17)
+        ldbu    $3,-11($17)
+        stl     $1,-8($16)
+        sth     $2,-10($16)
+        stb     $3,-11($16)
+        br      $dest_0mod32
+
+J$H12:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+        br      $dest_0mod32
+
+J$H13:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+        ldbu    $3,-13($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+        stb     $3,-13($16)
+        br      $dest_0mod32
+
+J$H14:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+        ldh     $3,-14($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+        sth     $3,-14($16)
+        br      $dest_0mod32
+
+J$H15:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+        ldh     $3,-14($17)
+        ldbu    $4,-15($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+        sth     $3,-14($16)
+        stb     $4,-15($16)
+        br      $dest_0mod32
+
+J$H16:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        br      $dest_0mod32
+
+J$H17:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldbu    $3,-17($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stb     $3,-17($16)
+        br      $dest_0mod32
+J$H18:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldh     $3,-18($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        sth     $3,-18($16)
+        br      $dest_0mod32
+
+J$H19:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldh     $3,-18($17)
+        ldbu    $4,-19($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        sth     $3,-18($16)
+        stb     $4,-19($16)
+        br      $dest_0mod32
+
+J$H20:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+        br      $dest_0mod32
+
+J$H21:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+        ldbu    $4,-21($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+        stb     $4,-21($16)
+        br      $dest_0mod32
+
+J$H22:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+        ldh     $4,-22($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+        sth     $4,-22($16)
+        br      $dest_0mod32
+
+J$H23:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+        ldh     $4,-22($17)
+        ldbu    $5,-23($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+        sth     $4,-22($16)
+        stb     $5,-23($16)
+        br      $dest_0mod32
+J$H24:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        br      $dest_0mod32
+
+J$H25:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldbu    $4,-25($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stb     $4,-25($16)
+        br      $dest_0mod32
+
+J$H26:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldh     $4,-26($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        sth     $4,-26($16)
+        br      $dest_0mod32
+
+J$H27:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldh     $4,-26($17)
+        ldbu    $5,-27($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        sth     $4,-26($16)
+        stb     $5,-27($16)
+        br      $dest_0mod32
+
+J$H28:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+        br      $dest_0mod32
+
+J$H29:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+        ldbu    $5,-29($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+        stb     $5,-29($16)
+        br      $dest_0mod32
+
+J$H30:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+        ldh     $5,-30($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+        sth     $5,-30($16)
+        br      $dest_0mod32
+
+J$H31:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+        ldh     $5,-30($17)
+        ldbu    $6,-31($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+        sth     $5,-30($16)
+        stb     $6,-31($16)
+        br      $dest_0mod32
+
+
+END(memcpy)
+libc_hidden_builtin_def (memcpy)
+
+        .end memcpy
+
+#endif
+
+
+
diff --git a/sysdeps/sw_64/sw6a/memset.S b/sysdeps/sw_64/sw6a/memset.S
new file mode 100644
index 00000000..d903221c
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/memset.S
@@ -0,0 +1,453 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifdef __sw_64_sw6a__
+
+#include <sysdep.h>
+
+	.arch sw6a
+	.set noat
+	.set noreorder
+
+#ifndef STRING_OPT
+ENTRY(memset)
+#ifdef PROF
+        ldgp    gp, 0(pv)
+        ldi     AT, _mcount
+        call    AT, (AT), _mcount
+        .prologue 1
+#else
+        .prologue 0
+#endif
+
+        /*
+         * Serious stalling happens.  The only way to mitigate this is to
+         * undertake a major re-write to interleave the constant materialization
+         * with other parts of the fall-through code.  This is important, even
+         * though it makes maintenance tougher.
+         * Do this later.
+         */
+        and     $17, 255, $1    # E : 00000000000000ch
+        ins0b   $17, 1, $2      # U : 000000000000ch00
+        mov     $16, $0         # E : return value
+        ble     $18, $end       # U : zero length requested?
+
+        addl    $18, $16, $6    # E : max address to write to
+        or      $1, $2, $17     # E : 000000000000chch
+        ins0b   $1, 2, $3       # U : 0000000000ch0000
+        ins0b   $1, 3, $4       # U : 00000000ch000000
+
+        or      $3, $4, $3      # E : 00000000chch0000
+        ins1b   $17, 4, $5      # U : 0000chch00000000
+        xor     $16, $6, $1     # E : will complete write be within one quadword?
+        ins1b   $17, 6, $2      # U : chch000000000000
+
+        or      $17, $3, $17    # E : 00000000chchchch
+        or      $2, $5, $2      # E : chchchch00000000
+        bic     $1, 7, $1       # E : fit within a single quadword?
+        and     $16, 7, $3      # E : Target addr misalignment
+
+        or      $17, $2, $17    # E : chchchchchchchch
+        beq     $1, $within_quad # U :
+        nop                     # E :
+        beq     $3, $aligned    # U : target is 0mod8
+
+        /*
+         * Target address is misaligned, and won't fit within a quadword.
+         */
+        ldl_u   $4, 0($16)      # L : Fetch first partial
+        mov     $16, $5         # E : Save the address
+        ins3b   $17, $16, $2    # U : Insert new bytes
+        subl    $3, 8, $3       # E : Invert (for addressing uses)
+
+        addl    $18, $3, $18    # E : $18 is new count ($3 is negative)
+        mask3b  $4, $16, $4     # U : clear relevant parts of the quad
+        subl    $16, $3, $16    # E : $16 is new aligned destination
+        or      $2, $4, $1      # E : Final bytes
+
+        nop
+        stl_u   $1,0($5)        # L : Store result
+        nop
+        nop
+
+        .align 4
+$aligned:
+        /*
+         * We are now guaranteed to be quad aligned, with at least
+         * one partial quad to write.
+         */
+
+        sra     $18, 3, $3      # U : Number of remaining quads to write
+        and     $18, 7, $18     # E : Number of trailing bytes to write
+        mov     $16, $5         # E : Save dest address
+        beq     $3, $no_quad    # U : tail stuff only
+
+        /*
+         * It's worth the effort to unroll this and use wh64 if possible.
+         * At this point, entry values are:
+         * $16  Current destination address
+         * $5   A copy of $16
+         * $6   The max quadword address to write to
+         * $18  Number trailer bytes
+         * $3   Number quads to write
+         */
+        and     $16, 0x3f, $2   # E : Forward work (only useful for unrolled loop)
+        subl    $3, 16, $4      # E : Only try to unroll if > 128 bytes
+        subl    $2, 0x40, $1    # E : bias counter (aligning stuff 0mod64)
+        blt     $4, $loop       # U :
+
+        /*
+         * We know we've got at least 16 quads, minimum of one trip
+         * through unrolled loop.  Do a quad at a time to get us 0mod64
+         * aligned.
+         */
+
+        nop                     # E :
+        nop                     # E :
+        nop                     # E :
+        beq     $1, $bigalign   # U :
+$alignmod32:
+        stl     $17, 0($5)      # L :
+        subl    $3, 1, $3       # E : For consistency later
+        addl    $1, 8, $1       # E : Increment towards zero for alignment
+        addl    $5, 8, $4       # E : Initial wh64 address (filler instruction)
+
+        nop
+        nop
+        addl    $5, 8, $5       # E : Inc address
+        blt     $1, $alignmod32 # U :
+
+$bigalign:
+        /*
+         * $3 - number quads left to go
+         * $5 - target address (aligned 0mod64)
+         * $17 - mask of stuff to store
+         * Scratch registers available: $7, $2, $4, $1
+         * We know that we'll be taking a minimum of one trip through.
+         * CWG Section 3.7.6: do not expect a sustained store rate of > 1/cycle
+         * Assumes the wh64 needs to be for 2 trips through the loop in the future.
+         * The wh64 is issued on for the starting destination address for trip +2
+         * through the loop, and if there are less than two trips left, the target
+         * address will be for the current trip.
+         */
+
+$do_wh64:
+        wh64    ($4)            # L1 : memory subsystem write hint
+        subl    $3, 24, $2      # E : For determining future wh64 addresses
+        stl     $17, 0($5)      # L :
+        nop                     # E :
+
+        addl    $5, 128, $4     # E : speculative target of next wh64
+        stl     $17, 8($5)      # L :
+        stl     $17, 16($5)     # L :
+        addl    $5, 64, $7      # E : Fallback address for wh64 (== next trip addr)
+
+        stl     $17, 24($5)     # L :
+        stl     $17, 32($5)     # L :
+        sellt   $2, $7, $4, $4  # E : Latency 2, extra mapping cycle
+        nop
+
+        stl     $17, 40($5)     # L :
+        stl     $17, 48($5)     # L :
+        subl    $3, 16, $2      # E : Repeat the loop at least once more?
+        nop
+
+        stl     $17, 56($5)     # L :
+        addl    $5, 64, $5      # E :
+        subl    $3, 8, $3       # E :
+        bge     $2, $do_wh64    # U :
+
+        nop
+        nop
+        nop
+        beq     $3, $no_quad    # U : Might have finished already
+
+        .align 4
+        /*
+         * Simple loop for trailing quadwords, or for small amounts
+         * of data (where we can't use an unrolled loop and wh64)
+         */
+$loop:
+        stl     $17, 0($5)      # L :
+        subl    $3, 1, $3       # E : Decrement number quads left
+        addl    $5, 8, $5       # E : Inc address
+        bne     $3, $loop       # U : more?
+
+$no_quad:
+        /*
+         * Write 0..7 trailing bytes.
+         */
+        nop                     # E :
+        beq     $18, $end       # U : All done?
+        ldl     $7, 0($5)       # L :
+        mask7b  $7, $6, $2      # U : Mask final quad
+
+        ins7b   $17, $6, $4     # U : New bits
+        or      $2, $4, $1      # E : Put it all together
+        stl     $1, 0($5)       # L : And back to memory
+        ret     $31,($26),1     # L0 :
+
+$within_quad:
+        ldl_u   $1, 0($16)      # L :
+        ins3b   $17, $16, $2    # U : New bits
+        mask3b  $1, $16, $4     # U : Clear old
+        or      $2, $4, $2      # E : New result
+
+        mask3b  $2, $6, $4      # U :
+        mask7b  $1, $6, $2      # U :
+        or      $2, $4, $1      # E :
+        stl_u   $1, 0($16)      # L :
+
+$end:
+        nop
+        nop
+        nop
+        ret $31,($26),1         # L0 :
+
+        END(memset)
+libc_hidden_builtin_def (memset)
+
+#else
+ENTRY(memset)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	/*
+	 * Serious stalling happens.  The only way to mitigate this is to
+	 * undertake a major re-write to interleave the constant materialization
+	 * with other parts of the fall-through code.  This is important, even
+	 * though it makes maintenance tougher.
+	 * Do this later.
+	 */
+	and	$17, 255, $1	# E : 00000000000000ch
+	ins0b	$17, 1, $2	# U : 000000000000ch00
+	mov	$16, $0		# E : return value
+	ble	$18, $end	# U : zero length requested?
+
+	addl	$18, $16, $6	# E : max address to write to
+	or	$1, $2, $17	# E : 000000000000chch
+	ins0b	$1, 2, $3	# U : 0000000000ch0000
+	ins0b	$1, 3, $4	# U : 00000000ch000000
+
+	or	$3, $4, $3	# E : 00000000chch0000
+	ins1b	$17, 4, $5	# U : 0000chch00000000
+	xor	$16, $6, $1	# E : will complete write be within one quadword?
+	ins1b	$17, 6, $2	# U : chch000000000000
+
+	or	$17, $3, $17	# E : 00000000chchchch
+	or	$2, $5, $2	# E : chchchch00000000
+	bic	$1, 7, $1	# E : fit within a single quadword?
+	and	$16, 7, $3	# E : Target addr misalignment
+
+	or	$17, $2, $17	# E : chchchchchchchch
+	beq	$1, $within_quad # U :
+	nop			# E :
+	beq	$3, $aligned	# U : target is 0mod8
+
+	/*
+	 * Target address is misaligned, and won't fit within a quadword.
+	 */
+	ldl_u	$4, 0($16)	# L : Fetch first partial
+	mov	$16, $5		# E : Save the address
+	ins3b	$17, $16, $2	# U : Insert new bytes
+	subl	$3, 8, $3	# E : Invert (for addressing uses)
+
+	addl	$18, $3, $18	# E : $18 is new count ($3 is negative)
+	mask3b	$4, $16, $4	# U : clear relevant parts of the quad
+	subl	$16, $3, $16	# E : $16 is new aligned destination
+	or	$2, $4, $1	# E : Final bytes
+
+	nop
+	stl_u	$1,0($5)	# L : Store result
+	nop
+	nop
+
+	.align 4
+$aligned:
+	/*
+	 * We are now guaranteed to be quad aligned, with at least
+	 * one partial quad to write.
+	 */
+
+	sra	$18, 3, $3	# U : Number of remaining quads to write
+	and	$18, 7, $18	# E : Number of trailing bytes to write
+	mov	$16, $5		# E : Save dest address
+	beq	$3, $no_quad	# U : tail stuff only
+
+	/*
+	 * It's worth the effort to unroll this and use wh64 if possible.
+	 * At this point, entry values are:
+	 * $16	Current destination address
+	 * $5	A copy of $16
+	 * $6	The max quadword address to write to
+	 * $18	Number trailer bytes
+	 * $3	Number quads to write
+	 */
+#ifdef HUANGLM20161111
+	and	$16, 0x3f, $2	# E : Forward work (only useful for unrolled loop)
+#else 
+	and	$16, 0x1f, $2	# E : Forward work (only useful for unrolled loop) : aligned low 63 bits
+#endif 
+	subl	$3, 16, $4	# E : Only try to unroll if > 128 bytes
+	subl	$2, 0x40, $1	# E : bias counter (aligning stuff 0mod64)
+	blt	$4, $loop	# U :
+
+	/*
+	 * We know we've got at least 16 quads, minimum of one trip
+	 * through unrolled loop.  Do a quad at a time to get us 0mod64
+	 * aligned.
+	 */
+
+	nop			# E :
+	nop			# E :
+	nop			# E :
+#ifdef HUANGLM20161111
+	beq	$1, $bigalign	# U :
+#else
+	beq	$2, $bigalign
+#endif 
+$alignmod32:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : For consistency later
+	addl	$1, 8, $1	# E : Increment towards zero for alignment
+	addl	$5, 8, $4	# E : Initial wh64 address (filler instruction)
+
+	nop
+	nop
+	addl	$5, 8, $5	# E : Inc address
+	blt	$1, $alignmod32 # U :
+
+$bigalign:
+	/*
+	 * $3 - number quads left to go
+	 * $5 - target address (aligned 0mod64)
+	 * $17 - mask of stuff to store
+	 * Scratch registers available: $7, $2, $4, $1
+	 * We know that we'll be taking a minimum of one trip through.
+	 * CWG Section 3.7.6: do not expect a sustained store rate of > 1/cycle
+	 * Assumes the wh64 needs to be for 2 trips through the loop in the future.
+	 * The wh64 is issued on for the starting destination address for trip +2
+	 * through the loop, and if there are less than two trips left, the target
+	 * address will be for the current trip.
+	 */
+
+#ifndef HUANGLM20161111
+	nop
+	nop
+	ifmovs $17, $f1
+	vcpyw $f1, $f1
+#endif
+
+$do_wh64:
+#ifdef HUANGLM20161111
+	wh64	($4)		# L1 : memory subsystem write hint
+	subq	$3, 24, $2	# E : For determining future wh64 addresses
+	stq	$17, 0($5)	# L :
+	nop			# E :
+
+	addq	$5, 128, $4	# E : speculative target of next wh64
+	stq	$17, 8($5)	# L :
+	stq	$17, 16($5)	# L :
+	addq	$5, 64, $7	# E : Fallback address for wh64 (== next trip addr)
+
+	stq	$17, 24($5)	# L :
+	stq	$17, 32($5)	# L :
+	cmovlt	$2, $7, $4	# E : Latency 2, extra mapping cycle
+	nop
+
+	stq	$17, 40($5)	# L :
+	stq	$17, 48($5)	# L :
+	subq	$3, 16, $2	# E : Repeat the loop at least once more?
+	nop
+
+	stq	$17, 56($5)	# L :
+	addq	$5, 64, $5	# E :
+	subq	$3, 8, $3	# E :
+#else
+	fillde	128*4($5)
+	subl	$3, 16, $2
+	vstd 	$f1, 0($5)
+	vstd 	$f1, 32($5)
+
+	subl	$3, 8, $3
+	addl	$5, 64, $5
+	nop
+#endif
+	bge	$2, $do_wh64	# U :
+
+	nop
+	nop
+	nop
+	beq	$3, $no_quad	# U : Might have finished already
+
+	.align 4
+	/*
+	 * Simple loop for trailing quadwords, or for small amounts
+	 * of data (where we can't use an unrolled loop and wh64)
+	 */
+$loop:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : Decrement number quads left
+	addl	$5, 8, $5	# E : Inc address
+	bne	$3, $loop	# U : more?
+
+$no_quad:
+	/*
+	 * Write 0..7 trailing bytes.
+	 */
+	nop			# E :
+	beq	$18, $end	# U : All done?
+	ldl	$7, 0($5)	# L :
+	mask7b	$7, $6, $2	# U : Mask final quad
+
+	ins7b	$17, $6, $4	# U : New bits
+	or	$2, $4, $1	# E : Put it all together
+	stl	$1, 0($5)	# L : And back to memory
+	ret	$31,($26),1	# L0 :
+
+$within_quad:
+	ldl_u	$1, 0($16)	# L :
+	ins3b	$17, $16, $2	# U : New bits
+	mask3b	$1, $16, $4	# U : Clear old
+	or	$2, $4, $2	# E : New result
+
+	mask3b	$2, $6, $4	# U :
+	mask7b	$1, $6, $2	# U :
+	or	$2, $4, $1	# E :
+	stl_u	$1, 0($16)	# L :
+
+$end:
+	nop
+	nop
+	nop
+	ret $31,($26),1		# L0 :
+
+	END(memset)
+libc_hidden_builtin_def (memset)
+#endif //STRING_OPT
+#else
+#include <sysdeps/sw_64/memset.S>
+
+#endif
diff --git a/sysdeps/sw_64/sw6a/rshift.S b/sysdeps/sw_64/sw6a/rshift.S
new file mode 100644
index 00000000..2a020414
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/rshift.S
@@ -0,0 +1,170 @@
+ # Sw_64 EV5 __mpn_rshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 3.25 cycles/limb on the EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_rshift
+	.ent	__mpn_rshift
+__mpn_rshift:
+	.frame	$30,0,$26,0
+
+	ldl	$4,0($17)	# load first limb
+	subl	$31,$19,$20
+	subl	$18,1,$18
+	and	$18,4-1,$28	# number of limbs in first loop
+	sll	$4,$20,$0	# compute function result
+
+	beq	$28,.L0
+	subl	$18,$28,$18
+
+	.align	3
+.Loop0:	ldl	$3,8($17)
+	addl	$16,8,$16
+	srl	$4,$19,$5
+	addl	$17,8,$17
+	subl	$28,1,$28
+	sll	$3,$20,$6
+	or	$3,$3,$4
+	or	$5,$6,$8
+	stl	$8,-8($16)
+	bne	$28,.Loop0
+
+.L0:	srl	$4,$19,$24
+	beq	$18,.Lend
+ # warm up phase 1
+	ldl	$1,8($17)
+	subl	$18,4,$18
+	ldl	$2,16($17)
+	ldl	$3,24($17)
+	ldl	$4,32($17)
+	beq	$18,.Lend1
+ # warm up phase 2
+	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	ldl	$1,40($17)
+	srl	$2,$19,$22
+	ldl	$2,48($17)
+	sll	$3,$20,$5
+	or	$7,$24,$7
+	srl	$3,$19,$23
+	or	$8,$21,$8
+	sll	$4,$20,$6
+	ldl	$3,56($17)
+	srl	$4,$19,$24
+	ldl	$4,64($17)
+	subl	$18,4,$18
+	beq	$18,.Lend2
+	.align  4
+ # main loop
+.Loop:	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+
+	sll	$1,$20,$7
+	subl	$18,4,$18
+	srl	$1,$19,$21
+	unop	# ldl	$31,-96($17)
+
+	sll	$2,$20,$8
+	ldl	$1,72($17)
+	srl	$2,$19,$22
+	ldl	$2,80($17)
+
+	stl	$5,16($16)
+	or	$7,$24,$7
+	stl	$6,24($16)
+	or	$8,$21,$8
+
+	sll	$3,$20,$5
+	unop	# ldl	$31,-96($17)
+	srl	$3,$19,$23
+	addl	$16,32,$16
+
+	sll	$4,$20,$6
+	ldl	$3,88($17)
+	srl	$4,$19,$24
+	ldl	$4,96($17)
+
+	addl	$17,32,$17
+	bne	$18,.Loop
+ # cool down phase 2/1
+.Lend2:	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	srl	$2,$19,$22
+	stl	$5,16($16)
+	or	$7,$24,$7
+	stl	$6,24($16)
+	or	$8,$21,$8
+	sll	$3,$20,$5
+	srl	$3,$19,$23
+	sll	$4,$20,$6
+	srl	$4,$19,$24
+ # cool down phase 2/2
+	stl	$7,32($16)
+	or	$5,$22,$5
+	stl	$8,40($16)
+	or	$6,$23,$6
+	stl	$5,48($16)
+	stl	$6,56($16)
+ # cool down phase 2/3
+	stl	$24,64($16)
+	ret	$31,($26),1
+
+ # cool down phase 1/1
+.Lend1:	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	srl	$2,$19,$22
+	sll	$3,$20,$5
+	or	$7,$24,$7
+	srl	$3,$19,$23
+	or	$8,$21,$8
+	sll	$4,$20,$6
+	srl	$4,$19,$24
+ # cool down phase 1/2
+	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+	stl	$5,16($16)
+	stl	$6,24($16)
+	stl	$24,32($16)
+	ret	$31,($26),1
+
+.Lend:	stl	$24,0($16)
+	ret	$31,($26),1
+	.end	__mpn_rshift
diff --git a/sysdeps/sw_64/sw6a/stxcpy.S b/sysdeps/sw_64/sw6a/stxcpy.S
new file mode 100644
index 00000000..12d59b27
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/stxcpy.S
@@ -0,0 +1,314 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy a null-terminated string from SRC to DST.
+
+   This is an internal routine used by strcpy, stpcpy, and strcat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+
+   On output:
+	t8  = bitmask (with one bit set) indicating the last byte written
+	a0  = unaligned address of the last *word* written
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+
+#include <sysdep.h>
+
+	.arch sw6a
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxcpy, @function
+	.globl	__stxcpy
+	.usepv	__stxcpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 4
+stxcpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# E : build a mask against false zero
+	mask7b	t2, a1, t2	# U :   detection in the src word (stall)
+	mask7b	t1, a1, t3	# U :
+	ornot	t1, t2, t2	# E : (stall)
+
+	mask3b	t0, a1, t0	# U : assemble the first output word
+	cmpgeb	zero, t2, t10	# E : bits set iff null found
+	or	t0, t3, t1	# E : (stall)
+	bne	t10, $a_eos	# U : (stall)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == a source word not containing a null.  */
+	/* Nops here to separate store quads from load quads */
+
+$a_loop:
+	stl_u	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	nop
+	nop
+
+	ldl_u	t1, 0(a1)	# L : Latency=3
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t10	# E : (3 cycle stall)
+	beq	t10, $a_loop	# U : (stall for t10)
+
+	/* Take care of the final (partial) word store.
+	   On entry to this basic block we have:
+	   t1 == the source word containing the null
+	   t10 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t10, t6		# E : find low bit set
+	and	t10, t6, t8	# E : (stall)
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t0, 0(a0)	# L : Latency=3
+	subl	t8, 1, t6	# E :
+	zapnot	t1, t6, t1	# U : clear src bytes >= null (stall)
+	or	t8, t6, t10	# E : (stall)
+
+	zap	t0, t10, t0	# E : clear dst bytes <= null
+	or	t0, t1, t1	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t1, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	.align 4
+__stxcpy:
+	/* Are source and destination co-aligned?  */
+	xor	a0, a1, t0	# E :
+	unop			# E :
+	and	t0, 7, t0	# E : (stall)
+	bne	t0, $unaligned	# U : (stall)
+
+	/* We are co-aligned; take care of a partial first word.  */
+	ldl_u	t1, 0(a1)		# L : load first src word
+	and	a0, 7, t0		# E : take care not to load a word ...
+	addl	a1, 8, a1		# E :
+	beq	t0, stxcpy_aligned	# U : ... if we wont need it (stall)
+
+	ldl_u	t0, 0(a0)	# L :
+	br	stxcpy_aligned	# L0 : Latency=3
+	nop
+	nop
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 4
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, for masking back in, if needed else 0
+	   t1 == the low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# L :
+	addl	a1, 8, a1	# E :
+	ext3b	t1, a1, t1	# U : (stall on a1)
+	ext7b	t2, a1, t4	# U : (stall on a1)
+
+	mask3b	t0, a0, t0	# U :
+	or	t1, t4, t1	# E :
+	mask7b	t1, a0, t1	# U : (stall on t1)
+	or	t0, t1, t1	# E : (stall on t1)
+
+	or	t1, t6, t6	# E :
+	cmpgeb	zero, t6, t10	# E : (stall)
+	ldi	t6, -1		# E : for masking just below
+	bne	t10, $u_final	# U : (stall)
+
+	mask3b	t6, a1, t6		# U : mask out the bits we have
+	or	t6, t2, t2		# E :   already extracted before (stall)
+	cmpgeb	zero, t2, t10		# E :   testing eos (stall)
+	bne	t10, $u_late_head_exit	# U : (stall)
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+
+	stl_u	t1, 0(a0)	# L : store first output word
+	addl	a0, 8, a0	# E :
+	ext3b	t2, a1, t0	# U : position ho-bits of lo word
+	ldl_u	t2, 8(a1)	# U : read next high-order source word
+
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t2, t10	# E : (stall for t2)
+	nop			# E :
+	bne	t10, $u_eos	# U : (stall)
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 3
+$u_loop:
+	ext7b	t2, a1, t1	# U : extract high bits for current word
+	addl	a1, 8, a1	# E : (stall)
+	ext3b	t2, a1, t3	# U : extract low bits for next time (stall)
+	addl	a0, 8, a0	# E :
+
+	or	t0, t1, t1	# E : current dst word now complete
+	ldl_u	t2, 0(a1)	# L : Latency=3 load high word for next time
+	stl_u	t1, -8(a0)	# L : save the current word (stall)
+	mov	t3, t0		# E :
+
+	cmpgeb	zero, t2, t10	# E : test new word for eos
+	beq	t10, $u_loop	# U : (stall)
+	nop
+	nop
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	ext7b	t2, a1, t1	# U :
+	or	t0, t1, t1	# E : first (partial) source word complete (stall)
+	cmpgeb	zero, t1, t10	# E : is the null in this first bit? (stall)
+	bne	t10, $u_final	# U : (stall)
+
+$u_late_head_exit:
+	stl_u	t1, 0(a0)	# L : the null was in the high-order bits
+	addl	a0, 8, a0	# E :
+	ext3b	t2, a1, t1	# U :
+	cmpgeb	zero, t1, t10	# E : (stall)
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t1 == assembled source word
+	   t10 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t10, t6		# E : isolate low bit set
+	and	t6, t10, t8	# E : (stall)
+	and	t8, 0x80, t6	# E : avoid dest word load if we can (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t0, 0(a0)	# E :
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t10	# E : (stall)
+	zapnot	t1, t6, t1	# U : kill source bytes >= null (stall)
+
+	zap	t0, t10, t0	# U : kill dest bytes <= null (2 cycle data stall)
+	or	t0, t1, t1	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t1, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	/* Unaligned copy entry point.  */
+	.align 4
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# L : load first source word
+	and	a0, 7, t4	# E : find dest misalignment
+	and	a1, 7, t5	# E : find src misalignment
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+	mov	zero, t0	# E :
+
+	mov	zero, t6	# E :
+	beq	t4, 1f		# U :
+	ldl_u	t0, 0(a0)	# L :
+	ldi	t6, -1		# E :
+
+	mask3b	t6, a0, t6	# U :
+	nop
+	nop
+	nop
+1:
+	subl	a1, t4, a1	# E : sub dest misalignment from src addr
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+	cmplt	t4, t5, t8	# E :
+	beq	t8, $u_head	# U :
+	ldi	t2, -1		# E : mask out leading garbage in source
+
+	mask7b	t2, t5, t2	# U :
+	ornot	t1, t2, t3	# E : (stall)
+	cmpgeb	zero, t3, t10	# E : is there a zero? (stall)
+	beq	t10, $u_head	# U : (stall)
+
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+
+	ldl_u	t0, 0(a0)	# L :
+	negl	t10, t6		# E : build bitmask of bytes <= zero
+	and	t6, t10, t8	# E : (stall)
+	and	a1, 7, t5	# E :
+
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t10	# E : (stall)
+	srl	t8, t5, t8	# U : adjust final null return value
+	zapnot	t2, t10, t2	# U : prepare source word; mirror changes (stall)
+
+	and	t1, t2, t1	# E : to source validity mask
+	ext3b	t2, a1, t2	# U :
+	ext3b	t1, a1, t1	# U : (stall)
+	andnot	t0, t2, t0	# .. e1 : zero place for source to reside (stall)
+
+	or	t0, t1, t1	# e1    : and put it there
+	stl_u	t1, 0(a0)	# .. e0 : (stall)
+	ret	(t9)		# e1    :
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/sw6a/stxncpy.S b/sysdeps/sw_64/sw6a/stxncpy.S
new file mode 100644
index 00000000..f56437b7
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/stxncpy.S
@@ -0,0 +1,392 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy no more than COUNT bytes of the null-terminated string from
+   SRC to DST.
+
+   This is an internal routine used by strncpy, stpncpy, and strncat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+	a2 = COUNT
+
+   Furthermore, COUNT may not be zero.
+
+   On output:
+	t0  = last word written
+	t8  = bitmask (with one bit set) indicating the last byte written
+	t10 = bitmask (with one bit set) indicating the byte position of
+	      the end of the range specified by COUNT
+	a0  = unaligned address of the last *word* written
+	a2  = the number of full words left in COUNT
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+#include <sysdep.h>
+
+	.arch sw6a
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxncpy, @function
+	.globl	__stxncpy
+	.usepv	__stxncpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 4
+stxncpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# E : build a mask against false zero
+	mask7b	t2, a1, t2	# U :   detection in the src word (stall)
+	mask7b	t1, a1, t3	# U :
+	ornot	t1, t2, t2	# E : (stall)
+
+	mask3b	t0, a1, t0	# U : assemble the first output word
+	cmpgeb	zero, t2, t7	# E : bits set iff null found
+	or	t0, t3, t0	# E : (stall)
+	beq	a2, $a_eoc	# U :
+
+	bne	t7, $a_eos	# U :
+	nop
+	nop
+	nop
+
+	/* On entry to this basic block:
+	   t0 == a source word not containing a null.  */
+
+	/*
+	 * nops here to:
+	 *	separate store quads from load quads
+	 *	limit of 1 bcond/quad to permit training
+	 */
+$a_loop:
+	stl_u	t0, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+
+	ldl_u	t0, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t0, t7	# E :
+	beq	a2, $a_eoc      # U :
+
+	beq	t7, $a_loop	# U :
+	nop
+	nop
+	nop
+
+	/* Take care of the final (partial) word store.  At this point
+	   the end-of-count bit is set in t7 iff it applies.
+
+	   On entry to this basic block we have:
+	   t0 == the source word containing the null
+	   t7 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t7, t8		# E : find low bit set
+	and	t7, t8, t8	# E : (stall)
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t1, 0(a0)	# L :
+	subl	t8, 1, t6	# E :
+	or	t8, t6, t7	# E : (stall)
+	zapnot	t0, t7, t0	# U : clear src bytes > null (stall)
+
+	zap	t1, t7, t1	# .. e1 : clear dst bytes <= null
+	or	t0, t1, t0	# e1    : (stall)
+	nop
+	nop
+
+1:	stl_u	t0, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	/* Add the end-of-count bit to the eos detection bitmask.  */
+$a_eoc:
+	or	t10, t7, t7	# E :
+	br	$a_eos		# L0 : Latency=3
+	nop
+	nop
+
+	.align 4
+__stxncpy:
+	/* Are source and destination co-aligned?  */
+	ldi	t2, -1		# E :
+	xor	a0, a1, t1	# E :
+	and	a0, 7, t0	# E : find dest misalignment
+	nop			# E :
+
+	srl	t2, 1, t2	# U :
+	and	t1, 7, t1	# E :
+	sellt	a2, t2, a2, a2	# E : bound count to LONG_MAX (stall)
+	nop			# E :
+
+	addl	a2, t0, a2	# E : bias count by dest misalignment
+	subl	a2, 1, a2	# E : (stall)
+	and	a2, 7, t2	# E : (stall)
+	ldi	t10, 1		# E :
+
+	srl	a2, 3, a2	# U : a2 = loop counter = (count - 1)/8
+	sll	t10, t2, t10	# U : t10 = bitmask of last count byte
+	nop			# E :
+	bne	t1, $unaligned	# U : (stall)
+
+	/* We are co-aligned; take care of a partial first word.  */
+	ldl_u	t1, 0(a1)	# L : load first src word
+	addl	a1, 8, a1	# E :
+	beq	t0, stxncpy_aligned # U : avoid loading dest word if not needed
+	ldl_u	t0, 0(a0)	# L :
+
+	br	stxncpy_aligned	# U :
+	nop
+	nop
+	nop
+
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 4
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, unmasked
+	   t1 == the shifted low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# L : Latency=3 load second src word
+	addl	a1, 8, a1	# E :
+	mask3b	t0, a0, t0	# U : mask trailing garbage in dst
+	ext7b	t2, a1, t4	# U : (3 cycle stall on t2)
+
+	or	t1, t4, t1	# E : first aligned src word complete (stall)
+	mask7b	t1, a0, t1	# U : mask leading garbage in src (stall)
+	or	t0, t1, t0	# E : first output word complete (stall)
+	or	t0, t6, t6	# E : mask original data for zero test (stall)
+
+	cmpgeb	zero, t6, t7	# E :
+	beq	a2, $u_eocfin	# U :
+	ldi	t6, -1		# E :
+	nop
+
+	bne	t7, $u_final	# U :
+	mask3b	t6, a1, t6	# U : mask out bits already seen
+	stl_u	t0, 0(a0)	# L : store first output word
+	or      t6, t2, t2	# E :
+
+	cmpgeb	zero, t2, t7	# E : find nulls in second partial
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	bne	t7, $u_late_head_exit	# U :
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+	ext3b	t2, a1, t1	# U : position hi-bits of lo word
+	beq	a2, $u_eoc	# U :
+	ldl_u	t2, 8(a1)	# L : read next high-order source word
+	addl	a1, 8, a1	# E :
+
+	ext7b	t2, a1, t0	# U : position lo-bits of hi word (stall)
+	cmpgeb	zero, t2, t7	# E :
+	nop
+	bne	t7, $u_eos	# U :
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 4
+$u_loop:
+	or	t0, t1, t0	# E : current dst word now complete
+	subl	a2, 1, a2	# E : decrement word count
+	ext3b	t2, a1, t1	# U : extract high bits for next time
+	addl	a0, 8, a0	# E :
+
+	stl_u	t0, -8(a0)	# L : save the current word
+	beq	a2, $u_eoc	# U :
+	ldl_u	t2, 8(a1)	# L : Latency=3 load high word for next time
+	addl	a1, 8, a1	# E :
+
+	ext7b	t2, a1, t0	# U : extract low bits (2 cycle stall)
+	cmpgeb	zero, t2, t7	# E : test new word for eos
+	nop
+	beq	t7, $u_loop	# U :
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	or	t0, t1, t0	# E : first (partial) source word complete
+	nop
+	cmpgeb	zero, t0, t7	# E : is the null in this first bit? (stall)
+	bne	t7, $u_final	# U : (stall)
+
+	stl_u	t0, 0(a0)	# L : the null was in the high-order bits
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+
+$u_late_head_exit:
+	ext3b	t2, a1, t0	# U :
+	cmpgeb	zero, t0, t7	# E :
+	or	t7, t10, t6	# E : (stall)
+	seleq	a2, t6, t7, t7	# E : Latency=2, extra map slot (stall)
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t0 == assembled source word
+	   t7 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t7, t6		# E : isolate low bit set
+	and	t6, t7, t8	# E : (stall)
+	and	t8, 0x80, t6	# E : avoid dest word load if we can (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t1, 0(a0)	# L :
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t7	# E : (stall)
+	zapnot	t0, t7, t0	# U : kill source bytes > null
+
+	zap	t1, t7, t1	# U : kill dest bytes <= null
+	or	t0, t1, t0	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t0, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+
+        /* Got to end-of-count before end of string.
+           On entry to this basic block:
+           t1 == the shifted high-order bits from the previous source word  */
+$u_eoc:
+	and	a1, 7, t6	# E :
+	sll	t10, t6, t6	# U : (stall)
+	and	t6, 0xff, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t2, 8(a1)	# L : load final src word
+	nop
+	ext7b	t2, a1, t0	# U : extract low bits for last word (stall)
+	or	t1, t0, t1	# E : (stall)
+
+1:	cmpgeb	zero, t1, t7	# E :
+	mov	t1, t0
+
+$u_eocfin:			# end-of-count, final word
+	or	t10, t7, t7	# E :
+	br	$u_final	# L0 : Latency=3
+
+	/* Unaligned copy entry point.  */
+	.align 4
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# L : load first source word
+	and	a0, 7, t4	# E : find dest misalignment
+	and	a1, 7, t5	# E : find src misalignment
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+	mov	zero, t0	# E :
+
+	mov	zero, t6	# E :
+	beq	t4, 1f		# U :
+	ldl_u	t0, 0(a0)	# L :
+	ldi	t6, -1		# E :
+
+	mask3b	t6, a0, t6	# U :
+	nop
+	nop
+1:	subl	a1, t4, a1	# E : sub dest misalignment from src addr
+
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+
+	cmplt	t4, t5, t8	# E :
+	ext3b	t1, a1, t1	# U : shift src into place
+	ldi	t2, -1		# E : for creating masks later
+	beq	t8, $u_head	# U : (stall)
+
+	mask7b	t2, t5, t2	# U : begin src byte validity mask
+	cmpgeb	zero, t1, t7	# E : is there a zero?
+	ext3b	t2, a1, t2	# U :
+	or	t7, t10, t5	# E : test for end-of-count too
+
+	cmpgeb	zero, t2, t3	# E :
+	seleq	a2, t5, t7, t7	# E : Latency=2, extra map slot
+	nop			# E : keep with seleq
+	andnot	t7, t3, t7	# E : (stall)
+
+	beq	t7, $u_head	# U :
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+	ldl_u	t0, 0(a0)	# L :
+	negl	t7, t6		# E : build bitmask of bytes <= zero
+	mask7b	t1, t4, t1	# U :
+
+	and	t6, t7, t8	# E :
+	subl	t8, 1, t6	# E : (stall)
+	or	t6, t8, t7	# E : (stall)
+	zapnot	t2, t7, t2	# U : prepare source word; mirror changes (stall)
+
+	zapnot	t1, t7, t1	# U : to source validity mask
+	andnot	t0, t2, t0	# E : zero place for source to reside
+	or	t0, t1, t0	# E : and put it there (stall both t0, t1)
+	stl_u	t0, 0(a0)	# L : (stall)
+
+	ret	(t9)		# L0 : Latency=3
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/sw6a/sub_n.S b/sysdeps/sw_64/sw6a/sub_n.S
new file mode 100644
index 00000000..d7fa7a0d
--- /dev/null
+++ b/sysdeps/sw_64/sw6a/sub_n.S
@@ -0,0 +1,147 @@
+ # Sw_64 __mpn_sub_n -- Subtract two limb vectors of the same length > 0 and
+ # store difference in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_sub_n
+	.ent	__mpn_sub_n
+__mpn_sub_n:
+	.frame	$30,0,$26,0
+
+	or	$31,$31,$25		# clear cy
+	subl	$19,4,$19		# decr loop cnt
+	blt	$19,.Lend2		# if less than 4 limbs, goto 2nd loop
+ # Start software pipeline for 1st loop
+	ldl	$0,0($18)
+	ldl	$1,8($18)
+	ldl	$4,0($17)
+	ldl	$5,8($17)
+	addl	$17,32,$17		# update s1_ptr
+	ldl	$2,16($18)
+	subl	$4,$0,$20		# 1st main sub
+	ldl	$3,24($18)
+	subl	$19,4,$19		# decr loop cnt
+	ldl	$6,-16($17)
+	cmpult	$4,$20,$25		# compute cy from last sub
+	ldl	$7,-8($17)
+	addl	$1,$25,$28		# cy add
+	addl	$18,32,$18		# update s2_ptr
+	subl	$5,$28,$21		# 2nd main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	blt	$19,.Lend1		# if less than 4 limbs remain, jump
+ # 1st loop handles groups of 4 limbs in a software pipeline
+	.align	4
+.Loop:	cmpult	$5,$21,$25		# compute cy from last add
+	ldl	$0,0($18)
+	or	$8,$25,$25		# combine cy from the two fadds
+	ldl	$1,8($18)
+	addl	$2,$25,$28		# cy add
+	ldl	$4,0($17)
+	subl	$6,$28,$22		# 3rd main sub
+	ldl	$5,8($17)
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$6,$22,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	subl	$7,$28,$23		# 4th main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$7,$23,$25		# compute cy from last add
+	addl	$17,32,$17		# update s1_ptr
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	addl	$0,$25,$28		# cy add
+	ldl	$2,16($18)
+	subl	$4,$28,$20		# 1st main sub
+	ldl	$3,24($18)
+	cmpult	$28,$25,$8		# compute cy from last add
+	ldl	$6,-16($17)
+	cmpult	$4,$20,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	or	$8,$25,$25		# combine cy from the two fadds
+	subl	$19,4,$19		# decr loop cnt
+	stl	$22,-16($16)
+	addl	$1,$25,$28		# cy add
+	stl	$23,-8($16)
+	subl	$5,$28,$21		# 2nd main sub
+	addl	$18,32,$18		# update s2_ptr
+	cmpult	$28,$25,$8		# compute cy from last add
+	bge	$19,.Loop
+ # Finish software pipeline for 1st loop
+.Lend1:	cmpult	$5,$21,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$2,$25,$28		# cy add
+	subl	$6,$28,$22		# 3rd main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$6,$22,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	subl	$7,$28,$23		# 4th main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$7,$23,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	stl	$22,-16($16)
+	stl	$23,-8($16)
+.Lend2:	addl	$19,4,$19		# restore loop cnt
+	beq	$19,.Lret
+ # Start software pipeline for 2nd loop
+	ldl	$0,0($18)
+	ldl	$4,0($17)
+	subl	$19,1,$19
+	beq	$19,.Lend0
+ # 2nd loop handles remaining 1-3 limbs
+	.align	4
+.Loop0:	addl	$0,$25,$28		# cy add
+	ldl	$0,8($18)
+	subl	$4,$28,$20		# main sub
+	ldl	$1,8($17)
+	addl	$18,8,$18
+	cmpult	$28,$25,$8		# compute cy from last add
+	addl	$17,8,$17
+	stl	$20,0($16)
+	cmpult	$4,$20,$25		# compute cy from last add
+	subl	$19,1,$19		# decr loop cnt
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,8,$16
+	or	$1,$31,$4
+	bne	$19,.Loop0
+.Lend0:	addl	$0,$25,$28		# cy add
+	subl	$4,$28,$20		# main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$4,$20,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+
+.Lret:	or	$25,$31,$0		# return cy
+	ret	$31,($26),1
+	.end	__mpn_sub_n
diff --git a/sysdeps/sw_64/sw6b/Implies b/sysdeps/sw_64/sw6b/Implies
new file mode 100644
index 00000000..cc08aefa
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/Implies
@@ -0,0 +1 @@
+sw_64/sw6b
diff --git a/sysdeps/sw_64/sw6b/add_n.S b/sysdeps/sw_64/sw6b/add_n.S
new file mode 100644
index 00000000..26e9c698
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/add_n.S
@@ -0,0 +1,146 @@
+ # Sw_64 __mpn_add_n -- Add two limb vectors of the same length > 0 and
+ # store sum in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_add_n
+	.ent	__mpn_add_n
+__mpn_add_n:
+	.frame	$30,0,$26,0
+
+	or	$31,$31,$25		# clear cy
+	subl	$19,4,$19		# decr loop cnt
+	blt	$19,.Lend2		# if less than 4 limbs, goto 2nd loop
+ # Start software pipeline for 1st loop
+	ldl	$0,0($18)
+	ldl	$1,8($18)
+	ldl	$4,0($17)
+	ldl	$5,8($17)
+	addl	$17,32,$17		# update s1_ptr
+	ldl	$2,16($18)
+	addl	$0,$4,$20		# 1st main add
+	ldl	$3,24($18)
+	subl	$19,4,$19		# decr loop cnt
+	ldl	$6,-16($17)
+	cmpult	$20,$0,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	addl	$1,$25,$28		# cy add
+	addl	$18,32,$18		# update s2_ptr
+	addl	$5,$28,$21		# 2nd main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	blt	$19,.Lend1		# if less than 4 limbs remain, jump
+ # 1st loop handles groups of 4 limbs in a software pipeline
+	.align	4
+.Loop:	cmpult	$21,$28,$25		# compute cy from last add
+	ldl	$0,0($18)
+	or	$8,$25,$25		# combine cy from the two fadds
+	ldl	$1,8($18)
+	addl	$2,$25,$28		# cy add
+	ldl	$4,0($17)
+	addl	$28,$6,$22		# 3rd main add
+	ldl	$5,8($17)
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$22,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	addl	$28,$7,$23		# 4th main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$23,$28,$25		# compute cy from last add
+	addl	$17,32,$17		# update s1_ptr
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	addl	$0,$25,$28		# cy add
+	ldl	$2,16($18)
+	addl	$4,$28,$20		# 1st main add
+	ldl	$3,24($18)
+	cmpult	$28,$25,$8		# compute cy from last add
+	ldl	$6,-16($17)
+	cmpult	$20,$28,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	or	$8,$25,$25		# combine cy from the two fadds
+	subl	$19,4,$19		# decr loop cnt
+	stl	$22,-16($16)
+	addl	$1,$25,$28		# cy add
+	stl	$23,-8($16)
+	addl	$5,$28,$21		# 2nd main add
+	addl	$18,32,$18		# update s2_ptr
+	cmpult	$28,$25,$8		# compute cy from last add
+	bge	$19,.Loop
+ # Finish software pipeline for 1st loop
+.Lend1:	cmpult	$21,$28,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$2,$25,$28		# cy add
+	addl	$28,$6,$22		# 3rd main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$22,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	addl	$28,$7,$23		# 4th main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$23,$28,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	stl	$22,-16($16)
+	stl	$23,-8($16)
+.Lend2:	addl	$19,4,$19		# restore loop cnt
+	beq	$19,.Lret
+ # Start software pipeline for 2nd loop
+	ldl	$0,0($18)
+	ldl	$4,0($17)
+	subl	$19,1,$19
+	beq	$19,.Lend0
+ # 2nd loop handles remaining 1-3 limbs
+	.align	4
+.Loop0:	addl	$0,$25,$28		# cy add
+	ldl	$0,8($18)
+	addl	$4,$28,$20		# main add
+	ldl	$4,8($17)
+	addl	$18,8,$18
+	cmpult	$28,$25,$8		# compute cy from last add
+	addl	$17,8,$17
+	stl	$20,0($16)
+	cmpult	$20,$28,$25		# compute cy from last add
+	subl	$19,1,$19		# decr loop cnt
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,8,$16
+	bne	$19,.Loop0
+.Lend0:	addl	$0,$25,$28		# cy add
+	addl	$4,$28,$20		# main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$20,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+
+.Lret:	or	$25,$31,$0		# return cy
+	ret	$31,($26),1
+	.end	__mpn_add_n
diff --git a/sysdeps/sw_64/sw6b/addmul_1.S b/sysdeps/sw_64/sw6b/addmul_1.S
new file mode 100644
index 00000000..4572fd6e
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/addmul_1.S
@@ -0,0 +1,477 @@
+ # Sw_64 sw6 mpn_addmul_1 -- Multiply a limb vector with a limb and add
+ # the result to a second limb vector.
+ #
+ #  Copyright (C) 2000-2018 Free Software Foundation, Inc.
+ #
+ #  This file is part of the GNU MP Library.
+ #
+ #  The GNU MP Library is free software; you can redistribute it and/or modify
+ #  it under the terms of the GNU Lesser General Public License as published
+ #  by the Free Software Foundation; either version 2.1 of the License, or (at
+ #  your option) any later version.
+ #
+ #  The GNU MP Library is distributed in the hope that it will be useful, but
+ #  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ #  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ #  License for more details.
+ #
+ #  You should have received a copy of the GNU Lesser General Public License
+ #  along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+ #  INPUT PARAMETERS
+ #  res_ptr	$16
+ #  s1_ptr	$17
+ #  size	$18
+ #  s2_limb	$19
+ #
+ #  This code runs at 42 cycles/limb on EV4, 18 cycles/limb on EV5, and
+ #  exactly 3.625 cycles/limb on EV6...
+ #
+ # This code was written in close cooperation with ev6 pipeline expert
+ # Steve Root (root@toober.hlo.dec.com).  Any errors are tege's fault, though.
+ #
+ #   Register usages for unrolled loop:
+ #	  0-3     mul's
+ #	  4-7     acc's
+ #	  8-15    mul results
+ #	  20,21   carry's
+ #	  22,23   save for stores
+ #
+ #   Sustains 8 mul-fadds in 29 cycles in the unrolled inner loop.
+ #
+ #   The stores can issue a cycle late so we have paired no-op's to 'catch'
+ #   them, so that further disturbance to the schedule is damped.
+ #
+ #   We couldn't pair the loads, because the entangled schedule of the
+ #   carry's has to happen on one side {0} of the machine. Note, the total
+ #   use of U0, and the total use of L0 (after attending to the stores).
+ #   which is part of the reason why....
+ #
+ #   This is a great schedule for the d_cache, a poor schedule for the
+ #   b_cache. The lockup on U0 means that any stall can't be recovered
+ #   from. Consider a ldl in L1.  say that load gets stalled because it
+ #   collides with a fill from the b_Cache. On the next cycle, this load
+ #   gets priority. If first looks at L0, and goes there. The instruction
+ #   we intended for L0 gets to look at L1, which is NOT where we want
+ #   it. It either stalls 1, because it can't go in L0, or goes there, and
+ #   causes a further instruction to stall.
+ #
+ #   So for b_cache, we're likely going to want to put one or more cycles
+ #   back into the code! And, of course, put in prefetches. For the
+ #   accumulator, flds, intent to modify.  For the fmuldiplier, you might
+ #   want ldl, evict next, if you're not wanting to use it again soon. Use
+ #   256 ahead of present pointer value. At a place where we have an mt
+ #   followed by a bookkeeping, put the bookkeeping in upper, and the
+ #   prefetch into lower.
+ #
+ #   Note, the usage of physical registers per cycle is smoothed off, as
+ #   much as possible.
+ #
+ #   Note, the ldl's and stl's are at the end of the quadpacks.  note, we'd
+ #   like not to have a ldl or stl to preceded a conditional branch in a
+ #   quadpack. The conditional branch moves the retire pointer one cycle
+ #   later.
+ #
+ #   Optimization notes:
+ #   Callee-saves regs: $9 $10 $11 $12 $13 $14 $15 $26 ?$27?
+ #   Reserved regs:	 $29 $30 $31
+ #   Free caller-saves regs in unrolled code: $24 $25 $28
+ #   We should swap some of the callee-saves regs for some of the free
+ #   caller-saves regs, saving some overhead cycles.
+ #   Most importantly, we should write fast code for the 0-7 case.
+ #   The code we use there are for the 21164, and runs at 7 cycles/limb
+ #   on the 21264.  Should not be hard, if we write specialized code for
+ #   1-7 limbs (the one for 0 limbs should be straightforward).  We then just
+ #   need a jump table indexed by the low 3 bits of the count argument.
+
+	.set	noreorder
+	.set	noat
+	.text
+
+	.globl	__mpn_addmul_1
+	.ent	__mpn_addmul_1
+__mpn_addmul_1:
+	.frame	$30,0,$26,0
+	.prologue 0
+
+	cmpult	$18,	8,	$1
+	beq	$1,	$Large
+
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$18,	1,	$18	# size--
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	umulh	$2,	$19,	$0	# $0 = prod_high
+	beq	$18,	$Lend0b		# jump if size was == 1
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$18,	1,	$18	# size--
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$4
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	beq	$18,	$Lend0a		# jump if size was == 2
+
+	.align 3
+$Loop0:	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	subl	$18,	1,	$18	# size--
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	bne	$18,	$Loop0
+$Lend0a:
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$5,	$0,	$0	# combine carries
+	addl	$4,	$0,	$0	# cy_limb = prod_high + cy
+	ret	$31,	($26),	1
+$Lend0b:
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$0,	$5,	$0
+	ret	$31,	($26),	1
+
+$Large:
+	ldi	$30,	-240($30)
+	stl	$9,	8($30)
+	stl	$10,	16($30)
+	stl	$11,	24($30)
+	stl	$12,	32($30)
+	stl	$13,	40($30)
+	stl	$14,	48($30)
+	stl	$15,	56($30)
+
+	and	$18,	7,	$20	# count for the first loop, 0-7
+	srl	$18,	3,	$18	# count for unrolled loop
+	bis	$31,	$31,	$0
+	beq	$20,	$Lunroll
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$20,	1,	$20	# size--
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	umulh	$2,	$19,	$0	# $0 = prod_high
+	beq	$20,	$Lend1b		# jump if size was == 1
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$20,	1,	$20	# size--
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$4
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	beq	$20,	$Lend1a		# jump if size was == 2
+
+	.align 3
+$Loop1:	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	subl	$20,	1,	$20	# size--
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	bne	$20,	$Loop1
+
+$Lend1a:
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	addl	$4,	$0,	$0	# cy_limb = prod_high + cy
+	br	$31,	$Lunroll
+$Lend1b:
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$0,	$5,	$0
+
+$Lunroll:
+	ldi	$17,	-16($17)	# L1 bookkeeping
+	ldi	$16,	-16($16)	# L1 bookkeeping
+	bis	$0,	$31,	$12
+
+ # ____ UNROLLED LOOP SOFTWARE PIPELINE STARTUP ____
+
+	ldl	$2,	16($17)		# L1
+	ldl	$3,	24($17)		# L1
+	ldi	$18,	-1($18)		# L1 bookkeeping
+	ldl	$6,	16($16)		# L1
+	ldl	$7,	24($16)		# L1
+	ldl	$0,	32($17)		# L1
+	mull	$19,	$2,	$13	# U1
+	ldl	$1,	40($17)		# L1
+	umulh	$19,	$2,	$14	# U1
+	mull	$19,	$3,	$15	# U1
+	ldi	$17,	64($17)		# L1 bookkeeping
+	ldl	$4,	32($16)		# L1
+	ldl	$5,	40($16)		# L1
+	umulh	$19,	$3,	$8	# U1
+	ldl	$2,	-16($17)	# L1
+	mull	$19,	$0,	$9	# U1
+	ldl	$3,	-8($17)		# L1
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	mull	$19,	$1,	$11	# U1
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	ldi	$16,	64($16)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	-16($16)	# L1
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	-8($16)		# L1
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	0($17)		# L1
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	8($17)		# L1
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# L0 lo + acc
+	stl	$22,	-48($16)	# L0
+	stl	$23,	-40($16)	# L1
+	mull	$19,	$3,	$15	# U1
+	addl	$8,	$21,	$8	# U0 hi mul + carry
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	ble	$18,	$Lend		# U1 bookkeeping
+
+ # ____ MAIN UNROLLED LOOP ____
+	.align 4
+$Loop:
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	0($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	8($16)		# L1
+
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	ldl	$2,	16($17)		# L1
+
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	ldl	$3,	24($17)		# L1
+
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	-32($16)	# L0
+	stl	$23,	-24($16)	# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$1,	$11	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$18,	-1($18)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	16($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	24($16)		# L1
+
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	32($17)		# L1
+
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	40($17)		# L1
+
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# U0 lo + acc
+	stl	$22,	-16($16)	# L0
+	stl	$23,	-8($16)		# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$3,	$15	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$8,	$21,	$8	# L0 hi mul + carry
+
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$17,	64($17)		# L1 bookkeeping
+	addl	$4,	$8,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	32($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	40($16)		# L1
+
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	ldl	$2,	-16($17)	# L1
+
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	ldl	$3,	-8($17)		# L1
+
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	0($16)		# L0
+	stl	$23,	8($16)		# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$1,	$11	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$16,	64($16)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	-16($16)	# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	-8($16)		# L1
+
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	0($17)		# L1
+
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	8($17)		# L1
+
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# L0 lo + acc
+	stl	$22,	-48($16)	# L0
+	stl	$23,	-40($16)	# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$3,	$15	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$8,	$21,	$8	# U0 hi mul + carry
+
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	bis	$31,	$31,	$31	# L1 mt
+	bgt	$18,	$Loop		# U1 bookkeeping
+
+# ____ UNROLLED LOOP SOFTWARE PIPELINE FINISH ____
+$Lend:
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	0($16)		# L1
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	8($16)		# L1
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	-32($16)	# L0
+	stl	$23,	-24($16)	# L1
+	mull	$19,	$1,	$11	# U1
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	addl	$6,	$12,	$22	# U0 hi add => answer
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	addl	$4,	$9,	$4	# U0 lo + acc
+	stl	$22,	-16($16)	# L0
+	stl	$23,	-8($16)		# L1
+	bis	$31,	$31,	$31	# L0 st slosh
+	addl	$8,	$21,	$8	# L0 hi mul + carry
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	stl	$22,	0($16)		# L0
+	stl	$23,	8($16)		# L1
+	addl	$12,	$21,	$0	# U0 hi mul + carry
+
+	ldl	$9,	8($30)
+	ldl	$10,	16($30)
+	ldl	$11,	24($30)
+	ldl	$12,	32($30)
+	ldl	$13,	40($30)
+	ldl	$14,	48($30)
+	ldl	$15,	56($30)
+	ldi	$30,	240($30)
+	ret	$31,	($26),	1
+
+	.end	__mpn_addmul_1
diff --git a/sysdeps/sw_64/sw6b/lshift.S b/sysdeps/sw_64/sw6b/lshift.S
new file mode 100644
index 00000000..1b7f3f98
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/lshift.S
@@ -0,0 +1,172 @@
+ # Sw_64 EV5 __mpn_lshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 3.25 cycles/limb on the EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_lshift
+	.ent	__mpn_lshift
+__mpn_lshift:
+	.frame	$30,0,$26,0
+
+	s8addl	$18,$17,$17	# make r17 point at end of s1
+	ldl	$4,-8($17)	# load first limb
+	subl	$31,$19,$20
+	s8addl	$18,$16,$16	# make r16 point at end of RES
+	subl	$18,1,$18
+	and	$18,4-1,$28	# number of limbs in first loop
+	srl	$4,$20,$0	# compute function result
+
+	beq	$28,.L0
+	subl	$18,$28,$18
+
+	.align	3
+.Loop0:	ldl	$3,-16($17)
+	subl	$16,8,$16
+	sll	$4,$19,$5
+	subl	$17,8,$17
+	subl	$28,1,$28
+	srl	$3,$20,$6
+	or	$3,$3,$4
+	or	$5,$6,$8
+	stl	$8,0($16)
+	bne	$28,.Loop0
+
+.L0:	sll	$4,$19,$24
+	beq	$18,.Lend
+ # warm up phase 1
+	ldl	$1,-16($17)
+	subl	$18,4,$18
+	ldl	$2,-24($17)
+	ldl	$3,-32($17)
+	ldl	$4,-40($17)
+	beq	$18,.Lend1
+ # warm up phase 2
+	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	ldl	$1,-48($17)
+	sll	$2,$19,$22
+	ldl	$2,-56($17)
+	srl	$3,$20,$5
+	or	$7,$24,$7
+	sll	$3,$19,$23
+	or	$8,$21,$8
+	srl	$4,$20,$6
+	ldl	$3,-64($17)
+	sll	$4,$19,$24
+	ldl	$4,-72($17)
+	subl	$18,4,$18
+	beq	$18,.Lend2
+	.align  4
+ # main loop
+.Loop:	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+
+	srl	$1,$20,$7
+	subl	$18,4,$18
+	sll	$1,$19,$21
+	unop	# ldl	$31,-96($17)
+
+	srl	$2,$20,$8
+	ldl	$1,-80($17)
+	sll	$2,$19,$22
+	ldl	$2,-88($17)
+
+	stl	$5,-24($16)
+	or	$7,$24,$7
+	stl	$6,-32($16)
+	or	$8,$21,$8
+
+	srl	$3,$20,$5
+	unop	# ldl	$31,-96($17)
+	sll	$3,$19,$23
+	subl	$16,32,$16
+
+	srl	$4,$20,$6
+	ldl	$3,-96($17)
+	sll	$4,$19,$24
+	ldl	$4,-104($17)
+
+	subl	$17,32,$17
+	bne	$18,.Loop
+ # cool down phase 2/1
+.Lend2:	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	sll	$2,$19,$22
+	stl	$5,-24($16)
+	or	$7,$24,$7
+	stl	$6,-32($16)
+	or	$8,$21,$8
+	srl	$3,$20,$5
+	sll	$3,$19,$23
+	srl	$4,$20,$6
+	sll	$4,$19,$24
+ # cool down phase 2/2
+	stl	$7,-40($16)
+	or	$5,$22,$5
+	stl	$8,-48($16)
+	or	$6,$23,$6
+	stl	$5,-56($16)
+	stl	$6,-64($16)
+ # cool down phase 2/3
+	stl	$24,-72($16)
+	ret	$31,($26),1
+
+ # cool down phase 1/1
+.Lend1:	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	sll	$2,$19,$22
+	srl	$3,$20,$5
+	or	$7,$24,$7
+	sll	$3,$19,$23
+	or	$8,$21,$8
+	srl	$4,$20,$6
+	sll	$4,$19,$24
+ # cool down phase 1/2
+	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+	stl	$5,-24($16)
+	stl	$6,-32($16)
+	stl	$24,-40($16)
+	ret	$31,($26),1
+
+.Lend:	stl	$24,-8($16)
+	ret	$31,($26),1
+	.end	__mpn_lshift
diff --git a/sysdeps/sw_64/sw6b/memcpy.S b/sysdeps/sw_64/sw6b/memcpy.S
new file mode 100644
index 00000000..e277839c
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/memcpy.S
@@ -0,0 +1,416 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   sw6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Much of the information about 21264 scheduling/coding comes from:
+ *	Compiler Writer's Guide for the Sw_64 21264
+ *	abbreviated as 'CWG' in other comments here
+ *	ftp.digital.com/pub/Digital/info/semiconductor/literature/dsc-library.html
+ * Scheduling notation:
+ *	E	- either cluster
+ *	U	- upper subcluster; U0 - subcluster U0; U1 - subcluster U1
+ *	L	- lower subcluster; L0 - subcluster L0; L1 - subcluster L1
+ *
+ * Temp usage notes:
+ *	$0		- destination address
+ *	$1,$2,		- scratch
+ */
+
+#include <sysdep.h>
+
+	.arch ev6
+	.set noreorder
+	.set noat
+        
+	.type $jmppointh,@object
+$jumppointh:
+        .gprel32        $both_0mod8
+        .gprel32        J$H01
+        .gprel32        J$H02
+        .gprel32        J$H03
+        .gprel32        J$H04
+        .gprel32        J$H05
+        .gprel32        J$H06
+        .gprel32        J$H07
+
+ENTRY(memcpy)
+	.prologue 1
+	ldgp	$29, 0($27)
+	mov	$16, $0			# E : copy dest to return
+	ble	$18, $nomoredata	# U : done with the copy?
+        cmplt	$18, 8, $1
+        bne 	$1, $less_8
+	xor	$16, $17, $1		# E : are source and dest alignments the same?
+	and	$1, 7, $1		# E : are they the same mod 8?
+
+	bne	$1, $misaligned		# U : Nope - gotta do this the slow way
+	/* source and dest are same mod 8 address */
+	and	$16, 7, $1		# E : Are both 0mod8?
+	beq	$1, $both_0mod8		# U : Yes
+	nop				# E :
+
+	/*
+	 * source and dest are same misalignment.  move a byte at a time
+	 * until a 0mod8 alignment for both is reached.
+	 * At least one byte more to move
+	 */
+
+        ldi   $2, 8
+        subl  $2, $1, $1
+
+$head_align:
+        addl   $16, $1, $16
+        addl   $17, $1, $17
+        subl   $18, $1, $18
+        ldih    $2, $jumppointh($29)    !gprelhigh
+        s4addl $1, $2, $2
+        ldw    $2, $jumppointh($2)      !gprellow
+        addl   $2, $29, $2
+        jmp    ($2)
+
+$both_0mod8:
+	cmple	$18, 127, $1		# E : Can we unroll the loop?
+	bne	$1, $no_unroll		# U :
+	and	$16, 63, $1		# E : get mod64 alignment
+	beq	$1, $do_unroll		# U : no single quads to fiddle
+
+$single_head_quad:
+	ldl	$1, 0($17)		# L : get 8 bytes
+	subl	$18, 8, $18		# E : count -= 8
+	addl	$17, 8, $17		# E : src += 8
+	nop				# E :
+
+	stl	$1, 0($16)		# L : store
+	addl	$16, 8, $16		# E : dest += 8
+	and	$16, 63, $1		# E : get mod64 alignment
+	bne	$1, $single_head_quad	# U : still not fully aligned
+
+$do_unroll:
+	ldih	$1, 8($31)		# big than 512K
+	cmple	$18, $1, $1
+	beq	$1, $unroll_body_512
+	nop 
+	nop 
+	cmple	$18, 63, $1		# E : Can we go through the unrolled loop?
+	bne	$1, $tail_quads		# U : Nope
+	nop				# E :
+
+$unroll_body:
+	ldl	$6, 0($17)		# L0 : bytes 0..7
+	nop				# E :
+	nop				# E :
+
+	ldl	$4, 8($17)		# L : bytes 8..15
+	ldl	$5, 16($17)		# L : bytes 16..23
+	nop				# E :
+	nop				# E :
+
+	ldl	$3, 24($17)		# L : bytes 24..31
+	addl	$16, 64, $1		# E : fallback value for wh64
+	nop				# E :
+	nop				# E :
+
+	addl	$17, 32, $17		# E : src += 32 bytes
+	stl	$6, 0($16)		# L : bytes 0..7
+	nop				# E :
+	nop				# E :
+
+	stl	$4, 8($16)		# L : bytes 8..15
+	stl	$5, 16($16)		# L : bytes 16..23
+	subl	$18, 192, $2		# E : At least two more trips to go?
+	nop				# E :
+
+	stl	$3, 24($16)		# L : bytes 24..31
+	addl	$16, 32, $16		# E : dest += 32 bytes
+	nop				# E :
+	nop				# E :
+
+	ldl	$6, 0($17)		# L : bytes 0..7
+	ldl	$4, 8($17)		# L : bytes 8..15
+					# fallback wh64 address if < 2 more trips
+	nop				# E :
+	nop				# E :
+
+	ldl	$5, 16($17)		# L : bytes 16..23
+	ldl	$3, 24($17)		# L : bytes 24..31
+	addl	$16, 32, $16		# E : dest += 32
+	subl	$18, 64, $18		# E : count -= 64
+
+	addl	$17, 32, $17		# E : src += 32
+	stl	$6, -32($16)		# L : bytes 0..7
+	stl	$4, -24($16)		# L : bytes 8..15
+	cmple	$18, 63, $1		# E : At least one more trip?
+
+	stl	$5, -16($16)		# L : bytes 16..23
+	stl	$3, -8($16)		# L : bytes 24..31
+	nop				# E :
+	beq	$1, $unroll_body
+	nop
+	nop
+	nop
+	br	$tail_quads
+
+$unroll_body_512:
+	fillcs	128*4($17)
+	e_fillcs 128*20($17)
+
+	fillcs	128*3($16)		#add by ZJ20220620 stl_nc->stl
+	e_fillcs 128*7($16)
+
+	ldl	$6, 0($17)		# L0 : bytes 0..7
+	nop				# E :
+	nop				# E :
+
+	ldl	$4, 8($17)		# L : bytes 8..15
+	ldl	$5, 16($17)		# L : bytes 16..23
+	nop				# E :
+	nop				# E :
+
+	ldl	$3, 24($17)		# L : bytes 24..31
+	addl	$16, 64, $1		# E : fallback value for wh64
+	nop				# E :
+	nop				# E :
+
+	addl	$17, 32, $17		# E : src += 32 bytes
+	stl	$6, 0($16)		# L : bytes 0..7
+	nop				# E :
+	nop				# E :
+
+	stl	$4, 8($16)		# L : bytes 8..15
+	stl	$5, 16($16)		# L : bytes 16..23
+	subl	$18, 192, $2		# E : At least two more trips to go?
+	nop				# E :
+
+	stl	$3, 24($16)		# L : bytes 24..31
+	addl	$16, 32, $16		# E : dest += 32 bytes
+	nop				# E :
+	nop				# E :
+
+	ldl	$6, 0($17)		# L : bytes 0..7
+	ldl	$4, 8($17)		# L : bytes 8..15
+					# fallback wh64 address if < 2 more trips
+	nop				# E :
+	nop				# E :
+
+	ldl	$5, 16($17)		# L : bytes 16..23
+	ldl	$3, 24($17)		# L : bytes 24..31
+	addl	$16, 32, $16		# E : dest += 32
+	subl	$18, 64, $18		# E : count -= 64
+
+	addl	$17, 32, $17		# E : src += 32
+	stl	$6, -32($16)		# L : bytes 0..7
+	stl	$4, -24($16)		# L : bytes 8..15
+	cmple	$18, 63, $1		# E : At least one more trip?
+
+	stl	$5, -16($16)		# L : bytes 16..23
+	stl	$3, -8($16)		# L : bytes 24..31
+	nop				# E :
+	beq	$1, $unroll_body_512
+
+$tail_quads:
+$no_unroll:
+	.align 4
+	subl	$18, 8, $18		# E : At least a quad left?
+	blt	$18, $less_than_8	# U : Nope
+	nop				# E :
+	nop				# E :
+
+$move_a_quad:
+	ldl	$1, 0($17)		# L : fetch 8
+	subl	$18, 8, $18		# E : count -= 8
+	addl	$17, 8, $17		# E : src += 8
+	nop				# E :
+
+	stl	$1, 0($16)		# L : store 8
+	addl	$16, 8, $16		# E : dest += 8
+	bge	$18, $move_a_quad	# U :
+	nop				# E :
+
+$less_than_8:
+	.align 4
+	addl	$18, 8, $18		# E : add back for trailing bytes
+	ble	$18, $nomoredata	# U : All-done
+	nop				# E :
+	nop				# E :
+
+	/* Trailing bytes */
+$tail_bytes:
+	subl	$18, 1, $18		# E : count--
+	ldbu	$1, 0($17)		# L : fetch a byte
+	addl	$17, 1, $17		# E : src++
+	nop				# E :
+
+	stb	$1, 0($16)		# L : store a byte
+	addl	$16, 1, $16		# E : dest++
+	bgt	$18, $tail_bytes	# U : more to be done?
+	nop				# E :
+
+	/* branching to exit takes 3 extra cycles, so replicate exit here */
+	ret	$31, ($26), 1		# L0 :
+	nop				# E :
+	nop				# E :
+	nop				# E :
+
+$misaligned:
+	mov	$0, $4			# E : dest temp
+	and	$0, 7, $1		# E : dest alignment mod8
+	beq	$1, $dest_0mod8		# U : life doesnt totally suck
+	nop
+
+$aligndest:
+	ble	$18, $nomoredata	# U :
+	ldbu	$1, 0($17)		# L : fetch a byte
+	subl	$18, 1, $18		# E : count--
+	addl	$17, 1, $17		# E : src++
+
+	stb	$1, 0($4)		# L : store it
+	addl	$4, 1, $4		# E : dest++
+	and	$4, 7, $1		# E : dest 0mod8 yet?
+	bne	$1, $aligndest		# U : go until we are aligned.
+
+	/* Source has unknown alignment, but dest is known to be 0mod8 */
+$dest_0mod8:
+	subl	$18, 8, $18		# E : At least a quad left?
+	blt	$18, $misalign_tail	# U : Nope
+	ldl_u	$3, 0($17)		# L : seed (rotating load) of 8 bytes
+	ldih    $1, 8($31)
+	subl	$1, 8, $1
+	cmple	$18, $1, $1
+	beq	$1, $mis_quad_big	# big than 512K
+
+$mis_quad:
+	ldl_u	$16, 8($17)	# L : Fetch next 8
+	ext3b	$3, $17, $3	# U : masking
+	ext7b	$16, $17, $1	# U : masking
+	bis	$3, $1, $1	# E : merged bytes to store
+	
+	subl	$18, 8, $18	# E : count -= 8
+	addl	$17, 8, $17	# E : src += 8
+	stl	$1, 0($4)	# L : store 8 (aligned)
+	mov	$16, $3		# E : "rotate" source data
+	
+	addl	$4, 8, $4	# E : dest += 8
+	bge	$18, $mis_quad	# U : More quads to move
+	nop
+	nop
+	nop
+	br	$misalign_tail
+
+$mis_quad_big:
+	fillcs	128*4($17)
+	e_fillcs 128*20($17)
+	ldl_u   $16, 8($17)             # L : Fetch next 8
+	ext3b   $3, $17, $3             # U : masking
+	ext7b   $16, $17, $1            # U : masking
+	bis     $3, $1, $1              # E : merged bytes to store
+	
+	fillcs	128*9($17)		#add by ZJ20220620 stl_nc->stl
+	e_fillcs 128*15($17)
+
+	subl	$18, 8, $18             # E : count -= 8
+	addl	$17, 8, $17             # E : src += 8
+	stl	$1, 0($4)               # L : store 8 (aligned)
+        mov     $16, $3                 # E : "rotate" source data
+
+        addl    $4, 8, $4               # E : dest += 8
+        bge     $18, $mis_quad_big          # U : More quads to move
+        nop
+        nop
+
+$misalign_tail:
+	addl	$18, 8, $18		# E : account for tail stuff
+	ble	$18, $nomoredata	# U :
+	nop
+	nop
+
+$misalign_byte:
+	ldbu	$1, 0($17)		# L : fetch 1
+	subl	$18, 1, $18		# E : count--
+	addl	$17, 1, $17		# E : src++
+	nop				# E :
+
+	stb	$1, 0($4)		# L : store
+	addl	$4, 1, $4		# E : dest++
+	bgt	$18, $misalign_byte	# U : more to go?
+	nop
+	br 	$nomoredata
+
+$less_8:
+	ldbu	$1, 0($17)		# L : fetch 1
+	subl	$18, 1, $18		# E : count--
+	addl	$17, 1, $17		# E : src++
+	nop				# E :
+
+	stb	$1, 0($16)		# L : store
+	addl	$16, 1, $16		# E : dest++
+	bgt	$18, $less_8		# U : more to go?
+	nop
+
+$nomoredata:
+	ret	$31, ($26), 1		# L0 :
+	nop				# E :
+	nop				# E :
+	nop				# E :
+
+J$H01:
+        ldbu    $1,-1($17)
+        stb     $1,-1($16)
+        br      $both_0mod8
+
+J$H02:
+        ldh     $1,-2($17)
+        sth     $1,-2($16)
+        br      $both_0mod8
+
+J$H03:
+        ldh     $1,-2($17)
+        ldbu    $2,-3($17)
+        sth     $1,-2($16)
+        stb     $2,-3($16)
+        br      $both_0mod8
+
+J$H04:
+        ldw     $1,-4($17)
+        stw     $1,-4($16)
+        br      $both_0mod8
+
+J$H05:
+        ldw     $1,-4($17)
+        ldbu    $2,-5($17)
+        stw     $1,-4($16)
+        stb     $2,-5($16)
+        br      $both_0mod8
+
+J$H06:
+        ldw     $1,-4($17)
+        ldh     $2,-6($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+        br      $both_0mod8
+
+J$H07:
+        ldw     $1,-4($17)
+        ldh     $2,-6($17)
+        ldbu    $3,-7($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+        stb     $3,-7($16)
+        br      $both_0mod8
+
+END(memcpy)
+libc_hidden_builtin_def (memcpy)
diff --git a/sysdeps/sw_64/sw6b/memset.S b/sysdeps/sw_64/sw6b/memset.S
new file mode 100644
index 00000000..a862d6fd
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/memset.S
@@ -0,0 +1,311 @@
+/* Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include <sysdep.h>
+
+	.arch sw6b
+	.set noat
+	.set noreorder
+
+ENTRY(memset)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	/*
+	 * Serious stalling happens.  The only way to mitigate this is to
+	 * undertake a major re-write to interleave the constant materialization
+	 * with other parts of the fall-through code.  This is important, even
+	 * though it makes maintenance tougher.
+	 * Do this later.
+	 */
+	and	$17, 255, $1	# E : 00000000000000ch
+	ins0b	$17, 1, $2	# U : 000000000000ch00
+	mov	$16, $0		# E : return value
+        mov     $17, $8		# E : Save the ch
+	ble	$18, $end	# U : zero length requested?
+
+	addl	$18, $16, $6	# E : max address to write to
+	or	$1, $2, $17	# E : 000000000000chch
+	ins0b	$1, 2, $3	# U : 0000000000ch0000
+	ins0b	$1, 3, $4	# U : 00000000ch000000
+
+	or	$3, $4, $3	# E : 00000000chch0000
+	ins1b	$17, 4, $5	# U : 0000chch00000000
+	xor	$16, $6, $1	# E : will complete write be within one quadword?
+	ins1b	$17, 6, $2	# U : chch000000000000
+
+	or	$17, $3, $17	# E : 00000000chchchch
+	or	$2, $5, $2	# E : chchchch00000000
+	bic	$1, 7, $1	# E : fit within a single quadword?
+	and	$16, 7, $3	# E : Target addr misalignment
+
+	or	$17, $2, $17	# E : chchchchchchchch
+	beq	$1, $within_quad # U :
+	nop			# E :
+	beq	$3, $aligned	# U : target is 0mod8
+
+	/*
+	 * Target address is misaligned, and won't fit within a quadword.
+	 */
+
+#ifdef  pixman_error
+//if the addr is unaligned in multi-thread, this will cause thread unsafty,so use stb to store the trailing bytes
+	ldl_u	$4, 0($16)	# L : Fetch first partial
+	mov	$16, $5		# E : Save the address
+	ins3b	$17, $16, $2	# U : Insert new bytes
+	subl	$3, 8, $3	# E : Invert (for addressing uses)
+
+	addl	$18, $3, $18	# E : $18 is new count ($3 is negative)
+	mask3b	$4, $16, $4	# U : clear relevant parts of the quad
+	subl	$16, $3, $16	# E : $16 is new aligned destination
+	or	$2, $4, $1	# E : Final bytes
+
+	nop
+	stl_u	$1,0($5)	# L : Store result
+	nop
+	nop
+#else
+$misaligned:
+        stb	$8, 0($16)
+        subl	$18, 1, $18
+        beq	$18, $end
+        addl	$16, 1, $16
+        and     $16, 7, $3      # E : Target addr misalignment
+        bne	$3, $misaligned
+#endif
+
+	.align 4
+$aligned:
+	/*
+	 * We are now guaranteed to be quad aligned, with at least
+	 * one partial quad to write.
+	 */
+
+	sra	$18, 3, $3	# U : Number of remaining quads to write
+	and	$18, 7, $18	# E : Number of trailing bytes to write
+	mov	$16, $5		# E : Save dest address
+	beq	$3, $no_quad	# U : tail stuff only
+
+	/*
+	 * It's worth the effort to unroll this and use wh64 if possible.
+	 * At this point, entry values are:
+	 * $16	Current destination address
+	 * $5	A copy of $16
+	 * $6	The max quadword address to write to
+	 * $18	Number trailer bytes
+	 * $3	Number quads to write
+	 */
+#	and	$16, 0x3f, $2	# E : Forward work (only useful for unrolled loop)
+	and	$16, 0x1f, $2	# E : Forward work (only useful for unrolled loop)
+	subl	$3, 16, $4	# E : Only try to unroll if > 128 bytes
+	subl	$2, 0x40, $1	# E : bias counter (aligning stuff 0mod64)
+	blt	$4, $loop	# U :
+
+	/*
+	 * We know we've got at least 16 quads, minimum of one trip
+	 * through unrolled loop.  Do a quad at a time to get us 0mod64
+	 * aligned.
+	 */
+
+	nop			# E :
+	nop			# E :
+	nop			# E :
+#	beq	$1, $bigalign	# U :
+	beq	$2, $bigalign	# U :
+$alignmod32:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : For consistency later
+	addl	$1, 8, $1	# E : Increment towards zero for alignment
+#	addl	$5, 8, $4	# E : Initial wh64 address (filler instruction)
+
+	nop
+	nop
+	addl	$5, 8, $5	# E : Inc address
+	blt	$1, $alignmod32 # U :
+
+
+$bigalign:
+	ldih    $1, 8($31)	# big than 512KB
+	cmple	$18, $1, $1
+	beq	$1, $do_wh64_512	
+
+	/*
+	 * $3 - number quads left to go
+	 * $5 - target address (aligned 0mod64)
+	 * $17 - mask of stuff to store
+	 * Scratch registers available: $7, $2, $4, $1
+	 * We know that we'll be taking a minimum of one trip through.
+	 * CWG Section 3.7.6: do not expect a sustained store rate of > 1/cycle
+	 * Assumes the wh64 needs to be for 2 trips through the loop in the future.
+	 * The wh64 is issued on for the starting destination address for trip +2
+	 * through the loop, and if there are less than two trips left, the target
+	 * address will be for the current trip.
+	 */
+
+$do_wh64:
+#	wh64	($4)		# L1 : memory subsystem write hint
+	subl	$3, 24, $2	# E : For determining future wh64 addresses
+	stl	$17, 0($5)	# L :
+	nop			# E :
+
+#	addl	$5, 128, $4	# E : speculative target of next wh64
+	stl	$17, 8($5)	# L :
+	stl	$17, 16($5)	# L :
+	addl	$5, 64, $7	# E : Fallback address for wh64 (== next trip addr)
+
+	stl	$17, 24($5)	# L :
+	stl	$17, 32($5)	# L :
+#	sellt	$2, $7, $4, $4	# E : Latency 2, extra mapping cycle
+	nop
+
+	stl	$17, 40($5)	# L :
+	stl	$17, 48($5)	# L :
+	subl	$3, 16, $2	# E : Repeat the loop at least once more?
+	nop
+
+	stl	$17, 56($5)	# L :
+	addl	$5, 64, $5	# E :
+	subl	$3, 8, $3	# E :
+	bge	$2, $do_wh64	# U :
+
+	nop
+	nop
+	nop
+	beq	$3, $no_quad	# U : Might have finished already
+
+	nop
+	nop
+	nop
+	br	$loop		# U : Might have finished already
+
+$do_wh64_512:
+#	wh64	($4)		# L1 : memory subsystem write hint
+	subl	$3, 24, $2	# E : For determining future wh64 addresses
+
+	fillcs	 128*1($5)
+	e_fillcs 128*5($5)
+		
+#	stl_nc	$17, 0($5)	# L :
+	stl	$17, 0($5)	# L :
+	nop			# E :
+
+#	addl	$5, 128, $4	# E : speculative target of next wh64
+#	stl_nc	$17, 8($5)	# L :
+	stl	$17, 8($5)	# L :
+#	stl_nc	$17, 16($5)	# L :
+	stl	$17, 16($5)	# L :
+	addl	$5, 64, $7	# E : Fallback address for wh64 (== next trip addr)
+
+#	stl_nc	$17, 24($5)	# L :
+	stl	$17, 24($5)	# L :
+#	stl_nc	$17, 32($5)	# L :
+	stl	$17, 32($5)	# L :
+#	sellt	$2, $7, $4, $4	# E : Latency 2, extra mapping cycle
+	nop
+
+#	stl_nc	$17, 40($5)	# L :
+	stl	$17, 40($5)	# L :
+#	stl_nc	$17, 48($5)	# L :
+	stl	$17, 48($5)	# L :
+	subl	$3, 16, $2	# E : Repeat the loop at least once more?
+	nop
+
+#	stl_nc	$17, 56($5)	# L :
+	stl	$17, 56($5)	# L :
+	addl	$5, 64, $5	# E :
+	subl	$3, 8, $3	# E :
+	bge	$2, $do_wh64_512	# U :
+
+	nop
+	nop
+	nop
+	beq	$3, $no_quad	# U : Might have finished already
+
+	.align 4
+	/*
+	 * Simple loop for trailing quadwords, or for small amounts
+	 * of data (where we can't use an unrolled loop and wh64)
+	 */
+$loop:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : Decrement number quads left
+	addl	$5, 8, $5	# E : Inc address
+	bne	$3, $loop	# U : more?
+
+$no_quad:
+	/*
+	 * Write 0..7 trailing bytes.
+	 */
+	nop			# E :
+	beq	$18, $end	# U : All done?
+
+#ifndef  pixman_error
+//if the addr is unaligned in multi-thread, this will cause thread unsafty,so use stb to store the trailing bytes
+$trailing:
+        stb	$17, 0($5)
+        subl	$18, 1, $18
+        beq	$18, $end
+        addl	$5, 1, $5
+        br	$trailing
+#else
+	ldl	$7, 0($5)	# L :
+	mask7b	$7, $6, $2	# U : Mask final quad
+
+	ins7b	$17, $6, $4	# U : New bits
+	or	$2, $4, $1	# E : Put it all together
+	stl	$1, 0($5)	# L : And back to memory
+	ret	$31,($26),1	# L0 :
+#endif
+
+$within_quad:
+#ifdef PIXMAN_ERROR 
+//if the addr is unaligned in multi-thread, this will cause thread unsafty,so use stb to store the trailing bytes
+	ldl_u	$1, 0($16)	# L :
+	ins3b	$17, $16, $2	# U : New bits
+	mask3b	$1, $16, $4	# U : Clear old
+	or	$2, $4, $2	# E : New result
+
+	mask3b	$2, $6, $4	# U :
+	mask7b	$1, $6, $2	# U :
+	or	$2, $4, $1	# E :
+	stl_u	$1, 0($16)	# L :
+#else
+        stb	$8, 0($16)
+        subl	$18, 1, $18
+        beq	$18, $end
+        addl	$16, 1, $16
+        br	$within_quad
+#endif
+
+$end:
+	nop
+	nop
+	nop
+	ret $31,($26),1		# L0 :
+
+        END(memset)
+libc_hidden_builtin_def (memset)
+
diff --git a/sysdeps/sw_64/sw6b/rshift.S b/sysdeps/sw_64/sw6b/rshift.S
new file mode 100644
index 00000000..2a020414
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/rshift.S
@@ -0,0 +1,170 @@
+ # Sw_64 EV5 __mpn_rshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 3.25 cycles/limb on the EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_rshift
+	.ent	__mpn_rshift
+__mpn_rshift:
+	.frame	$30,0,$26,0
+
+	ldl	$4,0($17)	# load first limb
+	subl	$31,$19,$20
+	subl	$18,1,$18
+	and	$18,4-1,$28	# number of limbs in first loop
+	sll	$4,$20,$0	# compute function result
+
+	beq	$28,.L0
+	subl	$18,$28,$18
+
+	.align	3
+.Loop0:	ldl	$3,8($17)
+	addl	$16,8,$16
+	srl	$4,$19,$5
+	addl	$17,8,$17
+	subl	$28,1,$28
+	sll	$3,$20,$6
+	or	$3,$3,$4
+	or	$5,$6,$8
+	stl	$8,-8($16)
+	bne	$28,.Loop0
+
+.L0:	srl	$4,$19,$24
+	beq	$18,.Lend
+ # warm up phase 1
+	ldl	$1,8($17)
+	subl	$18,4,$18
+	ldl	$2,16($17)
+	ldl	$3,24($17)
+	ldl	$4,32($17)
+	beq	$18,.Lend1
+ # warm up phase 2
+	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	ldl	$1,40($17)
+	srl	$2,$19,$22
+	ldl	$2,48($17)
+	sll	$3,$20,$5
+	or	$7,$24,$7
+	srl	$3,$19,$23
+	or	$8,$21,$8
+	sll	$4,$20,$6
+	ldl	$3,56($17)
+	srl	$4,$19,$24
+	ldl	$4,64($17)
+	subl	$18,4,$18
+	beq	$18,.Lend2
+	.align  4
+ # main loop
+.Loop:	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+
+	sll	$1,$20,$7
+	subl	$18,4,$18
+	srl	$1,$19,$21
+	unop	# ldl	$31,-96($17)
+
+	sll	$2,$20,$8
+	ldl	$1,72($17)
+	srl	$2,$19,$22
+	ldl	$2,80($17)
+
+	stl	$5,16($16)
+	or	$7,$24,$7
+	stl	$6,24($16)
+	or	$8,$21,$8
+
+	sll	$3,$20,$5
+	unop	# ldl	$31,-96($17)
+	srl	$3,$19,$23
+	addl	$16,32,$16
+
+	sll	$4,$20,$6
+	ldl	$3,88($17)
+	srl	$4,$19,$24
+	ldl	$4,96($17)
+
+	addl	$17,32,$17
+	bne	$18,.Loop
+ # cool down phase 2/1
+.Lend2:	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	srl	$2,$19,$22
+	stl	$5,16($16)
+	or	$7,$24,$7
+	stl	$6,24($16)
+	or	$8,$21,$8
+	sll	$3,$20,$5
+	srl	$3,$19,$23
+	sll	$4,$20,$6
+	srl	$4,$19,$24
+ # cool down phase 2/2
+	stl	$7,32($16)
+	or	$5,$22,$5
+	stl	$8,40($16)
+	or	$6,$23,$6
+	stl	$5,48($16)
+	stl	$6,56($16)
+ # cool down phase 2/3
+	stl	$24,64($16)
+	ret	$31,($26),1
+
+ # cool down phase 1/1
+.Lend1:	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	srl	$2,$19,$22
+	sll	$3,$20,$5
+	or	$7,$24,$7
+	srl	$3,$19,$23
+	or	$8,$21,$8
+	sll	$4,$20,$6
+	srl	$4,$19,$24
+ # cool down phase 1/2
+	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+	stl	$5,16($16)
+	stl	$6,24($16)
+	stl	$24,32($16)
+	ret	$31,($26),1
+
+.Lend:	stl	$24,0($16)
+	ret	$31,($26),1
+	.end	__mpn_rshift
diff --git a/sysdeps/sw_64/sw6b/stxcpy.S b/sysdeps/sw_64/sw6b/stxcpy.S
new file mode 100644
index 00000000..a3cca303
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/stxcpy.S
@@ -0,0 +1,314 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy a null-terminated string from SRC to DST.
+
+   This is an internal routine used by strcpy, stpcpy, and strcat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+
+   On output:
+	t8  = bitmask (with one bit set) indicating the last byte written
+	a0  = unaligned address of the last *word* written
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+
+#include <sysdep.h>
+
+	.arch ev6
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxcpy, @function
+	.globl	__stxcpy
+	.usepv	__stxcpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 4
+stxcpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# E : build a mask against false zero
+	mask7b	t2, a1, t2	# U :   detection in the src word (stall)
+	mask7b	t1, a1, t3	# U :
+	ornot	t1, t2, t2	# E : (stall)
+
+	mask3b	t0, a1, t0	# U : assemble the first output word
+	cmpgeb	zero, t2, t10	# E : bits set iff null found
+	or	t0, t3, t1	# E : (stall)
+	bne	t10, $a_eos	# U : (stall)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == a source word not containing a null.  */
+	/* Nops here to separate store quads from load quads */
+
+$a_loop:
+	stl_u	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	nop
+	nop
+
+	ldl_u	t1, 0(a1)	# L : Latency=3
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t10	# E : (3 cycle stall)
+	beq	t10, $a_loop	# U : (stall for t10)
+
+	/* Take care of the final (partial) word store.
+	   On entry to this basic block we have:
+	   t1 == the source word containing the null
+	   t10 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t10, t6		# E : find low bit set
+	and	t10, t6, t8	# E : (stall)
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t0, 0(a0)	# L : Latency=3
+	subl	t8, 1, t6	# E :
+	zapnot	t1, t6, t1	# U : clear src bytes >= null (stall)
+	or	t8, t6, t10	# E : (stall)
+
+	zap	t0, t10, t0	# E : clear dst bytes <= null
+	or	t0, t1, t1	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t1, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	.align 4
+__stxcpy:
+	/* Are source and destination co-aligned?  */
+	xor	a0, a1, t0	# E :
+	unop			# E :
+	and	t0, 7, t0	# E : (stall)
+	bne	t0, $unaligned	# U : (stall)
+
+	/* We are co-aligned; take care of a partial first word.  */
+	ldl_u	t1, 0(a1)		# L : load first src word
+	and	a0, 7, t0		# E : take care not to load a word ...
+	addl	a1, 8, a1		# E :
+	beq	t0, stxcpy_aligned	# U : ... if we wont need it (stall)
+
+	ldl_u	t0, 0(a0)	# L :
+	br	stxcpy_aligned	# L0 : Latency=3
+	nop
+	nop
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 4
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, for masking back in, if needed else 0
+	   t1 == the low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# L :
+	addl	a1, 8, a1	# E :
+	ext3b	t1, a1, t1	# U : (stall on a1)
+	ext7b	t2, a1, t4	# U : (stall on a1)
+
+	mask3b	t0, a0, t0	# U :
+	or	t1, t4, t1	# E :
+	mask7b	t1, a0, t1	# U : (stall on t1)
+	or	t0, t1, t1	# E : (stall on t1)
+
+	or	t1, t6, t6	# E :
+	cmpgeb	zero, t6, t10	# E : (stall)
+	ldi	t6, -1		# E : for masking just below
+	bne	t10, $u_final	# U : (stall)
+
+	mask3b	t6, a1, t6		# U : mask out the bits we have
+	or	t6, t2, t2		# E :   already extracted before (stall)
+	cmpgeb	zero, t2, t10		# E :   testing eos (stall)
+	bne	t10, $u_late_head_exit	# U : (stall)
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+
+	stl_u	t1, 0(a0)	# L : store first output word
+	addl	a0, 8, a0	# E :
+	ext3b	t2, a1, t0	# U : position ho-bits of lo word
+	ldl_u	t2, 8(a1)	# U : read next high-order source word
+
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t2, t10	# E : (stall for t2)
+	nop			# E :
+	bne	t10, $u_eos	# U : (stall)
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 3
+$u_loop:
+	ext7b	t2, a1, t1	# U : extract high bits for current word
+	addl	a1, 8, a1	# E : (stall)
+	ext3b	t2, a1, t3	# U : extract low bits for next time (stall)
+	addl	a0, 8, a0	# E :
+
+	or	t0, t1, t1	# E : current dst word now complete
+	ldl_u	t2, 0(a1)	# L : Latency=3 load high word for next time
+	stl_u	t1, -8(a0)	# L : save the current word (stall)
+	mov	t3, t0		# E :
+
+	cmpgeb	zero, t2, t10	# E : test new word for eos
+	beq	t10, $u_loop	# U : (stall)
+	nop
+	nop
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	ext7b	t2, a1, t1	# U :
+	or	t0, t1, t1	# E : first (partial) source word complete (stall)
+	cmpgeb	zero, t1, t10	# E : is the null in this first bit? (stall)
+	bne	t10, $u_final	# U : (stall)
+
+$u_late_head_exit:
+	stl_u	t1, 0(a0)	# L : the null was in the high-order bits
+	addl	a0, 8, a0	# E :
+	ext3b	t2, a1, t1	# U :
+	cmpgeb	zero, t1, t10	# E : (stall)
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t1 == assembled source word
+	   t10 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t10, t6		# E : isolate low bit set
+	and	t6, t10, t8	# E : (stall)
+	and	t8, 0x80, t6	# E : avoid dest word load if we can (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t0, 0(a0)	# E :
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t10	# E : (stall)
+	zapnot	t1, t6, t1	# U : kill source bytes >= null (stall)
+
+	zap	t0, t10, t0	# U : kill dest bytes <= null (2 cycle data stall)
+	or	t0, t1, t1	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t1, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	/* Unaligned copy entry point.  */
+	.align 4
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# L : load first source word
+	and	a0, 7, t4	# E : find dest misalignment
+	and	a1, 7, t5	# E : find src misalignment
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+	mov	zero, t0	# E :
+
+	mov	zero, t6	# E :
+	beq	t4, 1f		# U :
+	ldl_u	t0, 0(a0)	# L :
+	ldi	t6, -1		# E :
+
+	mask3b	t6, a0, t6	# U :
+	nop
+	nop
+	nop
+1:
+	subl	a1, t4, a1	# E : sub dest misalignment from src addr
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+	cmplt	t4, t5, t8	# E :
+	beq	t8, $u_head	# U :
+	ldi	t2, -1		# E : mask out leading garbage in source
+
+	mask7b	t2, t5, t2	# U :
+	ornot	t1, t2, t3	# E : (stall)
+	cmpgeb	zero, t3, t10	# E : is there a zero? (stall)
+	beq	t10, $u_head	# U : (stall)
+
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+
+	ldl_u	t0, 0(a0)	# L :
+	negl	t10, t6		# E : build bitmask of bytes <= zero
+	and	t6, t10, t8	# E : (stall)
+	and	a1, 7, t5	# E :
+
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t10	# E : (stall)
+	srl	t8, t5, t8	# U : adjust final null return value
+	zapnot	t2, t10, t2	# U : prepare source word; mirror changes (stall)
+
+	and	t1, t2, t1	# E : to source validity mask
+	ext3b	t2, a1, t2	# U :
+	ext3b	t1, a1, t1	# U : (stall)
+	andnot	t0, t2, t0	# .. e1 : zero place for source to reside (stall)
+
+	or	t0, t1, t1	# e1    : and put it there
+	stl_u	t1, 0(a0)	# .. e0 : (stall)
+	ret	(t9)		# e1    :
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/sw6b/stxncpy.S b/sysdeps/sw_64/sw6b/stxncpy.S
new file mode 100644
index 00000000..2675d179
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/stxncpy.S
@@ -0,0 +1,392 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy no more than COUNT bytes of the null-terminated string from
+   SRC to DST.
+
+   This is an internal routine used by strncpy, stpncpy, and strncat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+	a2 = COUNT
+
+   Furthermore, COUNT may not be zero.
+
+   On output:
+	t0  = last word written
+	t8  = bitmask (with one bit set) indicating the last byte written
+	t10 = bitmask (with one bit set) indicating the byte position of
+	      the end of the range specified by COUNT
+	a0  = unaligned address of the last *word* written
+	a2  = the number of full words left in COUNT
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+#include <sysdep.h>
+
+	.arch ev6
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxncpy, @function
+	.globl	__stxncpy
+	.usepv	__stxncpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 4
+stxncpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# E : build a mask against false zero
+	mask7b	t2, a1, t2	# U :   detection in the src word (stall)
+	mask7b	t1, a1, t3	# U :
+	ornot	t1, t2, t2	# E : (stall)
+
+	mask3b	t0, a1, t0	# U : assemble the first output word
+	cmpgeb	zero, t2, t7	# E : bits set iff null found
+	or	t0, t3, t0	# E : (stall)
+	beq	a2, $a_eoc	# U :
+
+	bne	t7, $a_eos	# U :
+	nop
+	nop
+	nop
+
+	/* On entry to this basic block:
+	   t0 == a source word not containing a null.  */
+
+	/*
+	 * nops here to:
+	 *	separate store quads from load quads
+	 *	limit of 1 bcond/quad to permit training
+	 */
+$a_loop:
+	stl_u	t0, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+
+	ldl_u	t0, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t0, t7	# E :
+	beq	a2, $a_eoc      # U :
+
+	beq	t7, $a_loop	# U :
+	nop
+	nop
+	nop
+
+	/* Take care of the final (partial) word store.  At this point
+	   the end-of-count bit is set in t7 iff it applies.
+
+	   On entry to this basic block we have:
+	   t0 == the source word containing the null
+	   t7 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t7, t8		# E : find low bit set
+	and	t7, t8, t8	# E : (stall)
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t1, 0(a0)	# L :
+	subl	t8, 1, t6	# E :
+	or	t8, t6, t7	# E : (stall)
+	zapnot	t0, t7, t0	# U : clear src bytes > null (stall)
+
+	zap	t1, t7, t1	# .. e1 : clear dst bytes <= null
+	or	t0, t1, t0	# e1    : (stall)
+	nop
+	nop
+
+1:	stl_u	t0, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	/* Add the end-of-count bit to the eos detection bitmask.  */
+$a_eoc:
+	or	t10, t7, t7	# E :
+	br	$a_eos		# L0 : Latency=3
+	nop
+	nop
+
+	.align 4
+__stxncpy:
+	/* Are source and destination co-aligned?  */
+	ldi	t2, -1		# E :
+	xor	a0, a1, t1	# E :
+	and	a0, 7, t0	# E : find dest misalignment
+	nop			# E :
+
+	srl	t2, 1, t2	# U :
+	and	t1, 7, t1	# E :
+	sellt	a2, t2, a2, a2	# E : bound count to LONG_MAX (stall)
+	nop			# E :
+
+	addl	a2, t0, a2	# E : bias count by dest misalignment
+	subl	a2, 1, a2	# E : (stall)
+	and	a2, 7, t2	# E : (stall)
+	ldi	t10, 1		# E :
+
+	srl	a2, 3, a2	# U : a2 = loop counter = (count - 1)/8
+	sll	t10, t2, t10	# U : t10 = bitmask of last count byte
+	nop			# E :
+	bne	t1, $unaligned	# U : (stall)
+
+	/* We are co-aligned; take care of a partial first word.  */
+	ldl_u	t1, 0(a1)	# L : load first src word
+	addl	a1, 8, a1	# E :
+	beq	t0, stxncpy_aligned # U : avoid loading dest word if not needed
+	ldl_u	t0, 0(a0)	# L :
+
+	br	stxncpy_aligned	# U :
+	nop
+	nop
+	nop
+
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 4
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, unmasked
+	   t1 == the shifted low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# L : Latency=3 load second src word
+	addl	a1, 8, a1	# E :
+	mask3b	t0, a0, t0	# U : mask trailing garbage in dst
+	ext7b	t2, a1, t4	# U : (3 cycle stall on t2)
+
+	or	t1, t4, t1	# E : first aligned src word complete (stall)
+	mask7b	t1, a0, t1	# U : mask leading garbage in src (stall)
+	or	t0, t1, t0	# E : first output word complete (stall)
+	or	t0, t6, t6	# E : mask original data for zero test (stall)
+
+	cmpgeb	zero, t6, t7	# E :
+	beq	a2, $u_eocfin	# U :
+	ldi	t6, -1		# E :
+	nop
+
+	bne	t7, $u_final	# U :
+	mask3b	t6, a1, t6	# U : mask out bits already seen
+	stl_u	t0, 0(a0)	# L : store first output word
+	or      t6, t2, t2	# E :
+
+	cmpgeb	zero, t2, t7	# E : find nulls in second partial
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	bne	t7, $u_late_head_exit	# U :
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+	ext3b	t2, a1, t1	# U : position hi-bits of lo word
+	beq	a2, $u_eoc	# U :
+	ldl_u	t2, 8(a1)	# L : read next high-order source word
+	addl	a1, 8, a1	# E :
+
+	ext7b	t2, a1, t0	# U : position lo-bits of hi word (stall)
+	cmpgeb	zero, t2, t7	# E :
+	nop
+	bne	t7, $u_eos	# U :
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 4
+$u_loop:
+	or	t0, t1, t0	# E : current dst word now complete
+	subl	a2, 1, a2	# E : decrement word count
+	ext3b	t2, a1, t1	# U : extract high bits for next time
+	addl	a0, 8, a0	# E :
+
+	stl_u	t0, -8(a0)	# L : save the current word
+	beq	a2, $u_eoc	# U :
+	ldl_u	t2, 8(a1)	# L : Latency=3 load high word for next time
+	addl	a1, 8, a1	# E :
+
+	ext7b	t2, a1, t0	# U : extract low bits (2 cycle stall)
+	cmpgeb	zero, t2, t7	# E : test new word for eos
+	nop
+	beq	t7, $u_loop	# U :
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	or	t0, t1, t0	# E : first (partial) source word complete
+	nop
+	cmpgeb	zero, t0, t7	# E : is the null in this first bit? (stall)
+	bne	t7, $u_final	# U : (stall)
+
+	stl_u	t0, 0(a0)	# L : the null was in the high-order bits
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+
+$u_late_head_exit:
+	ext3b	t2, a1, t0	# U :
+	cmpgeb	zero, t0, t7	# E :
+	or	t7, t10, t6	# E : (stall)
+	seleq	a2, t6, t7, t7	# E : Latency=2, extra map slot (stall)
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t0 == assembled source word
+	   t7 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t7, t6		# E : isolate low bit set
+	and	t6, t7, t8	# E : (stall)
+	and	t8, 0x80, t6	# E : avoid dest word load if we can (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t1, 0(a0)	# L :
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t7	# E : (stall)
+	zapnot	t0, t7, t0	# U : kill source bytes > null
+
+	zap	t1, t7, t1	# U : kill dest bytes <= null
+	or	t0, t1, t0	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t0, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+
+        /* Got to end-of-count before end of string.
+           On entry to this basic block:
+           t1 == the shifted high-order bits from the previous source word  */
+$u_eoc:
+	and	a1, 7, t6	# E :
+	sll	t10, t6, t6	# U : (stall)
+	and	t6, 0xff, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t2, 8(a1)	# L : load final src word
+	nop
+	ext7b	t2, a1, t0	# U : extract low bits for last word (stall)
+	or	t1, t0, t1	# E : (stall)
+
+1:	cmpgeb	zero, t1, t7	# E :
+	mov	t1, t0
+
+$u_eocfin:			# end-of-count, final word
+	or	t10, t7, t7	# E :
+	br	$u_final	# L0 : Latency=3
+
+	/* Unaligned copy entry point.  */
+	.align 4
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# L : load first source word
+	and	a0, 7, t4	# E : find dest misalignment
+	and	a1, 7, t5	# E : find src misalignment
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+	mov	zero, t0	# E :
+
+	mov	zero, t6	# E :
+	beq	t4, 1f		# U :
+	ldl_u	t0, 0(a0)	# L :
+	ldi	t6, -1		# E :
+
+	mask3b	t6, a0, t6	# U :
+	nop
+	nop
+1:	subl	a1, t4, a1	# E : sub dest misalignment from src addr
+
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+
+	cmplt	t4, t5, t8	# E :
+	ext3b	t1, a1, t1	# U : shift src into place
+	ldi	t2, -1		# E : for creating masks later
+	beq	t8, $u_head	# U : (stall)
+
+	mask7b	t2, t5, t2	# U : begin src byte validity mask
+	cmpgeb	zero, t1, t7	# E : is there a zero?
+	ext3b	t2, a1, t2	# U :
+	or	t7, t10, t5	# E : test for end-of-count too
+
+	cmpgeb	zero, t2, t3	# E :
+	seleq	a2, t5, t7, t7	# E : Latency=2, extra map slot
+	nop			# E : keep with seleq
+	andnot	t7, t3, t7	# E : (stall)
+
+	beq	t7, $u_head	# U :
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+	ldl_u	t0, 0(a0)	# L :
+	negl	t7, t6		# E : build bitmask of bytes <= zero
+	mask7b	t1, t4, t1	# U :
+
+	and	t6, t7, t8	# E :
+	subl	t8, 1, t6	# E : (stall)
+	or	t6, t8, t7	# E : (stall)
+	zapnot	t2, t7, t2	# U : prepare source word; mirror changes (stall)
+
+	zapnot	t1, t7, t1	# U : to source validity mask
+	andnot	t0, t2, t0	# E : zero place for source to reside
+	or	t0, t1, t0	# E : and put it there (stall both t0, t1)
+	stl_u	t0, 0(a0)	# L : (stall)
+
+	ret	(t9)		# L0 : Latency=3
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/sw6b/sub_n.S b/sysdeps/sw_64/sw6b/sub_n.S
new file mode 100644
index 00000000..d7fa7a0d
--- /dev/null
+++ b/sysdeps/sw_64/sw6b/sub_n.S
@@ -0,0 +1,147 @@
+ # Sw_64 __mpn_sub_n -- Subtract two limb vectors of the same length > 0 and
+ # store difference in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_sub_n
+	.ent	__mpn_sub_n
+__mpn_sub_n:
+	.frame	$30,0,$26,0
+
+	or	$31,$31,$25		# clear cy
+	subl	$19,4,$19		# decr loop cnt
+	blt	$19,.Lend2		# if less than 4 limbs, goto 2nd loop
+ # Start software pipeline for 1st loop
+	ldl	$0,0($18)
+	ldl	$1,8($18)
+	ldl	$4,0($17)
+	ldl	$5,8($17)
+	addl	$17,32,$17		# update s1_ptr
+	ldl	$2,16($18)
+	subl	$4,$0,$20		# 1st main sub
+	ldl	$3,24($18)
+	subl	$19,4,$19		# decr loop cnt
+	ldl	$6,-16($17)
+	cmpult	$4,$20,$25		# compute cy from last sub
+	ldl	$7,-8($17)
+	addl	$1,$25,$28		# cy add
+	addl	$18,32,$18		# update s2_ptr
+	subl	$5,$28,$21		# 2nd main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	blt	$19,.Lend1		# if less than 4 limbs remain, jump
+ # 1st loop handles groups of 4 limbs in a software pipeline
+	.align	4
+.Loop:	cmpult	$5,$21,$25		# compute cy from last add
+	ldl	$0,0($18)
+	or	$8,$25,$25		# combine cy from the two fadds
+	ldl	$1,8($18)
+	addl	$2,$25,$28		# cy add
+	ldl	$4,0($17)
+	subl	$6,$28,$22		# 3rd main sub
+	ldl	$5,8($17)
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$6,$22,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	subl	$7,$28,$23		# 4th main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$7,$23,$25		# compute cy from last add
+	addl	$17,32,$17		# update s1_ptr
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	addl	$0,$25,$28		# cy add
+	ldl	$2,16($18)
+	subl	$4,$28,$20		# 1st main sub
+	ldl	$3,24($18)
+	cmpult	$28,$25,$8		# compute cy from last add
+	ldl	$6,-16($17)
+	cmpult	$4,$20,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	or	$8,$25,$25		# combine cy from the two fadds
+	subl	$19,4,$19		# decr loop cnt
+	stl	$22,-16($16)
+	addl	$1,$25,$28		# cy add
+	stl	$23,-8($16)
+	subl	$5,$28,$21		# 2nd main sub
+	addl	$18,32,$18		# update s2_ptr
+	cmpult	$28,$25,$8		# compute cy from last add
+	bge	$19,.Loop
+ # Finish software pipeline for 1st loop
+.Lend1:	cmpult	$5,$21,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$2,$25,$28		# cy add
+	subl	$6,$28,$22		# 3rd main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$6,$22,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	subl	$7,$28,$23		# 4th main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$7,$23,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	stl	$22,-16($16)
+	stl	$23,-8($16)
+.Lend2:	addl	$19,4,$19		# restore loop cnt
+	beq	$19,.Lret
+ # Start software pipeline for 2nd loop
+	ldl	$0,0($18)
+	ldl	$4,0($17)
+	subl	$19,1,$19
+	beq	$19,.Lend0
+ # 2nd loop handles remaining 1-3 limbs
+	.align	4
+.Loop0:	addl	$0,$25,$28		# cy add
+	ldl	$0,8($18)
+	subl	$4,$28,$20		# main sub
+	ldl	$1,8($17)
+	addl	$18,8,$18
+	cmpult	$28,$25,$8		# compute cy from last add
+	addl	$17,8,$17
+	stl	$20,0($16)
+	cmpult	$4,$20,$25		# compute cy from last add
+	subl	$19,1,$19		# decr loop cnt
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,8,$16
+	or	$1,$31,$4
+	bne	$19,.Loop0
+.Lend0:	addl	$0,$25,$28		# cy add
+	subl	$4,$28,$20		# main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$4,$20,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+
+.Lret:	or	$25,$31,$0		# return cy
+	ret	$31,($26),1
+	.end	__mpn_sub_n
diff --git a/sysdeps/sw_64/sw8a/Implies b/sysdeps/sw_64/sw8a/Implies
new file mode 100644
index 00000000..4192bd22
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/Implies
@@ -0,0 +1 @@
+sw_64/sw8a
diff --git a/sysdeps/sw_64/sw8a/add_n.S b/sysdeps/sw_64/sw8a/add_n.S
new file mode 100644
index 00000000..26e9c698
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/add_n.S
@@ -0,0 +1,146 @@
+ # Sw_64 __mpn_add_n -- Add two limb vectors of the same length > 0 and
+ # store sum in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_add_n
+	.ent	__mpn_add_n
+__mpn_add_n:
+	.frame	$30,0,$26,0
+
+	or	$31,$31,$25		# clear cy
+	subl	$19,4,$19		# decr loop cnt
+	blt	$19,.Lend2		# if less than 4 limbs, goto 2nd loop
+ # Start software pipeline for 1st loop
+	ldl	$0,0($18)
+	ldl	$1,8($18)
+	ldl	$4,0($17)
+	ldl	$5,8($17)
+	addl	$17,32,$17		# update s1_ptr
+	ldl	$2,16($18)
+	addl	$0,$4,$20		# 1st main add
+	ldl	$3,24($18)
+	subl	$19,4,$19		# decr loop cnt
+	ldl	$6,-16($17)
+	cmpult	$20,$0,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	addl	$1,$25,$28		# cy add
+	addl	$18,32,$18		# update s2_ptr
+	addl	$5,$28,$21		# 2nd main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	blt	$19,.Lend1		# if less than 4 limbs remain, jump
+ # 1st loop handles groups of 4 limbs in a software pipeline
+	.align	4
+.Loop:	cmpult	$21,$28,$25		# compute cy from last add
+	ldl	$0,0($18)
+	or	$8,$25,$25		# combine cy from the two fadds
+	ldl	$1,8($18)
+	addl	$2,$25,$28		# cy add
+	ldl	$4,0($17)
+	addl	$28,$6,$22		# 3rd main add
+	ldl	$5,8($17)
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$22,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	addl	$28,$7,$23		# 4th main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$23,$28,$25		# compute cy from last add
+	addl	$17,32,$17		# update s1_ptr
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	addl	$0,$25,$28		# cy add
+	ldl	$2,16($18)
+	addl	$4,$28,$20		# 1st main add
+	ldl	$3,24($18)
+	cmpult	$28,$25,$8		# compute cy from last add
+	ldl	$6,-16($17)
+	cmpult	$20,$28,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	or	$8,$25,$25		# combine cy from the two fadds
+	subl	$19,4,$19		# decr loop cnt
+	stl	$22,-16($16)
+	addl	$1,$25,$28		# cy add
+	stl	$23,-8($16)
+	addl	$5,$28,$21		# 2nd main add
+	addl	$18,32,$18		# update s2_ptr
+	cmpult	$28,$25,$8		# compute cy from last add
+	bge	$19,.Loop
+ # Finish software pipeline for 1st loop
+.Lend1:	cmpult	$21,$28,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$2,$25,$28		# cy add
+	addl	$28,$6,$22		# 3rd main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$22,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	addl	$28,$7,$23		# 4th main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$23,$28,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	stl	$22,-16($16)
+	stl	$23,-8($16)
+.Lend2:	addl	$19,4,$19		# restore loop cnt
+	beq	$19,.Lret
+ # Start software pipeline for 2nd loop
+	ldl	$0,0($18)
+	ldl	$4,0($17)
+	subl	$19,1,$19
+	beq	$19,.Lend0
+ # 2nd loop handles remaining 1-3 limbs
+	.align	4
+.Loop0:	addl	$0,$25,$28		# cy add
+	ldl	$0,8($18)
+	addl	$4,$28,$20		# main add
+	ldl	$4,8($17)
+	addl	$18,8,$18
+	cmpult	$28,$25,$8		# compute cy from last add
+	addl	$17,8,$17
+	stl	$20,0($16)
+	cmpult	$20,$28,$25		# compute cy from last add
+	subl	$19,1,$19		# decr loop cnt
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,8,$16
+	bne	$19,.Loop0
+.Lend0:	addl	$0,$25,$28		# cy add
+	addl	$4,$28,$20		# main add
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$20,$28,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+
+.Lret:	or	$25,$31,$0		# return cy
+	ret	$31,($26),1
+	.end	__mpn_add_n
diff --git a/sysdeps/sw_64/sw8a/addmul_1.S b/sysdeps/sw_64/sw8a/addmul_1.S
new file mode 100644
index 00000000..4572fd6e
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/addmul_1.S
@@ -0,0 +1,477 @@
+ # Sw_64 sw6 mpn_addmul_1 -- Multiply a limb vector with a limb and add
+ # the result to a second limb vector.
+ #
+ #  Copyright (C) 2000-2018 Free Software Foundation, Inc.
+ #
+ #  This file is part of the GNU MP Library.
+ #
+ #  The GNU MP Library is free software; you can redistribute it and/or modify
+ #  it under the terms of the GNU Lesser General Public License as published
+ #  by the Free Software Foundation; either version 2.1 of the License, or (at
+ #  your option) any later version.
+ #
+ #  The GNU MP Library is distributed in the hope that it will be useful, but
+ #  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ #  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ #  License for more details.
+ #
+ #  You should have received a copy of the GNU Lesser General Public License
+ #  along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+ #  INPUT PARAMETERS
+ #  res_ptr	$16
+ #  s1_ptr	$17
+ #  size	$18
+ #  s2_limb	$19
+ #
+ #  This code runs at 42 cycles/limb on EV4, 18 cycles/limb on EV5, and
+ #  exactly 3.625 cycles/limb on EV6...
+ #
+ # This code was written in close cooperation with ev6 pipeline expert
+ # Steve Root (root@toober.hlo.dec.com).  Any errors are tege's fault, though.
+ #
+ #   Register usages for unrolled loop:
+ #	  0-3     mul's
+ #	  4-7     acc's
+ #	  8-15    mul results
+ #	  20,21   carry's
+ #	  22,23   save for stores
+ #
+ #   Sustains 8 mul-fadds in 29 cycles in the unrolled inner loop.
+ #
+ #   The stores can issue a cycle late so we have paired no-op's to 'catch'
+ #   them, so that further disturbance to the schedule is damped.
+ #
+ #   We couldn't pair the loads, because the entangled schedule of the
+ #   carry's has to happen on one side {0} of the machine. Note, the total
+ #   use of U0, and the total use of L0 (after attending to the stores).
+ #   which is part of the reason why....
+ #
+ #   This is a great schedule for the d_cache, a poor schedule for the
+ #   b_cache. The lockup on U0 means that any stall can't be recovered
+ #   from. Consider a ldl in L1.  say that load gets stalled because it
+ #   collides with a fill from the b_Cache. On the next cycle, this load
+ #   gets priority. If first looks at L0, and goes there. The instruction
+ #   we intended for L0 gets to look at L1, which is NOT where we want
+ #   it. It either stalls 1, because it can't go in L0, or goes there, and
+ #   causes a further instruction to stall.
+ #
+ #   So for b_cache, we're likely going to want to put one or more cycles
+ #   back into the code! And, of course, put in prefetches. For the
+ #   accumulator, flds, intent to modify.  For the fmuldiplier, you might
+ #   want ldl, evict next, if you're not wanting to use it again soon. Use
+ #   256 ahead of present pointer value. At a place where we have an mt
+ #   followed by a bookkeeping, put the bookkeeping in upper, and the
+ #   prefetch into lower.
+ #
+ #   Note, the usage of physical registers per cycle is smoothed off, as
+ #   much as possible.
+ #
+ #   Note, the ldl's and stl's are at the end of the quadpacks.  note, we'd
+ #   like not to have a ldl or stl to preceded a conditional branch in a
+ #   quadpack. The conditional branch moves the retire pointer one cycle
+ #   later.
+ #
+ #   Optimization notes:
+ #   Callee-saves regs: $9 $10 $11 $12 $13 $14 $15 $26 ?$27?
+ #   Reserved regs:	 $29 $30 $31
+ #   Free caller-saves regs in unrolled code: $24 $25 $28
+ #   We should swap some of the callee-saves regs for some of the free
+ #   caller-saves regs, saving some overhead cycles.
+ #   Most importantly, we should write fast code for the 0-7 case.
+ #   The code we use there are for the 21164, and runs at 7 cycles/limb
+ #   on the 21264.  Should not be hard, if we write specialized code for
+ #   1-7 limbs (the one for 0 limbs should be straightforward).  We then just
+ #   need a jump table indexed by the low 3 bits of the count argument.
+
+	.set	noreorder
+	.set	noat
+	.text
+
+	.globl	__mpn_addmul_1
+	.ent	__mpn_addmul_1
+__mpn_addmul_1:
+	.frame	$30,0,$26,0
+	.prologue 0
+
+	cmpult	$18,	8,	$1
+	beq	$1,	$Large
+
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$18,	1,	$18	# size--
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	umulh	$2,	$19,	$0	# $0 = prod_high
+	beq	$18,	$Lend0b		# jump if size was == 1
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$18,	1,	$18	# size--
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$4
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	beq	$18,	$Lend0a		# jump if size was == 2
+
+	.align 3
+$Loop0:	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	subl	$18,	1,	$18	# size--
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	bne	$18,	$Loop0
+$Lend0a:
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$5,	$0,	$0	# combine carries
+	addl	$4,	$0,	$0	# cy_limb = prod_high + cy
+	ret	$31,	($26),	1
+$Lend0b:
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$0,	$5,	$0
+	ret	$31,	($26),	1
+
+$Large:
+	ldi	$30,	-240($30)
+	stl	$9,	8($30)
+	stl	$10,	16($30)
+	stl	$11,	24($30)
+	stl	$12,	32($30)
+	stl	$13,	40($30)
+	stl	$14,	48($30)
+	stl	$15,	56($30)
+
+	and	$18,	7,	$20	# count for the first loop, 0-7
+	srl	$18,	3,	$18	# count for unrolled loop
+	bis	$31,	$31,	$0
+	beq	$20,	$Lunroll
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$20,	1,	$20	# size--
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	umulh	$2,	$19,	$0	# $0 = prod_high
+	beq	$20,	$Lend1b		# jump if size was == 1
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	subl	$20,	1,	$20	# size--
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$4
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	beq	$20,	$Lend1a		# jump if size was == 2
+
+	.align 3
+$Loop1:	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	subl	$20,	1,	$20	# size--
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	ldl	$2,	0($17)		# $2 = s1_limb
+	addl	$17,	8,	$17	# s1_ptr++
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	bne	$20,	$Loop1
+
+$Lend1a:
+	mull	$2,	$19,	$3	# $3 = prod_low
+	ldl	$5,	0($16)		# $5 = *res_ptr
+	addl	$4,	$0,	$0	# cy_limb = cy_limb + 'cy'
+	umulh	$2,	$19,	$4	# $4 = cy_limb
+	addl	$3,	$0,	$3	# $3 = cy_limb + prod_low
+	cmpult	$3,	$0,	$0	# $0 = carry from (cy_limb + prod_low)
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$5,	$0,	$0	# combine carries
+	addl	$4,	$0,	$0	# cy_limb = prod_high + cy
+	br	$31,	$Lunroll
+$Lend1b:
+	addl	$5,	$3,	$3
+	cmpult	$3,	$5,	$5
+	stl	$3,	0($16)
+	addl	$16,	8,	$16	# res_ptr++
+	addl	$0,	$5,	$0
+
+$Lunroll:
+	ldi	$17,	-16($17)	# L1 bookkeeping
+	ldi	$16,	-16($16)	# L1 bookkeeping
+	bis	$0,	$31,	$12
+
+ # ____ UNROLLED LOOP SOFTWARE PIPELINE STARTUP ____
+
+	ldl	$2,	16($17)		# L1
+	ldl	$3,	24($17)		# L1
+	ldi	$18,	-1($18)		# L1 bookkeeping
+	ldl	$6,	16($16)		# L1
+	ldl	$7,	24($16)		# L1
+	ldl	$0,	32($17)		# L1
+	mull	$19,	$2,	$13	# U1
+	ldl	$1,	40($17)		# L1
+	umulh	$19,	$2,	$14	# U1
+	mull	$19,	$3,	$15	# U1
+	ldi	$17,	64($17)		# L1 bookkeeping
+	ldl	$4,	32($16)		# L1
+	ldl	$5,	40($16)		# L1
+	umulh	$19,	$3,	$8	# U1
+	ldl	$2,	-16($17)	# L1
+	mull	$19,	$0,	$9	# U1
+	ldl	$3,	-8($17)		# L1
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	mull	$19,	$1,	$11	# U1
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	ldi	$16,	64($16)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	-16($16)	# L1
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	-8($16)		# L1
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	0($17)		# L1
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	8($17)		# L1
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# L0 lo + acc
+	stl	$22,	-48($16)	# L0
+	stl	$23,	-40($16)	# L1
+	mull	$19,	$3,	$15	# U1
+	addl	$8,	$21,	$8	# U0 hi mul + carry
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	ble	$18,	$Lend		# U1 bookkeeping
+
+ # ____ MAIN UNROLLED LOOP ____
+	.align 4
+$Loop:
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	0($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	8($16)		# L1
+
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	ldl	$2,	16($17)		# L1
+
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	ldl	$3,	24($17)		# L1
+
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	-32($16)	# L0
+	stl	$23,	-24($16)	# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$1,	$11	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$18,	-1($18)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	16($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	24($16)		# L1
+
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	32($17)		# L1
+
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	40($17)		# L1
+
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# U0 lo + acc
+	stl	$22,	-16($16)	# L0
+	stl	$23,	-8($16)		# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$3,	$15	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$8,	$21,	$8	# L0 hi mul + carry
+
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$17,	64($17)		# L1 bookkeeping
+	addl	$4,	$8,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	32($16)		# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	40($16)		# L1
+
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	ldl	$2,	-16($17)	# L1
+
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	ldl	$3,	-8($17)		# L1
+
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	0($16)		# L0
+	stl	$23,	8($16)		# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$1,	$11	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	bis	$31,	$31,	$31	# U1 mt
+	ldi	$16,	64($16)		# L1 bookkeeping
+	addl	$6,	$12,	$22	# U0 hi add => answer
+
+	bis	$31,	$31,	$31	# U1 mt
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	ldl	$6,	-16($16)	# L1
+
+	bis	$31,	$31,	$31	# U1 mt
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	ldl	$7,	-8($16)		# L1
+
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	ldl	$0,	0($17)		# L1
+
+	mull	$19,	$2,	$13	# U1
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	ldl	$1,	8($17)		# L1
+
+	umulh	$19,	$2,	$14	# U1
+	addl	$4,	$9,	$4	# L0 lo + acc
+	stl	$22,	-48($16)	# L0
+	stl	$23,	-40($16)	# L1
+
+	bis	$31,	$31,	$31	# L0 st slosh
+	mull	$19,	$3,	$15	# U1
+	bis	$31,	$31,	$31	# L1 st slosh
+	addl	$8,	$21,	$8	# U0 hi mul + carry
+
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	bis	$31,	$31,	$31	# L1 mt
+	bgt	$18,	$Loop		# U1 bookkeeping
+
+# ____ UNROLLED LOOP SOFTWARE PIPELINE FINISH ____
+$Lend:
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	ldl	$4,	0($16)		# L1
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	ldl	$5,	8($16)		# L1
+	umulh	$19,	$3,	$8	# U1
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	mull	$19,	$0,	$9	# U1
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	umulh	$19,	$0,	$10	# U1
+	addl	$6,	$13,	$6	# L0 lo + acc
+	stl	$22,	-32($16)	# L0
+	stl	$23,	-24($16)	# L1
+	mull	$19,	$1,	$11	# U1
+	addl	$12,	$21,	$12	# U0 hi mul + carry
+	cmpult	$6,	$13,	$20	# L0 lo add => carry
+	addl	$6,	$12,	$22	# U0 hi add => answer
+	cmpult	$22,	$12,	$21	# L0 hi add => carry
+	addl	$14,	$20,	$14	# U0 hi mul + carry
+	addl	$7,	$15,	$23	# L0 lo + acc
+	addl	$14,	$21,	$14	# U0 hi mul + carry
+	umulh	$19,	$1,	$12	# U1
+	cmpult	$23,	$15,	$20	# L0 lo add => carry
+	addl	$23,	$14,	$23	# U0 hi add => answer
+	cmpult	$23,	$14,	$21	# L0 hi add => carry
+	addl	$8,	$20,	$8	# U0 hi mul + carry
+	addl	$4,	$9,	$4	# U0 lo + acc
+	stl	$22,	-16($16)	# L0
+	stl	$23,	-8($16)		# L1
+	bis	$31,	$31,	$31	# L0 st slosh
+	addl	$8,	$21,	$8	# L0 hi mul + carry
+	cmpult	$4,	$9,	$20	# L0 lo add => carry
+	addl	$4,	$8,	$22	# U0 hi add => answer
+	cmpult	$22,	$8,	$21	# L0 hi add => carry
+	addl	$10,	$20,	$10	# U0 hi mul + carry
+	addl	$5,	$11,	$23	# L0 lo + acc
+	addl	$10,	$21,	$10	# L0 hi mul + carry
+	cmpult	$23,	$11,	$20	# L0 lo add => carry
+	addl	$23,	$10,	$23	# U0 hi add => answer
+	cmpult	$23,	$10,	$21	# L0 hi add => carry
+	addl	$12,	$20,	$12	# U0 hi mul + carry
+	stl	$22,	0($16)		# L0
+	stl	$23,	8($16)		# L1
+	addl	$12,	$21,	$0	# U0 hi mul + carry
+
+	ldl	$9,	8($30)
+	ldl	$10,	16($30)
+	ldl	$11,	24($30)
+	ldl	$12,	32($30)
+	ldl	$13,	40($30)
+	ldl	$14,	48($30)
+	ldl	$15,	56($30)
+	ldi	$30,	240($30)
+	ret	$31,	($26),	1
+
+	.end	__mpn_addmul_1
diff --git a/sysdeps/sw_64/sw8a/atomic-machine.h b/sysdeps/sw_64/sw8a/atomic-machine.h
new file mode 100644
index 00000000..1cbd5a8e
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/atomic-machine.h
@@ -0,0 +1,374 @@
+/* Copyright (C) 2003-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int16_t atomic16_t;
+typedef uint16_t uatomic16_t;
+typedef int_fast16_t atomic_fast16_t;
+typedef uint_fast16_t uatomic_fast16_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+#define __HAVE_64B_ATOMICS 1
+#define USE_ATOMIC_COMPILER_BUILTINS 0
+
+/* XXX Is this actually correct?  */
+#define ATOMIC_EXCHANGE_USES_CAS 1
+
+
+#ifdef UP
+# define __MB		/* nothing */
+#else
+//# define __MB		"	mb\n"
+# define __MB		"	memb\n"   //HUANGLM20161018
+#endif
+
+
+/* Compare and exchange.  For all of the "xxx" routines, we expect a
+   "__prev" and a "__cmp" variable to be provided by the enclosing scope,
+   in which values are returned.  */
+//delete memb after the rd_f by XWB20170510
+#define __arch_compare_and_exchange_xxx_8_int(mem, new, old, mb1, mb2)  \
+({                                                                      \
+  unsigned long __tmp, __snew, __addr64;                                \
+  __asm__ __volatile__ (                                                \
+        "       bic  %[__addr8],7,%[__addr64]\n"                        \
+        "       inslb   %[__new],%[__addr8],%[__snew]\n"                \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       extlb   %[__tmp],%[__addr8],%[__prev]\n"                \
+        "       cmpeq   %[__prev],%[__old],%[__cmp]\n"                  \
+        "       beq     %[__cmp],2f\n"                                  \
+        "       masklb   %[__tmp],%[__addr8],%[__tmp]\n"                \
+        "       or      %[__snew],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       beq     %[__tmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__snew] "=&r" (__snew),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr8] "r" (mem),                                          \
+          [__old] "Ir" ((uint64_t)(uint8_t)(uint64_t)(old)),            \
+          [__new] "r" (new)                                             \
+        : "memory");                                                    \
+})
+
+#define __arch_compare_and_exchange_xxx_16_int(mem, new, old, mb1, mb2) \
+({                                                                      \
+  unsigned long __tmp, __snew, __addr64;                                \
+  __asm__ __volatile__ (                                                \
+        "       bic  %[__addr16],7,%[__addr64]\n"                    	\
+        "       inslh   %[__new],%[__addr16],%[__snew]\n"               \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       extlh   %[__tmp],%[__addr16],%[__prev]\n"               \
+        "       cmpeq   %[__prev],%[__old],%[__cmp]\n"                  \
+        "       beq     %[__cmp],2f\n"                                  \
+        "       masklh   %[__tmp],%[__addr16],%[__tmp]\n"               \
+        "       or      %[__snew],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       beq     %[__tmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__snew] "=&r" (__snew),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr16] "r" (mem),                                         \
+          [__old] "Ir" ((uint64_t)(uint16_t)(uint64_t)(old)),           \
+          [__new] "r" (new)                                             \
+        : "memory");                                                    \
+})
+/* HUANGLM20161018  */
+#define __arch_compare_and_exchange_xxx_32_int(mem, new, old, mb1, mb2) \
+({									\
+  unsigned long  __addr;                                                \
+__asm__ __volatile__ (                                                  \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldw    %[__prev],0(%[__addr])\n"                       \
+        "       cmpeq   %[__prev],%[__old],%[__cmp]\n"                  \
+        "       beq     %[__cmp],2f\n"                                  \
+        "       mov     %[__new],%[__cmp]\n"                            \
+        "       lstw    %[__cmp],0(%[__addr])\n"                        \
+        "       beq     %[__cmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__old] "Ir" ((uint64_t)(atomic32_t)(uint64_t)(old)),         \
+          [__new] "Ir" (new)                                            \
+        : "memory");                                                    \
+})
+
+#define __arch_compare_and_exchange_xxx_64_int(mem, new, old, mb1, mb2) \
+({                                                                      \
+  unsigned long  __addr;                                                \
+  __asm__ __volatile__ (                                                \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldl    %[__prev],0(%[__addr])\n"                       \
+        "       cmpeq   %[__prev],%[__old],%[__cmp]\n"                  \
+        "       beq     %[__cmp],2f\n"                                  \
+        "       mov     %[__new],%[__cmp]\n"                            \
+        "       lstl    %[__cmp],0(%[__addr])\n"                        \
+        "       beq     %[__cmp],1b\n"                                  \
+        "2:"                                                            \
+        : [__prev] "=&r" (__prev),                                      \
+          [__cmp] "=&r" (__cmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__old] "Ir" ((uint64_t)(old)),                               \
+          [__new] "Ir" (new)                                            \
+        : "memory");                                                    \
+})
+/* For all "bool" routines, we return FALSE if exchange succesful.  */
+
+#define __arch_compare_and_exchange_bool_8_int(mem, new, old, mb1, mb2)	\
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_8_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+#define __arch_compare_and_exchange_bool_16_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_16_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+#define __arch_compare_and_exchange_bool_32_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_32_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+#define __arch_compare_and_exchange_bool_64_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_64_int(mem, new, old, mb1, mb2);	\
+   !__cmp; })
+
+/* For all "val" routines, return the old value whether exchange
+   successful or not.  */
+
+#define __arch_compare_and_exchange_val_8_int(mem, new, old, mb1, mb2)	\
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_8_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+#define __arch_compare_and_exchange_val_16_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_16_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+#define __arch_compare_and_exchange_val_32_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_32_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+#define __arch_compare_and_exchange_val_64_int(mem, new, old, mb1, mb2) \
+({ unsigned long __prev; int __cmp;					\
+   __arch_compare_and_exchange_xxx_64_int(mem, new, old, mb1, mb2);	\
+   (typeof (*mem))__prev; })
+
+/* Compare and exchange with "acquire" semantics, ie barrier after.  */
+
+#define atomic_compare_and_exchange_bool_acq(mem, new, old)	\
+  __atomic_bool_bysize (__arch_compare_and_exchange_bool, int,	\
+		        mem, new, old, "", __MB)
+
+#define atomic_compare_and_exchange_val_acq(mem, new, old)	\
+  __atomic_val_bysize (__arch_compare_and_exchange_val, int,	\
+		       mem, new, old, "", __MB)
+
+/* Compare and exchange with "release" semantics, ie barrier before.  */
+
+#define atomic_compare_and_exchange_val_rel(mem, new, old)	\
+  __atomic_val_bysize (__arch_compare_and_exchange_val, int,	\
+		       mem, new, old, __MB, "")
+
+
+/* Atomically store value and return the previous value.  */
+
+#define __arch_exchange_8_int(mem, value, mb1, mb2)                     \
+({                                                                      \
+  unsigned long __tmp, __addr64, __sval; __typeof(*mem) __ret;   \
+  __asm__ __volatile__ (                                                \
+        "       bic  %[__addr8],7,%[__addr64]\n"                     	\
+        "       inslb   %[__value],%[__addr8],%[__sval]\n"              \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       extlb   %[__tmp],%[__addr8],%[__ret]\n"                 \
+        "       masklb   %[__tmp],%[__addr8],%[__tmp]\n"                \
+        "       or      %[__sval],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__sval] "=&r" (__sval),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr8] "r" (mem),                                          \
+          [__value] "r" (value)                                         \
+        : "memory");                                                    \
+  __ret; })
+
+#define __arch_exchange_16_int(mem, value, mb1, mb2)                    \
+({                                                                      \
+  unsigned long __tmp, __addr64, __sval, __tmp1; __typeof(*mem) __ret;   \
+  __asm__ __volatile__ (                                                \
+        "       bic  %[__addr16],7,%[__addr64]\n"                       \
+        "       inslh   %[__value],%[__addr16],%[__sval]\n"             \
+        "1:     lldl    %[__tmp],0(%[__addr64])\n"                      \
+        "       extlh   %[__tmp],%[__addr16],%[__ret]\n"                \
+        "       masklh   %[__tmp],%[__addr16],%[__tmp]\n"               \
+        "       or      %[__sval],%[__tmp],%[__tmp]\n"                  \
+        "       lstl    %[__tmp],0(%[__addr64])\n"                      \
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__sval] "=&r" (__sval),                                      \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr64] "=&r" (__addr64)                                   \
+        : [__addr16] "r" (mem),                                         \
+          [__value] "r" (value)                                         \
+        : "memory");                                                    \
+  __ret; })
+/* HUANGLM20161018 */
+#define __arch_exchange_32_int(mem, value, mb1, mb2)                    \
+({                                                                      \
+  signed int __tmp; __typeof(*mem) __ret;                               \
+  unsigned long __addr;                                                 \
+  __asm__ __volatile__ (                                                \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldw    %[__ret],0(%[__addr])\n"                        \
+        "       mov     %[__val],%[__tmp]\n"                            \
+        "       lstw    %[__tmp],0(%[__addr])\n"                        \
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" (value)                                          \
+        : "memory");                                                    \
+  __ret; })
+
+#define __arch_exchange_64_int(mem, value, mb1, mb2)                    \
+({                                                                      \
+  unsigned long __tmp,__addr; __typeof(*mem) __ret;                     \
+  __asm__ __volatile__ (                                                \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldl    %[__ret],0(%[__addr])\n"                        \
+        "       mov     %[__val],%[__tmp]\n"                            \
+        "       lstl    %[__tmp],0(%[__addr])\n"                        \
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" (value)                                          \
+        : "memory");                                                    \
+  __ret; })
+
+#define atomic_exchange_acq(mem, value) \
+  __atomic_val_bysize (__arch_exchange, int, mem, value, "", __MB)
+
+#define atomic_exchange_rel(mem, value) \
+  __atomic_val_bysize (__arch_exchange, int, mem, value, __MB, "")
+
+
+/* Atomically add value and return the previous (unincremented) value.  */
+
+#define __arch_exchange_and_add_8_int(mem, value, mb1, mb2) \
+  ({ __builtin_trap (); 0; })
+
+#define __arch_exchange_and_add_16_int(mem, value, mb1, mb2) \
+  ({ __builtin_trap (); 0; })
+
+/* HUAGNLM20161018 */
+#define __arch_exchange_and_add_32_int(mem, value, mb1, mb2)            \
+({                                                                      \
+  signed int __tmp; __typeof(*mem) __ret;                               \
+  unsigned long __addr;                                                 \
+  __asm__ __volatile__ (                                                \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldw    %[__ret],0(%[__addr])\n"                        \
+        "       addw    %[__ret],%[__val],%[__tmp]\n"                   \
+        "       lstw    %[__tmp],0(%[__addr])\n"                        \
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" ((signed int)(value))                            \
+        : "memory");                                                    \
+  __ret; })
+
+#define __arch_exchange_and_add_64_int(mem, value, mb1, mb2)            \
+({                                                                      \
+  unsigned long __tmp,__addr; __typeof(*mem) __ret;                     \
+  __asm__ __volatile__ (                                                \
+        "       ldi     %[__addr],%[__mem]\n"                           \
+        "1:     lldl    %[__ret],0(%[__addr])\n"                        \
+        "       addl    %[__ret],%[__val],%[__tmp]\n"                   \
+        "       lstl    %[__tmp],0(%[__addr])\n"                        \
+        "       beq     %[__tmp],1b\n"                                  \
+        : [__ret] "=&r" (__ret),                                        \
+          [__tmp] "=&r" (__tmp),                                        \
+          [__addr] "=&r" (__addr)                                       \
+        : [__mem] "m" (*(mem)),                                         \
+          [__val] "Ir" ((unsigned long)(value))                         \
+        : "memory");                                                    \
+  __ret; })
+
+/* ??? Barrier semantics for atomic_exchange_and_add appear to be
+   undefined.  Use full barrier for now, as that's safe.  */
+#define atomic_exchange_and_add(mem, value) \
+  __atomic_val_bysize (__arch_exchange_and_add, int, mem, value, __MB, __MB)
+
+
+/* ??? Blah, I'm lazy.  Implement these later.  Can do better than the
+   compare-and-exchange loop provided by generic code.
+
+#define atomic_decrement_if_positive(mem)
+#define atomic_bit_test_set(mem, bit)
+
+*/
+#ifdef HUANGLM20161018
+#ifndef UP
+# define atomic_full_barrier()	__asm ("mb" : : : "memory");
+# define atomic_read_barrier()	__asm ("mb" : : : "memory");
+# define atomic_write_barrier()	__asm ("wmb" : : : "memory");
+#endif
+#else
+#ifndef UP
+# define atomic_full_barrier()	__asm ("memb" : : : "memory");
+# define atomic_read_barrier()	__asm ("memb" : : : "memory");
+# define atomic_write_barrier()	__asm ("memb" : : : "memory");
+#endif
+#endif
diff --git a/sysdeps/sw_64/sw8a/lshift.S b/sysdeps/sw_64/sw8a/lshift.S
new file mode 100644
index 00000000..1b7f3f98
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/lshift.S
@@ -0,0 +1,172 @@
+ # Sw_64 EV5 __mpn_lshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 3.25 cycles/limb on the EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_lshift
+	.ent	__mpn_lshift
+__mpn_lshift:
+	.frame	$30,0,$26,0
+
+	s8addl	$18,$17,$17	# make r17 point at end of s1
+	ldl	$4,-8($17)	# load first limb
+	subl	$31,$19,$20
+	s8addl	$18,$16,$16	# make r16 point at end of RES
+	subl	$18,1,$18
+	and	$18,4-1,$28	# number of limbs in first loop
+	srl	$4,$20,$0	# compute function result
+
+	beq	$28,.L0
+	subl	$18,$28,$18
+
+	.align	3
+.Loop0:	ldl	$3,-16($17)
+	subl	$16,8,$16
+	sll	$4,$19,$5
+	subl	$17,8,$17
+	subl	$28,1,$28
+	srl	$3,$20,$6
+	or	$3,$3,$4
+	or	$5,$6,$8
+	stl	$8,0($16)
+	bne	$28,.Loop0
+
+.L0:	sll	$4,$19,$24
+	beq	$18,.Lend
+ # warm up phase 1
+	ldl	$1,-16($17)
+	subl	$18,4,$18
+	ldl	$2,-24($17)
+	ldl	$3,-32($17)
+	ldl	$4,-40($17)
+	beq	$18,.Lend1
+ # warm up phase 2
+	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	ldl	$1,-48($17)
+	sll	$2,$19,$22
+	ldl	$2,-56($17)
+	srl	$3,$20,$5
+	or	$7,$24,$7
+	sll	$3,$19,$23
+	or	$8,$21,$8
+	srl	$4,$20,$6
+	ldl	$3,-64($17)
+	sll	$4,$19,$24
+	ldl	$4,-72($17)
+	subl	$18,4,$18
+	beq	$18,.Lend2
+	.align  4
+ # main loop
+.Loop:	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+
+	srl	$1,$20,$7
+	subl	$18,4,$18
+	sll	$1,$19,$21
+	unop	# ldl	$31,-96($17)
+
+	srl	$2,$20,$8
+	ldl	$1,-80($17)
+	sll	$2,$19,$22
+	ldl	$2,-88($17)
+
+	stl	$5,-24($16)
+	or	$7,$24,$7
+	stl	$6,-32($16)
+	or	$8,$21,$8
+
+	srl	$3,$20,$5
+	unop	# ldl	$31,-96($17)
+	sll	$3,$19,$23
+	subl	$16,32,$16
+
+	srl	$4,$20,$6
+	ldl	$3,-96($17)
+	sll	$4,$19,$24
+	ldl	$4,-104($17)
+
+	subl	$17,32,$17
+	bne	$18,.Loop
+ # cool down phase 2/1
+.Lend2:	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	sll	$2,$19,$22
+	stl	$5,-24($16)
+	or	$7,$24,$7
+	stl	$6,-32($16)
+	or	$8,$21,$8
+	srl	$3,$20,$5
+	sll	$3,$19,$23
+	srl	$4,$20,$6
+	sll	$4,$19,$24
+ # cool down phase 2/2
+	stl	$7,-40($16)
+	or	$5,$22,$5
+	stl	$8,-48($16)
+	or	$6,$23,$6
+	stl	$5,-56($16)
+	stl	$6,-64($16)
+ # cool down phase 2/3
+	stl	$24,-72($16)
+	ret	$31,($26),1
+
+ # cool down phase 1/1
+.Lend1:	srl	$1,$20,$7
+	sll	$1,$19,$21
+	srl	$2,$20,$8
+	sll	$2,$19,$22
+	srl	$3,$20,$5
+	or	$7,$24,$7
+	sll	$3,$19,$23
+	or	$8,$21,$8
+	srl	$4,$20,$6
+	sll	$4,$19,$24
+ # cool down phase 1/2
+	stl	$7,-8($16)
+	or	$5,$22,$5
+	stl	$8,-16($16)
+	or	$6,$23,$6
+	stl	$5,-24($16)
+	stl	$6,-32($16)
+	stl	$24,-40($16)
+	ret	$31,($26),1
+
+.Lend:	stl	$24,-8($16)
+	ret	$31,($26),1
+	.end	__mpn_lshift
diff --git a/sysdeps/sw_64/sw8a/memcpy.S b/sysdeps/sw_64/sw8a/memcpy.S
new file mode 100644
index 00000000..8a7b7d12
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/memcpy.S
@@ -0,0 +1,323 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   sw6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Much of the information about 21264 scheduling/coding comes from:
+ *	Compiler Writer's Guide for the Sw_64 21264
+ *	abbreviated as 'CWG' in other comments here
+ *	ftp.digital.com/pub/Digital/info/semiconductor/literature/dsc-library.html
+ * Scheduling notation:
+ *	E	- either cluster
+ *	U	- upper subcluster; U0 - subcluster U0; U1 - subcluster U1
+ *	L	- lower subcluster; L0 - subcluster L0; L1 - subcluster L1
+ *
+ * Temp usage notes:
+ *	$0		- destination address
+ *	$1,$2,		- scratch
+ */
+
+#include <sysdep.h>
+
+#	.arch ev6
+	.set noreorder
+	.set noat
+ 	.align  4
+#        .globl memcpy
+ #       .ent memcpy
+
+        
+	.type $jmppointh,@object
+$jumppointh:
+        .gprel32        $both_0mod8
+        .gprel32        J$H01
+        .gprel32        J$H02
+        .gprel32        J$H03
+        .gprel32        J$H04
+        .gprel32        J$H05
+        .gprel32        J$H06
+        .gprel32        J$H07
+
+ENTRY(memcpy)
+#memcpy:
+	.prologue 1
+
+	ldgp	$29, 0($27)
+	
+	mov	$16, $0			# E : copy dest to return
+#	mov	$16, $1
+	ble	$18, $nomoredata	# U : done with the copy?
+        cmplt	$18, 8, $1
+        bne 	$1, $less_8
+
+	/* source and dest are same mod 8 address */
+	and	$16, 7, $1		# E : Are both 0mod8?
+	beq	$1, $both_0mod8		# U : Yes
+	nop				# E :
+
+	/*
+	 * source and dest are same misalignment.  move a byte at a time
+	 * until a 0mod8 alignment for both is reached.
+	 * At least one byte more to move
+	 */
+
+        ldi   $2, 8
+        subl  $2, $1, $1
+
+$head_align:
+        addl   $16, $1, $16
+        addl   $17, $1, $17
+        subl   $18, $1, $18
+        ldih    $2, $jumppointh($29)    !gprelhigh
+        s4addl $1, $2, $2
+        ldw    $2, $jumppointh($2)      !gprellow
+        addl   $2, $29, $2
+        jmp    ($2)
+
+$both_0mod8:
+	cmple	$18, 127, $1		# E : Can we unroll the loop?
+	bne	$1, $no_unroll		# U :
+
+
+$do_unroll:
+	ldih	$1, 8($31)		# big than 512K
+	cmple	$18, $1, $1
+	beq	$1, $unroll_body_512
+	nop 
+	nop 
+
+$unroll_body:
+	ldl	$6, 0($17)		# L0 : bytes 0..7
+	nop				# E :
+	nop				# E :
+
+	ldl	$4, 8($17)		# L : bytes 8..15
+	ldl	$5, 16($17)		# L : bytes 16..23
+	nop				# E :
+	nop				# E :
+
+	ldl	$3, 24($17)		# L : bytes 24..31
+	nop				# E :
+	nop				# E :
+
+	stl	$6, 0($16)		# L : bytes 0..7
+	nop				# E :
+	nop				# E :
+
+	stl	$4, 8($16)		# L : bytes 8..15
+	stl	$5, 16($16)		# L : bytes 16..23
+	nop				# E :
+
+	stl	$3, 24($16)		# L : bytes 24..31
+	nop				# E :
+	nop				# E :
+
+	ldl	$22, 32($17)		# L : bytes 0..7
+	ldl	$23, 40($17)		# L : bytes 8..15
+					# fallback wh64 address if < 2 more trips
+	nop				# E :
+	nop				# E :
+
+	ldl	$24, 48($17)		# L : bytes 16..23
+	ldl	$25, 56($17)		# L : bytes 24..31
+	stl	$22, 32($16)		# L : bytes 0..7
+	stl	$23, 40($16)		# L : bytes 8..15
+	stl	$24, 48($16)		# L : bytes 16..23
+	stl	$25, 56($16)		# L : bytes 24..31
+	addl	$17, 64, $17		# E : src += 32 bytes
+	addl	$16, 64, $16		# E : dest += 32
+	subl	$18, 64, $18		# E : count -= 64
+
+
+	nop				# E :
+	cmple	$18, 63, $1		# E : At least one more trip?
+	beq	$1, $unroll_body
+	nop
+	nop
+	nop
+	br	$tail_quads
+
+$unroll_body_512:
+#	fillcs	128*4($17)
+	e_fillcs 128*20($17)  #org
+	
+	ldl     $6, 0($17)              # L0 : bytes 0..7
+        nop                             # E :
+        nop                             # E :
+
+        ldl     $4, 8($17)              # L : bytes 8..15
+        ldl     $5, 16($17)             # L : bytes 16..23
+        nop                             # E :
+        nop                             # E :
+
+        ldl     $3, 24($17)             # L : bytes 24..31
+        nop                             # E :
+        nop                             # E :
+
+        stl     $6, 0($16)              # L : bytes 0..7
+        nop                             # E :
+        nop                             # E :
+
+        stl     $4, 8($16)              # L : bytes 8..15
+        stl     $5, 16($16)             # L : bytes 16..23
+        nop                             # E :
+
+        stl     $3, 24($16)             # L : bytes 24..31
+        nop                             # E :
+        nop                             # E :
+
+	nop                             # E :
+        nop                             # E :
+
+        ldl     $22, 32($17)            # L : bytes 0..7
+        ldl     $23, 40($17)            # L : bytes 8..15
+                                        # fallback wh64 address if < 2 more trips
+        nop                             # E :
+        nop                             # E :
+
+        ldl     $24, 48($17)            # L : bytes 16..23
+        ldl     $25, 56($17)            # L : bytes 24..31
+        stl     $22, 32($16)            # L : bytes 0..7
+        stl     $23, 40($16)            # L : bytes 8..15
+        stl     $24, 48($16)            # L : bytes 16..23
+        stl     $25, 56($16)            # L : bytes 24..31
+        addl    $17, 64, $17            # E : src += 32 bytes
+        addl    $16, 64, $16            # E : dest += 32
+        subl    $18, 64, $18            # E : count -= 64
+
+
+        nop                             # E :
+        cmple   $18, 63, $1             # E : At least one more trip?
+
+
+
+//	e_fillcs 128*7($16)
+
+	nop				# E :
+	beq	$1, $unroll_body_512
+
+
+$tail_quads:
+$no_unroll:
+	.align 4
+	subl	$18, 8, $18		# E : At least a quad left?
+	blt	$18, $less_than_8	# U : Nope
+	nop				# E :
+	nop				# E :
+
+$move_a_quad:
+	ldl	$1, 0($17)		# L : fetch 8
+	subl	$18, 8, $18		# E : count -= 8
+	addl	$17, 8, $17		# E : src += 8
+	nop				# E :
+
+	stl	$1, 0($16)		# L : store 8
+	addl	$16, 8, $16		# E : dest += 8
+	bge	$18, $move_a_quad	# U :
+	nop				# E :
+
+$less_than_8:
+	.align 4
+	addl	$18, 8, $18		# E : add back for trailing bytes
+	ble	$18, $nomoredata	# U : All-done
+	nop				# E :
+	nop				# E :
+
+	/* Trailing bytes */
+$tail_bytes:
+	subl	$18, 1, $18		# E : count--
+	ldbu	$1, 0($17)		# L : fetch a byte
+	addl	$17, 1, $17		# E : src++
+	nop				# E :
+
+	stb	$1, 0($16)		# L : store a byte
+	addl	$16, 1, $16		# E : dest++
+	bgt	$18, $tail_bytes	# U : more to be done?
+	nop				# E :
+
+	/* branching to exit takes 3 extra cycles, so replicate exit here */
+	ret	$31, ($26), 1		# L0 :
+	nop				# E :
+	nop				# E :
+	nop				# E :
+
+$less_8:
+	ldbu	$1, 0($17)		# L : fetch 1
+	subl	$18, 1, $18		# E : count--
+	addl	$17, 1, $17		# E : src++
+	nop				# E :
+
+	stb	$1, 0($16)		# L : store
+	addl	$16, 1, $16		# E : dest++
+	bgt	$18, $less_8		# U : more to go?
+	nop
+
+$nomoredata:
+	ret	$31, ($26), 1		# L0 :
+	nop				# E :
+	nop				# E :
+	nop				# E :
+
+J$H01:
+        ldbu    $1,-1($17)
+        stb     $1,-1($16)
+        br      $both_0mod8
+
+J$H02:
+        ldh     $1,-2($17)
+        sth     $1,-2($16)
+        br      $both_0mod8
+
+J$H03:
+        ldh     $1,-2($17)
+        ldbu    $2,-3($17)
+        sth     $1,-2($16)
+        stb     $2,-3($16)
+        br      $both_0mod8
+
+J$H04:
+        ldw     $1,-4($17)
+        stw     $1,-4($16)
+        br      $both_0mod8
+
+J$H05:
+        ldw     $1,-4($17)
+        ldbu    $2,-5($17)
+        stw     $1,-4($16)
+        stb     $2,-5($16)
+        br      $both_0mod8
+
+J$H06:
+        ldw     $1,-4($17)
+        ldh     $2,-6($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+        br      $both_0mod8
+
+J$H07:
+        ldw     $1,-4($17)
+        ldh     $2,-6($17)
+        ldbu    $3,-7($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+        stb     $3,-7($16)
+        br      $both_0mod8
+
+END(memcpy)
+libc_hidden_builtin_def (memcpy)
+
+#	.end memcpy
diff --git a/sysdeps/sw_64/sw8a/memmove.S b/sysdeps/sw_64/sw8a/memmove.S
new file mode 100644
index 00000000..46239ee6
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/memmove.S
@@ -0,0 +1,1120 @@
+/* Copy memory to memory until the specified number of bytes
+   has been copied.  Overlap is handled correctly.
+   Copyright (C) 1991-2016 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Torbjorn Granlund (tege@sics.se).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+/*
+ * Inputs:
+ *      length in $18
+ *      destination address in $16
+ *      source address in $17
+ *      return address in $26
+ *
+ * Outputs:
+ *      bytes copied in $18
+ *
+ * Clobbers:
+ *      $1,$2,$3,$4,$5,$6,$7,$8,$16,$17,$18,$24
+ *      $f10,$f11,$f12,$f13,$f15,$f17,$f22,$f23,$f24,$f25,$f26,$f27,$f28,$f29
+ */
+
+/*
+ * Author: 
+ *	memmove simd version 1.0 (20190910) by Bao Zhaoling.
+ */
+
+
+#define __LABEL(x)      x##:
+#define ENTRY(name)                             \
+  .globl name;                                  \
+  .align 4;                                     \
+  .ent name, 0;                                 \
+  __LABEL(name)                                 \
+  .frame sp, 0, ra
+#define END(sym)        .end sym
+
+
+
+
+        .type $jmppoint,@object
+$jumppoint:
+	.gprel32	$End
+	.gprel32        J$A01
+	.gprel32        J$A02
+	.gprel32        J$A03
+	.gprel32        J$A04
+	.gprel32        J$A05
+	.gprel32        J$A06
+	.gprel32        J$A07
+	.gprel32        J$A08
+	.gprel32        J$A09
+	.gprel32        J$A10
+	.gprel32        J$A11
+	.gprel32        J$A12
+	.gprel32        J$A13
+	.gprel32        J$A14
+	.gprel32        J$A15
+	.gprel32        J$A16
+	.gprel32        J$A17
+	.gprel32        J$A18
+	.gprel32        J$A19
+	.gprel32        J$A20
+	.gprel32        J$A21
+	.gprel32        J$A22
+	.gprel32        J$A23
+	.gprel32        J$A24
+	.gprel32        J$A25
+	.gprel32        J$A26
+	.gprel32        J$A27
+	.gprel32        J$A28
+	.gprel32        J$A29
+	.gprel32        J$A30
+	.gprel32        J$A31
+	.type $jmppointh,@object
+$jumppointh:
+        .gprel32        $Loopselect
+        .gprel32        J$H01
+        .gprel32        J$H02
+        .gprel32        J$H03
+        .gprel32        J$H04
+        .gprel32        J$H05
+        .gprel32        J$H06
+        .gprel32        J$H07
+        .gprel32        J$H08
+        .gprel32        J$H09
+        .gprel32        J$H10
+        .gprel32        J$H11
+        .gprel32        J$H12
+        .gprel32        J$H13
+        .gprel32        J$H14
+        .gprel32        J$H15
+        .gprel32        J$H16
+        .gprel32        J$H17
+        .gprel32        J$H18
+        .gprel32        J$H19
+        .gprel32        J$H20
+        .gprel32        J$H21
+        .gprel32        J$H22
+        .gprel32        J$H23
+        .gprel32        J$H24
+        .gprel32        J$H25
+        .gprel32        J$H26
+        .gprel32        J$H27
+        .gprel32        J$H28
+        .gprel32        J$H29
+        .gprel32        J$H30
+        .gprel32        J$H31		
+	.type $jmppoint_o,@object
+$jumppoint_o:
+        .gprel32        $End
+        .gprel32        Jo$A01
+        .gprel32        Jo$A02
+        .gprel32        Jo$A03
+        .gprel32        Jo$A04
+        .gprel32        Jo$A05
+        .gprel32        Jo$A06
+        .gprel32        Jo$A07
+        .gprel32        Jo$A08
+        .gprel32        Jo$A09
+        .gprel32        Jo$A10
+        .gprel32        Jo$A11
+        .gprel32        Jo$A12
+        .gprel32        Jo$A13
+        .gprel32        Jo$A14
+        .gprel32        Jo$A15
+        .gprel32        Jo$A16
+        .gprel32        Jo$A17
+        .gprel32        Jo$A18
+        .gprel32        Jo$A19
+        .gprel32        Jo$A20
+        .gprel32        Jo$A21
+        .gprel32        Jo$A22
+        .gprel32        Jo$A23
+        .gprel32        Jo$A24
+        .gprel32        Jo$A25
+        .gprel32        Jo$A26
+        .gprel32        Jo$A27
+        .gprel32        Jo$A28
+        .gprel32        Jo$A29
+        .gprel32        Jo$A30
+        .gprel32        Jo$A31
+ENTRY(memmove)
+#memmove:
+	.prologue 1
+	ldgp    $29, 0($27)
+	mov	$16,$0
+	ldi	$3,0($31)
+	ble	$18,$End
+	cmple	$16,$17,$2
+	beq	$2,$L2
+
+$L1:
+#	br	$opp
+        call    $at,memcpy
+        ret     $31, ($26), 1
+$L2:	
+	addl    $16,$18,$16
+        addl    $17,$18,$17
+	ldi	$24,256($31)
+#	subl	$16,$17,$6
+#	and	$6,31,$6
+#	bne	$6,$Notaligned
+
+$Headalign:
+
+	and	$16,7,$2
+	cmplt	$18,$2,$6
+	bne	$6,$Mvtail
+	subl	$18,$2,$18
+	subl	$16,$2,$16
+	subl	$17,$2,$17
+	ldih   	$25, $jumppointh($29)	!gprelhigh
+        s4addl  $2,$25,$25
+	ldw    	$25, $jumppointh($25)	!gprellow
+        addl    $25,$29,$25
+        jmp     ($25)
+	        
+$Loopselect:
+	cmple	$18,255,$6
+	bne	$6,$Endalign
+
+	and	$17, 7, $6
+	bne	$6, $beforeloop
+	and	$17, 127, $6
+	beq	$6, $beforeloop
+
+$align128:
+	 subl    $17,8,$17
+        subl    $16,8,$16
+        ldl     $1,0($17)
+        stl     $1,0($16)
+        subl    $18,8,$18
+        and     $17,127,$6
+        bne     $6,$align128
+        cmple   $18,255,$6
+        bne     $6,$Endalign
+
+$beforeloop:
+	ldi	$6, 66060288
+	cmple	$18, $6, $6
+	beq	$6, $bigLoop
+	nop
+	nop
+
+
+$Loop:
+        subl    $16,64,$16
+        subl    $17,64,$17
+        fillcs  -6*128($17)
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl    $3,16($17)
+        ldl    $4,24($17)
+        ldl     $5,32($17)
+        ldl     $6,40($17)
+        ldl    $7,48($17)
+        ldl    $8,56($17)
+        stl     $1,0($16)
+        stl      $2,8($16)
+        stl      $3,16($16)
+        stl      $4,24($16)
+        stl      $5,32($16)
+        stl      $6,40($16)
+        stl      $7,48($16)
+        stl      $8,56($16)
+        subl    $18,64,$18
+        cmple   $18,255,$6
+        beq     $6,$Loop
+        br      $Endalign
+
+$bigLoop:
+        subl    $16,64,$16
+        subl    $17,64,$17
+        fillcs  -6*128($17)
+        e_fillcs        -10*128($17)
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl    $3,16($17)
+        ldl    $4,24($17)
+        ldl     $5,32($17)
+        ldl     $6,40($17)
+        ldl    $7,48($17)
+        ldl    $8,56($17)
+        stl     $1,0($16)
+        stl      $2,8($16)
+        stl      $3,16($16)
+        stl      $4,24($16)
+        stl      $5,32($16)
+        stl      $6,40($16)
+        stl      $7,48($16)
+        stl      $8,56($16)
+        subl    $18,64,$18
+        cmple   $18,255,$6
+        beq     $6,$bigLoop
+
+
+
+$Endalign:
+	cmplt	$18,32,$6
+	beq	$6,$Mvsimd	
+	br	$Alignedtail
+
+$Mvquad:
+	cmplt   $18,8,$6
+        bne     $6,$Mvgprel32
+	subl    $17,8,$17
+        subl    $16,8,$16
+        ldl     $1,0($17)
+        stl     $1,0($16)
+        subl    $18,8,$18
+	br	$Mvquad
+
+$Mvgprel32:
+	cmplt   $18,4,$6
+        bne     $6,$Mvhalf
+	subl    $17,4,$17
+        subl    $16,4,$16
+        ldw     $1,0($17)
+        stw     $1,0($16)
+        subl    $18,4,$18
+        br	$Mvgprel32
+
+$Mvhalf:
+	cmplt   $18,2,$6
+        bne     $6,$Mvbyte
+        subl    $17,2,$17
+        subl    $16,2,$16
+        ldh     $1,0($17)
+        sth     $1,0($16)
+        subl    $18,2,$18
+        br	$Mvhalf
+
+$Mvbyte:
+	beq	$18,$End	
+	subl    $17,1,$17
+        subl    $16,1,$16
+        ldbu    $1,0($17)
+        stb     $1,0($16)
+	subl	$18,1,$18
+	br	$Mvbyte
+
+$Mvsimd:
+        subl    $17,8,$17
+        subl    $16,8,$16
+
+         ldl     $22, 0($17)
+
+        stl     $22, 0($16)
+
+	subl    $18,8,$18
+        cmplt   $18,32,$6
+        beq     $6,$Mvsimd
+
+
+
+$Alignedtail:
+	ldi	$25,$jumppoint
+	ldih   	$25, $jumppoint($29)	!gprelhigh
+	s4addl	$18,$25,$25
+	ldw	$25, $jumppoint($25)	!gprellow
+	addl	$25,$29,$25
+	jmp	($25)
+
+	
+$Mvtail:
+	and	$2,7,$6
+	beq	$6,$Alignedtail
+	and	$2,3,$6
+	beq	$6,$Mvgprel32
+	and     $2,1,$6
+        beq     $6,$Mvhalf
+	br	$Mvbyte
+
+#################################################
+J$A01:
+        ldbu    $1,-1($17)
+        stb     $1,-1($16)
+        ret	$31, ($26), 1
+J$A02:
+	ldh   	$1,-2($17)
+        sth     $1,-2($16)
+        ret	$31, ($26), 1
+J$A03:
+        ldh     $1,-2($17)
+	ldbu    $2,-3($17)
+        sth     $1,-2($16)
+	stb     $2,-3($16)
+	ret	$31, ($26), 1
+J$A04:
+        ldw     $1,-4($17)
+        stw     $1,-4($16)	
+        ret	$31, ($26), 1
+J$A05:
+        ldw     $1,-4($17)
+        ldbu    $2,-5($17)
+	stw     $1,-4($16)
+	stb     $2,-5($16)
+        ret	$31, ($26), 1
+J$A06:
+        ldw     $1,-4($17)
+        ldh    	$2,-6($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+        ret	$31, ($26), 1
+J$A07:
+        ldw     $1,-4($17)
+        ldh     $2,-6($17)
+	ldbu    $3,-7($17)
+        stw     $1,-4($16)
+        sth     $2,-6($16)
+	stb     $3,-7($16)
+        ret	$31, ($26), 1
+J$A08:
+	ldl	$1,-8($17)
+	stl	$1,-8($16)
+	ret	$31, ($26), 1
+J$A09:
+	ldl     $1,-8($17)
+	ldbu    $2,-9($17)
+        stl     $1,-8($16)
+	stb     $2,-9($16)
+	ret	$31, ($26), 1
+J$A10:
+        ldl     $1,-8($17)
+        ldh     $2,-10($17)
+        stl     $1,-8($16)
+        sth     $2,-10($16)
+	ret	$31, ($26), 1
+J$A11:
+        ldl     $1,-8($17)
+        ldh     $2,-10($17)
+	ldbu    $3,-11($17)
+        stl     $1,-8($16)
+        sth     $2,-10($16)
+	stb     $3,-11($16)
+	ret	$31, ($26), 1
+J$A12:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+	ret	$31, ($26), 1
+J$A13:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+	ldbu    $3,-13($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+	stb     $3,-13($16)
+	ret	$31, ($26), 1
+J$A14:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+        ldh    	$3,-14($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+        sth   	$3,-14($16)
+	ret	$31, ($26), 1
+J$A15:
+        ldl     $1,-8($17)
+        ldw     $2,-12($17)
+        ldh     $3,-14($17)
+	ldbu    $4,-15($17)
+        stl     $1,-8($16)
+        stw     $2,-12($16)
+        sth     $3,-14($16)
+	stb     $4,-15($16)
+	ret	$31, ($26), 1
+J$A16:	
+	ldl     $1,-8($17)
+	ldl	$2,-16($17)
+        stl     $1,-8($16)
+	stl	$2,-16($16)
+	ret	$31, ($26), 1
+J$A17:  
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+	ldbu    $3,-17($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+	stb    	$3,-17($16)
+	ret	$31, ($26), 1
+J$A18:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldh    	$3,-18($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        sth     $3,-18($16)
+	ret	$31, ($26), 1
+J$A19:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldh     $3,-18($17)
+	ldbu    $4,-19($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        sth     $3,-18($16)
+	stb     $4,-19($16)
+	ret	$31, ($26), 1
+J$A20:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+	ret	$31, ($26), 1
+J$A21:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+	ldbu    $4,-21($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+	stb     $4,-21($16)
+	ret	$31, ($26), 1
+J$A22:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+        ldh    	$4,-22($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+        sth     $4,-22($16)
+	ret	$31, ($26), 1
+J$A23:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldw     $3,-20($17)
+        ldh     $4,-22($17)
+	ldbu    $5,-23($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stw     $3,-20($16)
+        sth     $4,-22($16)
+	stb     $5,-23($16)
+	ret	$31, ($26), 1
+J$A24:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl    	$3,-24($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+	ret	$31, ($26), 1
+J$A25:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+	ldbu    $4,-25($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+	stb     $4,-25($16)
+	ret	$31, ($26), 1
+J$A26:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldh    	$4,-26($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        sth     $4,-26($16)
+	ret	$31, ($26), 1
+J$A27:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldh     $4,-26($17)
+	ldbu    $5,-27($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        sth     $4,-26($16)
+	stb     $5,-27($16)
+	ret	$31, ($26), 1
+J$A28:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+	ret	$31, ($26), 1
+J$A29:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+	ldbu    $5,-29($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+	stb     $5,-29($16)
+	ret	$31, ($26), 1
+J$A30:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+        ldh    	$5,-30($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+        sth     $5,-30($16)
+	ret	$31, ($26), 1
+J$A31:
+        ldl     $1,-8($17)
+        ldl     $2,-16($17)
+        ldl     $3,-24($17)
+        ldw     $4,-28($17)
+        ldh     $5,-30($17)
+	ldbu    $6,-31($17)
+        stl     $1,-8($16)
+        stl     $2,-16($16)
+        stl     $3,-24($16)
+        stw     $4,-28($16)
+        sth     $5,-30($16)
+	stb	$6,-31($16)
+	ret	$31, ($26), 1
+
+
+J$H01:
+	ldbu    $1,0($17)
+        stb     $1,0($16)
+        br	$Loopselect
+J$H02:
+        ldh     $1,0($17)
+        sth     $1,0($16)
+        br	$Loopselect
+J$H03:
+        ldh     $1,0($17)
+	ldbu	$2,2($17)
+        sth     $1,0($16)
+	stb	$2,2($16)
+        br      $Loopselect
+J$H04:
+        ldw     $1,0($17)
+        stw     $1,0($16)
+        br      $Loopselect
+J$H05:
+        ldw     $1,0($17)
+        ldbu    $2,4($17)
+        stw     $1,0($16)
+        stb     $2,4($16)
+        br      $Loopselect
+J$H06:
+        ldw     $1,0($17)
+        ldh     $2,4($17)
+        stw     $1,0($16)
+        sth     $2,4($16)
+        br      $Loopselect
+J$H07:
+        ldw     $1,0($17)
+        ldh     $2,4($17)
+        ldbu    $3,6($17)
+        stw     $1,0($16)
+        sth     $2,4($16)
+        stb     $3,6($16)
+        br      $Loopselect
+J$H08:
+        ldl     $1,0($17)
+        stl     $1,0($16)
+        br      $Loopselect
+J$H09:
+        ldl     $1,0($17)
+        ldbu    $2,8($17)
+        stl     $1,0($16)
+        stb     $2,8($16)
+        br      $Loopselect
+J$H10:
+        ldl     $1,0($17)
+        ldh     $2,8($17)
+        stl     $1,0($16)
+        sth     $2,8($16)
+        br      $Loopselect
+J$H11:
+        ldl     $1,0($17)
+        ldh     $2,8($17)
+        ldbu    $3,10($17)
+        stl     $1,0($16)
+        sth     $2,8($16)
+        stb     $3,10($16)
+        br      $Loopselect
+J$H12:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        stl     $1,0($16)
+        stw     $2,8($16)
+        br      $Loopselect
+J$H13:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        ldbu    $3,12($17)
+        stl     $1,0($16)
+        stw     $2,8($16)
+        stb     $3,12($16)
+        br      $Loopselect
+J$H14:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        ldh     $3,12($17)
+        stl     $1,0($16)
+        stw     $2,8($16)
+        sth     $3,12($16)
+	br      $Loopselect
+J$H15:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        ldh     $3,12($17)
+        ldbu    $4,14($17)
+        stl     $1,-0($16)
+        stw     $2,8($16)
+        sth     $3,12($16)
+        stb     $4,14($16)
+        br      $Loopselect
+J$H16:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        br      $Loopselect
+J$H17:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldbu    $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stb     $3,16($16)
+        br      $Loopselect
+J$H18:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldh     $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        sth     $3,16($16)
+        br      $Loopselect
+J$H19:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldh     $3,16($17)
+        ldbu    $4,18($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        sth     $3,16($16)
+        stb     $4,18($16)
+        br      $Loopselect
+J$H20:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        br      $Loopselect
+J$H21:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        ldbu    $4,20($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        stb     $4,20($16)
+        br      $Loopselect
+J$H22:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        ldh     $4,20($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        sth     $4,20($16)
+        br      $Loopselect
+J$H23:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        ldh     $4,20($17)
+        ldbu    $5,22($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        sth     $4,20($16)
+        stb     $5,22($16)
+        br      $Loopselect
+J$H24:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        br      $Loopselect
+J$H25:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldbu    $4,24($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stb     $4,24($16)
+        br      $Loopselect
+J$H26:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldh     $4,24($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        sth     $4,24($16)
+        br      $Loopselect
+J$H27:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldh     $4,24($17)
+        ldbu    $5,26($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        sth     $4,24($16)
+        stb     $5,26($16)
+        br      $Loopselect
+J$H28:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        br      $Loopselect
+J$H29:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        ldbu    $5,28($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        stb     $5,28($16)
+        br      $Loopselect
+J$H30:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        ldh     $5,28($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        sth     $5,28($16)
+        br      $Loopselect
+J$H31:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        ldh     $5,28($17)
+        ldbu    $6,30($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        sth     $5,28($16)
+        stb     $6,30($16)
+	br      $Loopselect
+
+######################################
+Jo$A01:
+        ldbu    $1,0($17)
+        stb     $1,0($16)
+        br      $End
+Jo$A02:
+
+        ldh     $1,0($17)
+        sth     $1,0($16)
+        br      $End
+Jo$A03:
+        ldh     $1,0($17)
+        ldbu    $2,2($17)
+        sth     $1,0($16)
+        stb     $2,2($16)
+        br      $End
+Jo$A04:
+        ldw     $1,0($17)
+        stw     $1,0($16)
+        br      $End
+Jo$A05:
+        ldw     $1,0($17)
+        ldbu    $2,4($17)
+        stw     $1,0($16)
+        stb     $2,4($16)
+        br      $End
+Jo$A06:
+        ldw     $1,0($17)
+        ldh     $2,4($17)
+        stw     $1,0($16)
+        sth     $2,4($16)
+        br      $End
+Jo$A07:
+        ldw     $1,0($17)
+        ldh     $2,4($17)
+        ldbu    $3,6($17)
+        stw     $1,0($16)
+        sth     $2,4($16)
+        stb     $3,6($16)
+        br      $End
+Jo$A08:
+        ldl     $1,0($17)
+        stl     $1,0($16)
+        br      $End
+Jo$A09:
+        ldl     $1,0($17)
+        ldbu    $2,8($17)
+        stl     $1,0($16)
+        stb     $2,8($16)
+        br      $End
+Jo$A10:
+        ldl     $1,0($17)
+        ldh     $2,8($17)
+        stl     $1,0($16)
+        sth     $2,8($16)
+        br      $End
+Jo$A11:
+        ldl     $1,0($17)
+        ldh     $2,8($17)
+        ldbu    $3,10($17)
+        stl     $1,0($16)
+        sth     $2,8($16)
+        stb     $3,10($16)
+        br      $End
+Jo$A12:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        stl     $1,0($16)
+        stw     $2,8($16)
+        br      $End
+Jo$A13:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        ldbu    $3,12($17)
+        stl     $1,0($16)
+        stw     $2,8($16)
+        stb     $3,12($16)
+        br      $End
+Jo$A14:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        ldh     $3,12($17)
+        stl     $1,0($16)
+        stw     $2,8($16)
+        sth     $3,12($16)
+        br      $End
+Jo$A15:
+        ldl     $1,0($17)
+        ldw     $2,8($17)
+        ldh     $3,12($17)
+        ldbu    $4,14($17)
+        stl     $1,-0($16)
+        stw     $2,8($16)
+        sth     $3,12($16)
+        stb     $4,14($16)
+        br      $End
+Jo$A16:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        br      $End
+Jo$A17:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldbu    $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stb     $3,16($16)
+        br      $End
+Jo$A18:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldh     $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        sth     $3,16($16)
+        br      $End
+Jo$A19:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldh     $3,16($17)
+        ldbu    $4,18($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        sth     $3,16($16)
+        stb     $4,18($16)
+        br      $End
+Jo$A20:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        br      $End
+Jo$A21:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        ldbu    $4,20($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        stb     $4,20($16)
+        br      $End
+Jo$A22:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        ldh     $4,20($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        sth     $4,20($16)
+        br      $End
+Jo$A23:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldw     $3,16($17)
+        ldh     $4,20($17)
+        ldbu    $5,22($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stw     $3,16($16)
+        sth     $4,20($16)
+        stb     $5,22($16)
+        br      $End
+Jo$A24:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        br      $End
+Jo$A25:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldbu    $4,24($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stb     $4,24($16)
+        br      $End
+Jo$A26:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldh     $4,24($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        sth     $4,24($16)
+        br      $End
+Jo$A27:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldh     $4,24($17)
+        ldbu    $5,26($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        sth     $4,24($16)
+        stb     $5,26($16)
+        br      $End
+Jo$A28:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        br      $End
+Jo$A29:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        ldbu    $5,28($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        stb     $5,28($16)
+        br      $End
+Jo$A30:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        ldh     $5,28($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        sth     $5,28($16)
+        br      $End
+Jo$A31:
+        ldl     $1,0($17)
+        ldl     $2,8($17)
+        ldl     $3,16($17)
+        ldw     $4,24($17)
+        ldh     $5,28($17)
+        ldbu    $6,30($17)
+        stl     $1,0($16)
+        stl     $2,8($16)
+        stl     $3,16($16)
+        stw     $4,24($16)
+        sth     $5,28($16)
+        stb     $6,30($16)
+        br      $End
+$End:
+	ret $31, ($26), 1	
+END(memmove)
+libc_hidden_builtin_def (memmove)
+
+	#.end memmove
diff --git a/sysdeps/sw_64/sw8a/memset.S b/sysdeps/sw_64/sw8a/memset.S
new file mode 100644
index 00000000..c613ce54
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/memset.S
@@ -0,0 +1,332 @@
+/* Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+#        .arch sw6b
+        .set noat
+        .set noreorder
+
+
+
+
+ENTRY(memset)
+#memset:
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	/*
+	 * Serious stalling happens.  The only way to mitigate this is to
+	 * undertake a major re-write to interleave the constant materialization
+	 * with other parts of the fall-through code.  This is important, even
+	 * though it makes maintenance tougher.
+	 * Do this later.
+	 */
+#	mov	$17, $22
+	and	$17, 255, $1	# E : 00000000000000ch
+	ins0b	$17, 1, $2	# U : 000000000000ch00
+	mov	$16, $0		# E : return value
+	ble	$18, $end	# U : zero length requested?
+
+	addl	$18, $16, $6	# E : max address to write to
+	or	$1, $2, $17	# E : 000000000000chch
+	ins0b	$1, 2, $3	# U : 0000000000ch0000
+	ins0b	$1, 3, $4	# U : 00000000ch000000
+
+	or	$3, $4, $3	# E : 00000000chch0000
+	ins1b	$17, 4, $5	# U : 0000chch00000000
+	xor	$16, $6, $1	# E : will complete write be within one quadword?
+	ins1b	$17, 6, $2	# U : chch000000000000
+
+	or	$17, $3, $17	# E : 00000000chchchch
+	or	$2, $5, $2	# E : chchchch00000000
+	bic	$1, 7, $1	# E : fit within a single quadword?
+	and	$16, 7, $3	# E : Target addr misalignment
+
+	or	$17, $2, $17	# E : chchchchchchchch
+
+
+	mov     $16, $5
+        beq     $1, $within_quad # U :
+        nop                     # E :
+        beq     $3, $aligned    # U : target is 0mod8
+
+
+	/*
+	 * Target address is misaligned, and won't fit within a quadword.
+	 */
+
+
+         ldi     $2, 8
+        subl    $2, $3, $3
+
+
+
+$misaligned:
+        stb     $17, 0($16)
+        subl    $18, 1, $18
+        addl    $16, 1, $16
+        subl    $3, 1, $3
+        bne     $3, $misaligned
+
+
+
+$aligned:
+	/*
+	 * We are now guaranteed to be quad aligned, with at least
+	 * one partial quad to write.
+	 */
+
+	sra	$18, 3, $3	# U : Number of remaining quads to write
+	and	$18, 7, $18	# E : Number of trailing bytes to write
+	mov	$16, $5		# E : Save dest address
+	beq	$3, $no_quad	# U : tail stuff only
+
+	/*
+	 * It's worth the effort to unroll this and use wh64 if possible.
+	 * At this point, entry values are:
+	 * $16	Current destination address
+	 * $5	A copy of $16
+	 * $6	The max quadword address to write to
+	 * $18	Number trailer bytes
+	 * $3	Number quads to write
+	 */
+#	and	$16, 0x3f, $2	# E : Forward work (only useful for unrolled loop)
+	and	$16, 0x1f, $2	# E : Forward work (only useful for unrolled loop)
+	subl	$3, 16, $4	# E : Only try to unroll if > 128 bytes
+	subl	$2, 0x40, $1	# E : bias counter (aligning stuff 0mod64)
+	blt	$4, $loop	# U :
+
+	/*
+	 * We know we've got at least 16 quads, minimum of one trip
+	 * through unrolled loop.  Do a quad at a time to get us 0mod64
+	 * aligned.
+	 */
+
+	nop			# E :
+	nop			# E :
+	nop			# E :
+#	beq	$1, $bigalign	# U :
+	beq	$2, $do_wh64	# U :
+$alignmod32:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : For consistency later
+	addl	$1, 8, $1	# E : Increment towards zero for alignment
+#	addl	$5, 8, $4	# E : Initial wh64 address (filler instruction)
+
+	nop
+	nop
+	addl	$5, 8, $5	# E : Inc address
+	blt	$1, $alignmod32 # U :
+
+
+
+	/*
+	 * $3 - number quads left to go
+	 * $5 - target address (aligned 0mod64)
+	 * $17 - mask of stuff to store
+	 * Scratch registers available: $7, $2, $4, $1
+	 * We know that we'll be taking a minimum of one trip through.
+	 * CWG Section 3.7.6: do not expect a sustained store rate of > 1/cycle
+	 * Assumes the wh64 needs to be for 2 trips through the loop in the future.
+	 * The wh64 is issued on for the starting destination address for trip +2
+	 * through the loop, and if there are less than two trips left, the target
+	 * address will be for the current trip.
+	 */
+
+$do_wh64:
+#	wh64	($4)		# L1 : memory subsystem write hint
+	subl	$3, 24, $2	# E : For determining future wh64 addresses
+	stl	$17, 0($5)	# L :
+	nop			# E :
+
+#	addl	$5, 128, $4	# E : speculative target of next wh64
+	stl	$17, 8($5)	# L :
+	stl	$17, 16($5)	# L :
+	addl	$5, 64, $7	# E : Fallback address for wh64 (== next trip addr)
+
+	stl	$17, 24($5)	# L :
+	stl	$17, 32($5)	# L :
+#	sellt	$2, $7, $4, $4	# E : Latency 2, extra mapping cycle
+	nop
+
+	stl	$17, 40($5)	# L :
+	stl	$17, 48($5)	# L :
+	subl	$3, 16, $2	# E : Repeat the loop at least once more?
+	nop
+
+	stl	$17, 56($5)	# L :
+	addl	$5, 64, $5	# E :
+	subl	$3, 8, $3	# E :
+	bge	$2, $do_wh64	# U :
+
+	nop
+	nop
+	nop
+	beq	$3, $no_quad	# U : Might have finished already
+
+	nop
+	nop
+	nop
+	.align 4
+	/*
+	 * Simple loop for trailing quadwords, or for small amounts
+	 * of data (where we can't use an unrolled loop and wh64)
+	 */
+$loop:
+	stl	$17, 0($5)	# L :
+	subl	$3, 1, $3	# E : Decrement number quads left
+	addl	$5, 8, $5	# E : Inc address
+	bne	$3, $loop	# U : more?
+
+#$no_quad:
+	/*
+	 * Write 0..7 trailing bytes.
+	 */
+#	nop			# E :
+#	beq	$18, $end	# U : All done?
+#	ldl	$7, 0($5)	# L :
+#	mask7b	$7, $6, $2	# U : Mask final quad
+#
+#	ins7b	$17, $6, $4	# U : New bits
+#	or	$2, $4, $1	# E : Put it all together
+#	stl	$1, 0($5)	# L : And back to memory
+#	ret	$31,($26),1	# L0 :
+
+#	nop			# E :
+#	beq	$18, $end	# U : All done?
+#        stb     $22, 0($5)
+#	subl	$18, 1, $18	# E : Decrement number quads left
+#	addl	$5, 1, $5	# E : Inc address
+#	bne	$18, $no_quad	# U : more?
+#        ret     $31, ($26), 1	# L0 :
+
+
+#	nop			# E :
+#	beq	$18, $end	# U : All done?
+#	cmpeq   $18, 1, $6
+#	bne     $6, J$H01
+#	cmpeq   $18, 2, $6
+#	bne     $6, J$H02
+#	cmpeq   $18, 3, $6
+#	bne     $6, J$H03
+#	cmpeq   $18, 4, $6
+#	bne     $6, J$H04
+#	cmpeq   $18, 5, $6
+#	bne     $6, J$H05
+#	cmpeq   $18, 6, $6
+#	bne     $6, J$H06
+#	br      J$H07
+
+
+$no_quad:
+        /*
+         * Write 0..7 trailing bytes.
+         */
+        nop                     # E :
+        beq     $18, $end       # U : All done?
+
+
+$within_quad1:
+
+        stb     $17, 0($5)
+        subl    $18, 1, $18
+        addl    $5, 1, $5
+        bne     $18, $within_quad1
+
+/*        ldl     $7, 0($5)       # L :
+        mask7b  $7, $6, $2      # U : Mask final quad
+
+        ins7b   $17, $6, $4     # U : New bits
+        or      $2, $4, $1      # E : Put it all together
+        stl     $1, 0($5)       # L : And back to memory
+*/
+
+        ret     $31,($26),1     # L0 :
+
+
+$within_quad:
+
+        stb     $17, 0($16)
+        subl    $18, 1, $18
+        addl    $16, 1, $16
+        bne     $18, $within_quad
+
+
+$end:
+	nop
+	nop
+	nop
+	ret $31,($26),1		# L0 :
+
+J$H01:
+#        ldbu    $1, 0($22)
+        stb     $22, 0($5)
+        ret     $31, ($26), 1           # L0 :
+
+
+J$H02:
+        ldh     $1, 0($17)
+        sth     $1, 0($16)
+        ret     $31, ($26), 1           # L0 :
+
+J$H03:
+        ldh     $1, 0($17)
+        ldbu    $2, 2($17)
+        sth     $1, 0($16)
+        stb     $2, 2($16)
+        ret     $31, ($26), 1           # L0 :
+
+J$H04:
+        ldw     $1, 0($17)
+        stw     $1, 0($16)
+        ret     $31, ($26), 1           # L0 :
+
+J$H05:
+        ldw     $1, 0($17)
+        ldbu    $2, 4($17)
+        stw     $1, 0($16)
+        stb     $2, 4($16)
+        ret     $31, ($26), 1           # L0 :
+
+J$H06:
+        ldw     $1, 0($17)
+        ldh     $2, 4($17)
+        stw     $1, 0($16)
+        sth     $2, 4($16)
+        ret     $31, ($26), 1           # L0 :
+J$H07:
+        ldw     $1, 0($17)
+        ldh     $2, 4($17)
+        ldbu    $3, 6($17)
+        stw     $1, 0($16)
+        sth     $2, 4($16)
+        stb     $3, 6($16)
+        ret     $31, ($26), 1           # L0 :
+
+
+        END(memset)
+libc_hidden_builtin_def (memset)
+#	.end memset
diff --git a/sysdeps/sw_64/sw8a/nptl/Makefile b/sysdeps/sw_64/sw8a/nptl/Makefile
new file mode 100644
index 00000000..8e63e8ad
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/Makefile
@@ -0,0 +1,20 @@
+# Copyright (C) 2003-2018 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
diff --git a/sysdeps/sw_64/sw8a/nptl/bits/struct_rwlock.h b/sysdeps/sw_64/sw8a/nptl/bits/struct_rwlock.h
new file mode 100644
index 00000000..741a5ada
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/bits/struct_rwlock.h
@@ -0,0 +1,43 @@
+/* Sw_64 internal rwlock struct definitions.
+   Copyright (C) 2019-2023 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _RWLOCK_INTERNAL_H
+#define _RWLOCK_INTERNAL_H
+
+struct __pthread_rwlock_arch_t
+{
+  unsigned int __readers;
+  unsigned int __writers;
+  unsigned int __wrphase_futex;
+  unsigned int __writers_futex;
+  unsigned int __pad3;
+  unsigned int __pad4;
+  int __cur_writer;
+  int __shared;
+  unsigned long int __pad1;
+  unsigned long int __pad2;
+  /* FLAGS must stay at this position in the structure to maintain
+     binary compatibility.  */
+  unsigned int __flags;
+};
+
+#define __PTHREAD_RWLOCK_INITIALIZER(__flags) \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, __flags
+
+#endif
diff --git a/sysdeps/sw_64/sw8a/nptl/pthread-offsets.h b/sysdeps/sw_64/sw8a/nptl/pthread-offsets.h
new file mode 100644
index 00000000..31f0587b
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/pthread-offsets.h
@@ -0,0 +1,3 @@
+#define __PTHREAD_MUTEX_KIND_OFFSET		16
+
+#define __PTHREAD_RWLOCK_FLAGS_OFFSET		48
diff --git a/sysdeps/sw_64/sw8a/nptl/pthread_spin_lock.S b/sysdeps/sw_64/sw8a/nptl/pthread_spin_lock.S
new file mode 100644
index 00000000..cb12f6fc
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/pthread_spin_lock.S
@@ -0,0 +1,43 @@
+
+
+/* Copyright (C) 2003-2016 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson  <rth@twiddle.net>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* SHIPS20171102_LOCK_READ_CONDITION_WRITE.  */
+	.text
+	.align	4
+
+	.globl	pthread_spin_lock
+	.ent	pthread_spin_lock
+pthread_spin_lock:
+	.frame	$sp, 0, $26, 0
+	.prologue 0
+0:	lldw	$1, 0($16)
+	ldi	$2, 1
+	ldi	$0, 0
+	bne	$1, 1f
+
+	lstw	$2, 0($16)
+	beq	$2, 1f
+	ret
+
+1:	ldw	$1, 0($16)
+	bne	$1, 1b
+	unop
+	br	0b
+	.end	pthread_spin_lock
diff --git a/sysdeps/sw_64/sw8a/nptl/pthread_spin_trylock.S b/sysdeps/sw_64/sw8a/nptl/pthread_spin_trylock.S
new file mode 100644
index 00000000..04d152c1
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/pthread_spin_trylock.S
@@ -0,0 +1,44 @@
+
+
+/* Copyright (C) 2003-2016 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson  <rth@twiddle.net>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* SHIPS20171102_LOCK_READ_CONDITION_WRITE.  */
+#define _ERRNO_H 1
+#include <bits/errno.h>
+
+	.text
+	.align	4
+
+	.globl	pthread_spin_trylock
+	.ent	pthread_spin_trylock
+pthread_spin_trylock:
+	.frame	$sp, 0, $26, 0
+	.prologue 0
+0:	lldw	$1, 0($16)
+	ldi	$2, 1
+	ldi	$0, EBUSY
+	bne	$1, 1f
+
+	lstw	$2, 0($16)
+	beq	$2, 2f
+	ldi	$0, 0
+
+1:	ret
+2:	br	0b
+	.end	pthread_spin_trylock
diff --git a/sysdeps/sw_64/sw8a/nptl/pthreaddef.h b/sysdeps/sw_64/sw8a/nptl/pthreaddef.h
new file mode 100644
index 00000000..b8e24095
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/pthreaddef.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 2003-2023 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(4 * 1024 * 1024)
+
+/* Minimum guard size.  */
+#define ARCH_MIN_GUARD_SIZE 0
+
+/* Required stack pointer alignment at beginning.  The ABI requires 16.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	4096
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
diff --git a/sysdeps/sw_64/sw8a/nptl/tcb-offsets.sym b/sysdeps/sw_64/sw8a/nptl/tcb-offsets.sym
new file mode 100644
index 00000000..1005621b
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/tcb-offsets.sym
@@ -0,0 +1,13 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+-- # define __builtin_thread_pointer()  ((void *) 0)
+-- # define thread_offsetof(mem)     ((void *) &THREAD_SELF->mem - (void *) 0)
+-- Ho hum, this doesn't work in gcc4, so Know Things about THREAD_SELF
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - sizeof(struct pthread))
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+TID_OFFSET			thread_offsetof (tid)
diff --git a/sysdeps/sw_64/sw8a/nptl/tls.h b/sysdeps/sw_64/sw8a/nptl/tls.h
new file mode 100644
index 00000000..5a0f7a93
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/nptl/tls.h
@@ -0,0 +1,112 @@
+/* Definition for thread-local data handling.  NPTL/Sw_64 version.
+   Copyright (C) 2003-2023 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+# include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+# include <dl-dtv.h>
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+# define TLS_TCB_AT_TP	0
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *__private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
+
+/* This is the size of the TCB.  */
+# define TLS_TCB_SIZE		sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE	sizeof (struct pthread)
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(tcbp) \
+  (__builtin_set_thread_pointer ((void *)(tcbp)), true)
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+# define TLS_DEFINE_INIT_TP(tp, pd) void *tp = (pd) + 1
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) __builtin_thread_pointer ())->dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *)__builtin_thread_pointer () - 1)
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  REGISTER (64, 64, 32 * 8, -sizeof (struct pthread))
+
+#include<tcb-access.h>
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff --git a/sysdeps/sw_64/sw8a/rshift.S b/sysdeps/sw_64/sw8a/rshift.S
new file mode 100644
index 00000000..2a020414
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/rshift.S
@@ -0,0 +1,170 @@
+ # Sw_64 EV5 __mpn_rshift --
+
+ # Copyright (C) 1994-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	r16
+ # s1_ptr	r17
+ # size		r18
+ # cnt		r19
+
+ # This code runs at 3.25 cycles/limb on the EV5.
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_rshift
+	.ent	__mpn_rshift
+__mpn_rshift:
+	.frame	$30,0,$26,0
+
+	ldl	$4,0($17)	# load first limb
+	subl	$31,$19,$20
+	subl	$18,1,$18
+	and	$18,4-1,$28	# number of limbs in first loop
+	sll	$4,$20,$0	# compute function result
+
+	beq	$28,.L0
+	subl	$18,$28,$18
+
+	.align	3
+.Loop0:	ldl	$3,8($17)
+	addl	$16,8,$16
+	srl	$4,$19,$5
+	addl	$17,8,$17
+	subl	$28,1,$28
+	sll	$3,$20,$6
+	or	$3,$3,$4
+	or	$5,$6,$8
+	stl	$8,-8($16)
+	bne	$28,.Loop0
+
+.L0:	srl	$4,$19,$24
+	beq	$18,.Lend
+ # warm up phase 1
+	ldl	$1,8($17)
+	subl	$18,4,$18
+	ldl	$2,16($17)
+	ldl	$3,24($17)
+	ldl	$4,32($17)
+	beq	$18,.Lend1
+ # warm up phase 2
+	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	ldl	$1,40($17)
+	srl	$2,$19,$22
+	ldl	$2,48($17)
+	sll	$3,$20,$5
+	or	$7,$24,$7
+	srl	$3,$19,$23
+	or	$8,$21,$8
+	sll	$4,$20,$6
+	ldl	$3,56($17)
+	srl	$4,$19,$24
+	ldl	$4,64($17)
+	subl	$18,4,$18
+	beq	$18,.Lend2
+	.align  4
+ # main loop
+.Loop:	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+
+	sll	$1,$20,$7
+	subl	$18,4,$18
+	srl	$1,$19,$21
+	unop	# ldl	$31,-96($17)
+
+	sll	$2,$20,$8
+	ldl	$1,72($17)
+	srl	$2,$19,$22
+	ldl	$2,80($17)
+
+	stl	$5,16($16)
+	or	$7,$24,$7
+	stl	$6,24($16)
+	or	$8,$21,$8
+
+	sll	$3,$20,$5
+	unop	# ldl	$31,-96($17)
+	srl	$3,$19,$23
+	addl	$16,32,$16
+
+	sll	$4,$20,$6
+	ldl	$3,88($17)
+	srl	$4,$19,$24
+	ldl	$4,96($17)
+
+	addl	$17,32,$17
+	bne	$18,.Loop
+ # cool down phase 2/1
+.Lend2:	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	srl	$2,$19,$22
+	stl	$5,16($16)
+	or	$7,$24,$7
+	stl	$6,24($16)
+	or	$8,$21,$8
+	sll	$3,$20,$5
+	srl	$3,$19,$23
+	sll	$4,$20,$6
+	srl	$4,$19,$24
+ # cool down phase 2/2
+	stl	$7,32($16)
+	or	$5,$22,$5
+	stl	$8,40($16)
+	or	$6,$23,$6
+	stl	$5,48($16)
+	stl	$6,56($16)
+ # cool down phase 2/3
+	stl	$24,64($16)
+	ret	$31,($26),1
+
+ # cool down phase 1/1
+.Lend1:	sll	$1,$20,$7
+	srl	$1,$19,$21
+	sll	$2,$20,$8
+	srl	$2,$19,$22
+	sll	$3,$20,$5
+	or	$7,$24,$7
+	srl	$3,$19,$23
+	or	$8,$21,$8
+	sll	$4,$20,$6
+	srl	$4,$19,$24
+ # cool down phase 1/2
+	stl	$7,0($16)
+	or	$5,$22,$5
+	stl	$8,8($16)
+	or	$6,$23,$6
+	stl	$5,16($16)
+	stl	$6,24($16)
+	stl	$24,32($16)
+	ret	$31,($26),1
+
+.Lend:	stl	$24,0($16)
+	ret	$31,($26),1
+	.end	__mpn_rshift
diff --git a/sysdeps/sw_64/sw8a/strcat.S b/sysdeps/sw_64/sw8a/strcat.S
new file mode 100644
index 00000000..5a6385cb
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/strcat.S
@@ -0,0 +1,306 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Append a null-terminated string from SRC to DST.  */
+
+#include <sysdep.h>
+
+	.text
+
+ENTRY(strcat)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+	# we know the return reg is v0 and v1
+
+	mov	a0, v0		# set up return value
+
+	/* Find the end of the string.  */
+
+	ldl   t0, 0(a0)	# load first quadword (a0 may be misaligned) 
+				# so we need to use ldl_u and what we cost ?
+	nop
+	nop
+	nop
+	cmpgeb  zero, t0, t1	# t1 <- bitmask: bit i == 1 <==> i-th byte == 0
+	bne     t1, $found	# 
+
+#cp string 
+$loop:
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+    ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl     t0, 8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	beq     t1, $loop
+$found:	
+	cttz t1,t2
+	addl a0,t2,a0
+	#cfi_startproc
+	#cfi_return_column (t9)
+
+	
+	.align 3
+#__stxcpy:
+	ldl 	t1, 0(a1)	# e0    : load first src word
+	addl	a1, 8, a1		# e0    :
+.align 3
+	nop
+	nop
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	cmpgeb	zero, t1, t7	# .. e1 : bits set iff null found
+	bne	t7, $a_eos	# .. e1 :
+	nop
+	nop
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == a source word not containing a null.  */
+$a_loop:
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	bne t7, $a_eos
+
+	stl	t1, 0(a0)	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	ldl	t1, 0(a1)	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0 (stall)
+	#bne t7, $a_eos
+	beq	t7, $a_loop	# .. e1 (zdb)
+
+	
+	/* Take care of the final (partial) word store.
+	   On entry to this basic block we have:
+	   t1 == the source word containing the null
+	   t7 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t7, t6		# e0    : find low bit set
+	and	t7, t6, t8	# e1 (stall)
+
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# e0    :
+	bne	t6, 1f		# .. e1 (zdb)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl	t0, 0(a0)	# e0    :
+	subl	t8, 1, t6	# .. e1 :
+	zapnot	t1, t6, t1	# e0    : clear src bytes >= null
+	or	t8, t6, t7	# .. e1 :
+	zap	t0, t7, t0	# e0    : clear dst bytes <= null
+	or	t0, t1, t1	# e1    :
+
+1:	stl	t1, 0(a0)	# e0    :
+	ret		# .. e1 :
+
+
+	END(strcat)
+libc_hidden_builtin_def (strcat)
diff --git a/sysdeps/sw_64/sw8a/strchr.S b/sysdeps/sw_64/sw8a/strchr.S
new file mode 100644
index 00000000..0bf10d3f
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/strchr.S
@@ -0,0 +1,245 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@tamu.edu)
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Return the address of a given character within a null-terminated
+   string, or null if it is not found.
+
+   This is generally scheduled for the EV5 (got to look out for my own
+   interefsts :-), but with EV4 needs in mind.  There *should* be no more
+   stalls for the EV4 than there are for the EV5.
+*/
+
+#include <sysdep.h>
+
+	.set noreorder
+	.set noat
+
+ENTRY(strchr)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+/*
+	zapnot	a1, 1, a1	# e0    : zero extend the search character
+	sll	a1, 8, t5	# e0    : replicate the search character
+	or	t5, a1, a1	# e0    :
+	sll	a1, 16, t5	# e0    :
+	or	t5, a1, a1	# .. e1 :
+	sll	a1, 32, t5	# e0    :
+	or	t5, a1, a1	# e0    :
+	subl     a0,8,v0
+*/
+	zapnot	a1, 1, a1	# e0    : zero extend the search character
+	ldl_u   t0, 0(a0)	# .. e1 : load first quadword
+	sll	a1, 8, t5	# e0    : replicate the search character
+	andnot  a0, 7, v0	# .. e1 : align our loop pointer
+	or	t5, a1, a1	# e0    :
+	ldi	t4, -1		# .. e1 : build garbage mask
+	sll	a1, 16, t5	# e0    :
+	cmpgeb  zero, t0, t2	# .. e1 : bits set iff byte == zero
+	mask7b	t4, a0, t4	# e0    :
+	or	t5, a1, a1	# .. e1 :
+	sll	a1, 32, t5	# e0    :
+	cmpgeb	zero, t4, t4	# .. e1 : bits set iff byte is garbage
+	or	t5, a1, a1	# e0    :
+	xor	t0, a1, t1	# .. e1 : make bytes == c zero
+	cmpgeb  zero, t1, t3	# e0    : bits set iff byte == c
+	or	t2, t3, t0	# e1    : bits set iff char match or zero match
+	andnot	t0, t4, t0	# e0    : clear garbage bits
+	bne	t0, $found	# .. e1 (zdb)
+
+$loop:
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	bne	t0, $found	# .. e1 (zdb)
+
+	ldl	t0, 8(v0)	# e0    :
+	addl	v0, 8, v0	# .. e1 :
+	nop			# e0    :
+	xor	t0, a1, t1	# .. e1 (ev5 data stall)
+	cmpgeb	zero, t0, t2	# e0    : bits set iff byte == 0
+	cmpgeb	zero, t1, t3	# .. e1 : bits set iff byte == c
+	or	t2, t3, t0	# e0    :
+	beq	t0, $loop	# .. e1 (zdb)
+
+$found:	
+	cttz    t0, t2
+	negl    t0, t1		# e0    : clear all but least set bit
+	and     t0, t1, t0	# e1 (stall)
+
+	and	t0, t3, t1	# e0    : bit set iff byte was the char
+	beq	t1, $retnull	# .. e1 (zdb)
+
+	addl    v0, t2, v0
+/*
+
+	and     t0, 0xf0, t2	# e0    : binary search for that set bit
+	and	t0, 0xcc, t3	# .. e1 :
+	and	t0, 0xaa, t4	# e0    :
+	selne	t2, 4, t2, t2	# .. e1 :
+	selne	t3, 2, t3, t3	# e0    :
+	selne	t4, 1, t4, t4	# .. e1 :
+	addl	t2, t3, t2	# e0    :
+	addl	v0, t4, v0	# .. e1 :
+	addl	v0, t2, v0	# e0    :
+*/
+	ret			# .. e1 :
+
+$retnull:
+	mov	zero, v0	# e0    :
+	ret			# .. e1 :
+
+	END(strchr)
+
+weak_alias (strchr, index)
+libc_hidden_builtin_def (strchr)
diff --git a/sysdeps/sw_64/sw8a/strcmp.S b/sysdeps/sw_64/sw8a/strcmp.S
new file mode 100644
index 00000000..47ec454c
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/strcmp.S
@@ -0,0 +1,369 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Bytewise compare two null-terminated strings.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+	.text
+
+ENTRY(strcmp)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	jmp	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+$first_cmp:
+        ldbu   t0, 0(a0)
+        ldbu   t1, 0(a1)
+        ldi    v0, -1
+        xor    t0, t1, t2
+        beq    t2, $main
+        subw   t0, t1, t7
+        selgt  t7, 1, v0, v0
+        br     $done
+
+
+$main:
+	ldl_u	t0, 0(a0)	# e0    : give cache time to catch up
+	xor	a0, a1, t2	# .. e1 : are s1 and s2 co-aligned?
+	ldl_u	t1, 0(a1)	# e0    :
+	and	t2, 7, t2	# .. e1 :
+	ldi	t3, -1		# e0    :
+	bne	t2, $unaligned	# .. e1 :
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.
+	   t3 == -1.  */
+
+$aligned:
+	mask7b	t3, a0, t3	# e0    :
+	nop			# .. e1 :
+	ornot	t1, t3, t1	# e0    :
+	ornot	t0, t3, t0	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0    : bits set iff null found
+	bne	t7, $eos	# e1 (zdb)
+
+	/* Aligned compare main loop.
+	   On entry to this basic block:
+	   t0 == an s1 word.
+	   t1 == an s2 word not containing a null.  */
+
+$a_loop:
+	xor	t0, t1, t2	# e0	:
+	bne	t2, $wordcmp	# .. e1 (zdb)
+	ldl_u	t1, 8(a1)	# e0    :
+	ldl_u	t0, 8(a0)	# .. e1 :
+	addl	a1, 8, a1	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0    :
+#	beq	t7, $a_loop	# .. e1 (zdb)
+#	br	$eos		# e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+         xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 (zdb)
+#       br      $eos            # e1    :
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+        beq     t7, $a_loop     # .. e1 (zdb)
+        br      $eos            # e1    :
+
+
+$unaligned:
+	and	a0, 7, t4	# e0    : find s1 misalignment
+	and	a1, 7, t5	# .. e1 : find s2 misalignment
+	subl	a1, t4, a1	# e0    :
+
+	/* If s2 misalignment is larger than s2 misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+
+	cmplt	t4, t5, t8	# .. e1 :
+	beq	t8, $u_head	# e1    :
+
+	mask7b	t3, t5, t3	# e0    :
+	ornot	t1, t3, t3	# e0    :
+	cmpgeb	zero, t3, t7	# e1    : is there a zero?
+	beq	t7, $u_head	# e1    :
+
+	/* We've found a zero in the first partial word of s2.  Align
+	   our current s1 and s2 words and compare what we've got.  */
+
+	ext3b	t1, t5, t1	# e0    :
+	ext3b	t0, a0, t0	# e0    :
+	cmpgeb	zero, t1, t7	# .. e1 : find that zero again
+	br	$eos		# e1    : and finish up
+
+	.align 3
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full word of s2.  We can still find a zero at the end of it.
+
+	   On entry to this basic block:
+	   t0 == first word of s1
+	   t1 == first partial word of s2.  */
+
+	ldl_u	t2, 8(a1)	# e0    : load second partial s2 word
+	ldi	t3, -1		# .. e1 : create leading garbage mask
+	ext3b	t1, a1, t1	# e0    : create first s2 word
+	mask7b	t3, a0, t3	# e0    :
+	ext7b	t2, a1, t4	# e0    :
+	ornot	t0, t3, t0	# .. e1 : kill s1 garbage
+	or	t1, t4, t1	# e0    : s2 word now complete
+	cmpgeb	zero, t0, t7	# .. e1 : find zero in first s1 word
+	ornot	t1, t3, t1	# e0    : kill s2 garbage
+	ldi	t3, -1		# .. e1 :
+	mask3b	t3, a1, t3	# e0    : mask for s2[1] bits we have seen
+	bne	t7, $eos	# .. e1 :
+	xor	t0, t1, t4	# e0    : compare aligned words
+	bne	t4, $wordcmp	# .. e1 (zdb)
+	or	t2, t3, t3	# e0    :
+	cmpgeb	zero, t3, t7	# e1    :
+	bne	t7, $u_final	# e1    :
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned words from s2.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t2 == the unshifted low-bits from the next s2 word.  */
+
+	.align 3
+$u_loop:
+	ext3b	t2, a1, t3	# e0    :
+	ldl_u	t2, 16(a1)	# .. e1 : load next s2 high bits
+	ldl_u	t0, 8(a0)	# e0    : load next s1 word
+	addl	a1, 8, a1	# .. e1 :
+	addl	a0, 8, a0	# e0    :
+	nop			# .. e1 :
+	ext7b	t2, a1, t1	# e0    :
+	cmpgeb	zero, t0, t7	# .. e1 : find zero in current s1 word
+	or	t1, t3, t1	# e0    :
+	bne	t7, $eos	# .. e1 :
+	xor	t0, t1, t4	# e0    : compare the words
+	bne	t4, $wordcmp	# .. e1 (zdb)
+	cmpgeb	zero, t2, t4	# e0    : find zero in next low bits
+	beq	t4, $u_loop	# .. e1 (zdb)
+
+	/* We've found a zero in the low bits of the last s2 word.  Get
+	   the next s1 word and align them.  */
+$u_final:
+	ldl_u	t0, 8(a0)	# e1    :
+	ext3b	t2, a1, t1	# .. e0 :
+	cmpgeb	zero, t1, t7	# e0    :
+
+	/* We've found a zero somewhere in a word we just read.
+	   On entry to this basic block:
+	   t0 == s1 word
+	   t1 == s2 word
+	   t7 == cmpgeb mask containing the zero.  */
+
+	.align 3
+$eos:
+	negl	t7, t6		# e0    : create bytemask of valid data
+	and	t6, t7, t8	# e1    :
+	subl	t8, 1, t6	# e0    :
+	or	t6, t8, t7	# e1    :
+	zapnot	t0, t7, t0	# e0    : kill the garbage
+	zapnot	t1, t7, t1	# .. e1 :
+	xor	t0, t1, v0	# e0    : and compare
+	beq	v0, $done	# .. e1 :
+
+	/* Here we have two differing co-aligned words in t0 & t1.
+	   Bytewise compare them and return (t0 > t1 ? 1 : -1).  */
+$wordcmp:
+	cmpgeb	t0, t1, t2	# e0    : comparison yieflds bit mask of ge
+	cmpgeb	t1, t0, t3	# .. e1 :
+	xor	t2, t3, t0	# e0    : bits set iff t0/t1 bytes differ
+	negl	t0, t1		# e1    : clear all but least bit
+	and	t0, t1, t0	# e0    :
+	ldi	v0, -1		# .. e1 :
+	and	t0, t2, t1	# e0    : was bit set in t0 > t1?
+	selne	t1, 1, v0, v0	# .. e1 (zdb)
+
+$done:
+	ret			# e1    :
+
+	END(strcmp)
+libc_hidden_builtin_def (strcmp)
diff --git a/sysdeps/sw_64/sw8a/strlen.S b/sysdeps/sw_64/sw8a/strlen.S
new file mode 100644
index 00000000..a1fd3b3a
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/strlen.S
@@ -0,0 +1,112 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   Contributed by David Mosberger (davidm@cs.arizona.edu).
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Finds length of a 0-terminated string.  Optimized for the Sw_64
+   architecture:
+
+      - memory accessed as aligned quadwords only
+      - uses cmpgeb to compare 8 bytes in parallel
+      - does binary search to find 0 byte in last quadword (HAKMEM
+	needed 12 instructions to do this instead of the 8 instructions
+	that the binary search needs).
+*/
+#include <sysdep.h>
+
+	.set noreorder
+	.set noat
+ENTRY(strlen)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	ldl_u   $1, 0($16)	# load first quadword ($16 may be misaligned)
+	ldi     $2, -1($31)
+	ins7b   $2, $16, $2
+	andnot  $16, 7, $0
+	or      $2, $1, $1
+	nop			# dual issue the next two on ev5
+	cmpgeb  $31, $1, $2	# $2 <- bitmask: bit i == 1 <==> i-th byte == 0
+	bne     $2, $found
+
+$loop:	ldl     $1, 8($0)
+	cmpgeb  $31, $1, $2
+	addl    $0, 8, $0	# addr += 8
+	bne     $2, $found
+
+        ldl     $1, 8($0)
+        cmpgeb  $31, $1, $2
+        addl    $0, 8, $0       # addr += 8
+        bne     $2, $found
+ 
+        ldl     $1, 8($0)
+        cmpgeb  $31, $1, $2
+        addl    $0, 8, $0       # addr += 8
+        bne     $2, $found
+
+        ldl     $1, 8($0)
+        cmpgeb  $31, $1, $2
+        addl    $0, 8, $0       # addr += 8
+        bne     $2, $found
+
+        ldl     $1, 8($0)
+        cmpgeb  $31, $1, $2
+        addl    $0, 8, $0       # addr += 8
+        bne     $2, $found
+
+        ldl     $1, 8($0)
+        cmpgeb  $31, $1, $2
+        addl    $0, 8, $0       # addr += 8
+        bne     $2, $found
+   
+        ldl     $1, 8($0)
+        cmpgeb  $31, $1, $2
+        addl    $0, 8, $0       # addr += 8
+        bne     $2, $found
+	
+        ldl     $1, 8($0)
+	cmpgeb  $31, $1, $2
+	addl    $0, 8, $0	# addr += 8
+	beq     $2, $loop
+
+$found:			
+        cttz    $2, $3
+        addl    $0, $3, $0
+	subl    $0, $16, $0
+        /*negl    $2, $3          # clear all but least set bit
+        and     $2, $3, $2
+
+        and     $2, 0xf0, $3    # binary search for that set bit
+        and     $2, 0xcc, $4
+        and     $2, 0xaa, $5
+        selne   $3, 4, $3, $3
+        selne   $4, 2, $4, $4
+        selne   $5, 1, $5, $5
+        addl    $3, $4, $3
+        addl    $0, $5, $0
+        addl    $0, $3, $0
+        nop                     # dual issue next two on ev4 and ev5
+
+        subl    $0, $16, $0*/
+	ret
+END(strlen)
+libc_hidden_builtin_def (strlen)
diff --git a/sysdeps/sw_64/sw8a/strncat.S b/sysdeps/sw_64/sw8a/strncat.S
new file mode 100644
index 00000000..e394d5b8
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/strncat.S
@@ -0,0 +1,412 @@
+/* Copyright (C) 1996-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Append no more than COUNT characters from the null-terminated string SRC
+   to the null-terminated string DST.  Always null-terminate the new DST.  */
+
+#include <sysdep.h>
+
+	.text
+
+ENTRY(strncat)
+	ldgp	gp, 0(pv)
+#ifdef PROF
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	mov	a0, v0		# set up return value
+	beq	a2, $zerocount
+
+	/* Find the end of the string.  */
+#	ldl t0,0(a0)
+	ldl   t0, 0(a0)	# load first quadword (a0 may be misaligned)
+	nop
+	nop
+	nop
+	cmpgeb  zero, t0, t1	# t1 <- bitmask: bit i == 1 <==> i-th byte == 0
+	bne     t1, $found
+
+$loop:
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	bne t1,$found
+
+
+	ldl t0,8(a0)
+	addl    a0, 8, a0	# addr += 8
+	cmpgeb  zero, t0, t1
+	beq     t1, $loop
+$found:	
+	cttz t1,t2
+	addl a0,t2,a0
+	.set noat
+	.set noreorder
+	.text
+	cfi_startproc
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 4
+__stxncpy:
+	/* Are source and destination co-aligned?  */
+	ldi	t2, -1		# E :
+	nop			# E :
+	srl	t2, 1, t2	# U :
+	sellt	a2, t2, a2, a2	# E : bound count to LONG_MAX (stall)
+	nop			# E :
+
+	subl	a2, 1, a2	# E : (stall)
+	and	a2, 7, t2	# E : (stall)
+	ldi	t10, 1		# E :
+	nop			# E :
+
+	srl	a2, 3, a2	# U : a2 = loop counter = (count-1)/8
+	sll	t10, t2, t10	# U : t10 = bitmask of last count byte
+	.align 4
+	ldl	t1, 0(a1)	# L : load first src word
+	addl	a1, 8, a1	# E :
+	nop
+	nop
+	cmpgeb	zero, t1, t7	# E : bits set iff null found
+	nop
+	beq a2,$a_eoc
+	bne	t7, $a_eos	# U :
+	nop
+	nop
+	/* On entry to this basic block:
+	   t0 == a source word not containing a null.  */
+
+	/*
+	 * nops here to:
+	 *	separate store quads from load quads
+	 *	limit of 1 bcond/quad to permit training
+	 */
+$a_loop:
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	bne t7,$a_eos
+
+	stl	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+	ldl	t1, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t7	# E :
+	beq	a2, $a_eoc      # U :
+	#bne t7,$a_eos
+	beq	t7, $a_loop	# U :
+	/* Take care of the final (partial) word store.  At this point
+	   the end-of-count bit is set in t7 iff it applies.
+
+	   On entry to this basic block we have:
+	   t0 == the source word containing the null
+	   t7 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t7, t8		# E : find low bit set
+	and	t7, t8, t8	# E : (stall)
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl	t0, 0(a0)	# L :
+	subl	t8, 1, t6	# E :
+	or	t8, t6, t7	# E : (stall)
+	zapnot	t1, t7, t1	# U : clear src bytes > null (stall)
+	zap	t0, t7, t0	# .. e1 : clear dst bytes <= null
+	or	t0, t1, t1	# e1    : (stall)
+	nop
+	nop
+
+1:	stl	t1, 0(a0)	# L :
+	nop
+	nop
+	zapnot	t1, t8, t0	# was last byte a null?
+	bne	t0, 2f
+	ret
+
+2:	
+	and	t8, 0x80, t2
+	bne	t2, 3f
+	/* Here there are bytes left in the current word.  Clear one.  */
+	addl	t8, t8, t8	# end-of-count bit <<= 1
+	zap	t1, t8, t0
+	stl	t0, 0(a0)
+	ret
+	nop
+	nop
+
+3:	/* Here we must read the next DST word and clear the first byte.  */
+	ldl	t0, 8(a0)
+	nop
+	zap	t0, 1, t0
+	stl	t0, 8(a0)
+	ret
+	nop
+	nop
+	/* Add the end-of-count bit to the eos detection bitmask.  */
+$a_eoc:
+	or	t10, t7, t7	# E :
+	br	$a_eos		# L0 : Latency=3
+	nop
+	nop
+
+	cfi_endproc
+
+
+$zerocount:
+	ret
+
+	END(strncat)
diff --git a/sysdeps/sw_64/sw8a/strncmp.S b/sysdeps/sw_64/sw8a/strncmp.S
new file mode 100644
index 00000000..5a6ca604
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/strncmp.S
@@ -0,0 +1,694 @@
+/* Copyright (C) 1996-2020 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Bytewise compare two null-terminated strings of length no longer than N.  */
+
+#include <sysdep.h>
+
+	.set noat
+	.set noreorder
+
+/* EV6 only predicts one branch per octaword.  We'll use these to push
+   fsubsequent branches back to the next bundle.  This will generally add
+   a fetch+decode cycle to older machines, so skip in that case.  */
+#ifdef __sw_64_fix__
+# define sw6_unop	unop
+#else
+# define sw6_unop
+#endif
+
+	.text
+
+ENTRY(strncmp)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+$first_cmp:
+        beq    a2, $zerolength
+        ldbu   t0, 0(a0)
+        ldbu   t1, 0(a1)
+        ldi    v0, -1
+        xor    t0, t1, t2
+        beq    t2, $main
+        subw   t0, t1, t7
+        selgt  t7, 1, v0, v0
+        br     $done
+
+$main:
+	xor	a0, a1, t2	# are s1 and s2 co-aligned?
+	ldl_u	t0, 0(a0)	# load asap to give cache time to catch up
+	ldl_u	t1, 0(a1)
+	ldi	t3, -1
+	and	t2, 7, t2
+	srl	t3, 1, t6
+	and	a0, 7, t4	# find s1 misalignment
+	and	a1, 7, t5	# find s2 misalignment
+	sellt	a2, t6, a2, a2	# bound neg count to LONG_MAX
+	addl	a1, a2, a3	# s2+count
+	addl	a2, t4, a2	# bias count by s1 misalignment
+	and	a2, 7, t10	# ofs of last byte in s1 last word
+	srl	a2, 3, a2	# remaining full words in s1 count
+	bne	t2, $unaligned
+
+	/* On entry to this basic block:
+	   t0 == the first word of s1.
+	   t1 == the first word of s2.
+	   t3 == -1.  */
+$aligned:
+	mask7b	t3, a1, t8	# mask off leading garbage
+	ornot	t1, t8, t1
+	ornot	t0, t8, t0
+	cmpgeb	zero, t1, t7	# bits set iff null found
+	beq	a2, $eoc	# check end of count
+	bne	t7, $eos
+	beq	t10, $ant_loop
+
+	/* Aligned compare main loop.
+	   On entry to this basic block:
+	   t0 == an s1 word.
+	   t1 == an s2 word not containing a null.  */
+
+	.align 4
+$a_loop:
+	xor	t0, t1, t2	# e0	:
+	bne	t2, $wordcmp	# .. e1 (zdb)
+	ldl_u	t1, 8(a1)	# e0    :
+	ldl_u	t0, 8(a0)	# .. e1 :
+	subl	a2, 1, a2	# e0    :
+	addl	a1, 8, a1	# .. e1 :
+	addl	a0, 8, a0	# e0    :
+	beq	a2, $eoc	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0    :
+#	beq	t7, $a_loop	# .. e1 :
+# 	br	$eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $a_loop     # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        subl    a2, 1, a2       # e0    :
+        addl    a1, 8, a1       # .. e1 :
+        addl    a0, 8, a0       # e0    :
+        beq     a2, $eoc        # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+        beq     t7, $a_loop     # .. e1 :
+        br      $eos
+           
+	/* Alternate aligned compare loop, for when there's no trailing
+	   bytes on the count.  We have to avoid reading too much data.  */
+	.align 4
+$ant_loop:
+	xor	t0, t1, t2	# e0	:
+	sw6_unop
+	sw6_unop
+	bne	t2, $wordcmp	# .. e1 (zdb)
+	subl	a2, 1, a2	# e0    :
+	beq	a2, $zerolength	# .. e1 :
+	ldl_u	t1, 8(a1)	# e0    :
+	ldl_u	t0, 8(a0)	# .. e1 :
+	addl	a1, 8, a1	# e0    :
+	addl	a0, 8, a0	# .. e1 :
+	cmpgeb	zero, t1, t7	# e0    :
+#	beq	t7, $ant_loop	# .. e1 :
+#	br	$eos
+        bne     t7, $eos
+               
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+         xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+         xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+         xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+       xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+#       beq     t7, $ant_loop   # .. e1 :
+#       br      $eos
+        bne     t7, $eos
+
+        xor     t0, t1, t2      # e0    :
+        sw6_unop
+        sw6_unop
+        bne     t2, $wordcmp    # .. e1 (zdb)
+        subl    a2, 1, a2       # e0    :
+        beq     a2, $zerolength # .. e1 :
+        ldl_u   t1, 8(a1)       # e0    :
+        ldl_u   t0, 8(a0)       # .. e1 :
+        addl    a1, 8, a1       # e0    :
+        addl    a0, 8, a0       # .. e1 :
+        cmpgeb  zero, t1, t7    # e0    :
+        beq     t7, $ant_loop   # .. e1 :
+        br      $eos
+
+	.align	4
+$unaligned:
+	/* If s1 misalignment is larger than s2 misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+	subl	a1, t4, a1	# adjust s2 for s1 misalignment
+	cmpult	t4, t5, t9
+	subl	a3, 1, a3	# last byte of s2
+	bic	a1, 7, t8
+	mask7b	t3, t5, t7	# mask garbage in s2
+	subl	a3, t8, a3
+	ornot	t1, t7, t7
+	srl	a3, 3, a3	# remaining full words in s2 count
+	beq	t9, $u_head
+
+	/* Failing that, we need to look for both eos and eoc within the
+	   first word of s2.  If we find either, we can continue by
+	   pretending that the next word of s2 is all zeros.  */
+	ldi	t2, 0		# next = zero
+	cmpeq	a3, 0, t8	# eoc in the first word of s2?
+	cmpgeb	zero, t7, t7	# eos in the first word of s2?
+	or	t7, t8, t8
+	bne	t8, $u_head_nl
+
+	/* We know just enough now to be able to assemble the first
+	   full word of s2.  We can still find a zero at the end of it.
+
+	   On entry to this basic block:
+	   t0 == first word of s1
+	   t1 == first partial word of s2.
+	   t3 == -1.
+	   t10 == ofs of last byte in s1 last word.
+	   t11 == ofs of last byte in s2 last word.  */
+$u_head:
+	ldl_u	t2, 8(a1)	# load second partial s2 word
+	subl	a3, 1, a3
+$u_head_nl:
+	ext3b	t1, a1, t1	# create first s2 word
+	mask7b	t3, a0, t8
+	ext7b	t2, a1, t4
+	ornot	t0, t8, t0	# kill s1 garbage
+	or	t1, t4, t1	# s2 word now complete
+	cmpgeb	zero, t0, t7	# find eos in first s1 word
+	ornot	t1, t8, t1	# kill s2 garbage
+	beq	a2, $eoc
+	subl	a2, 1, a2
+	bne	t7, $eos
+	mask3b	t3, a1, t8	# mask out s2[1] bits we have seen
+	xor	t0, t1, t4	# compare aligned words
+	or	t2, t8, t8
+	bne	t4, $wordcmp
+	cmpgeb	zero, t8, t7	# eos in high bits of s2[1]?
+	cmpeq	a3, 0, t8	# eoc in s2[1]?
+	or	t7, t8, t7
+	bne	t7, $u_final
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned words from s2.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t2 == the unshifted low-bits from the next s2 word.
+	   t10 == ofs of last byte in s1 last word.
+	   t11 == ofs of last byte in s2 last word.  */
+	.align 4
+$u_loop:
+	ext3b	t2, a1, t3	# e0    :
+	ldl_u	t2, 16(a1)	# .. e1 : load next s2 high bits
+	ldl_u	t0, 8(a0)	# e0    : load next s1 word
+	addl	a1, 8, a1	# .. e1 :
+
+	addl	a0, 8, a0	# e0    :
+	subl	a3, 1, a3	# .. e1 :
+	ext7b	t2, a1, t1	# e0    :
+	cmpgeb	zero, t0, t7	# .. e1 : eos in current s1 word
+
+	or	t1, t3, t1	# e0    :
+	beq	a2, $eoc	# .. e1 : eoc in current s1 word
+	subl	a2, 1, a2	# e0    :
+	cmpgeb	zero, t2, t4	# .. e1 : eos in s2[1]
+
+	xor	t0, t1, t3	# e0    : compare the words
+	sw6_unop
+	sw6_unop
+	bne	t7, $eos	# .. e1 :
+
+	cmpeq	a3, 0, t5	# e0    : eoc in s2[1]
+	sw6_unop
+	sw6_unop
+	bne	t3, $wordcmp	# .. e1 :
+
+	or	t4, t5, t4	# e0    : eos or eoc in s2[1].
+	beq	t4, $u_loop	# .. e1 (zdb)
+
+	/* We've found a zero in the low bits of the last s2 word.  Get
+	   the next s1 word and align them.  */
+	.align 3
+$u_final:
+	ldl_u	t0, 8(a0)
+	ext3b	t2, a1, t1
+	cmpgeb	zero, t1, t7
+	bne	a2, $eos
+
+	/* We've hit end of count.  Zero everything after the count
+	   and compare whats left.  */
+	.align 3
+$eoc:
+	mask3b	t0, t10, t0
+	mask3b	t1, t10, t1
+	cmpgeb	zero, t1, t7
+
+	/* We've found a zero somewhere in a word we just read.
+	   On entry to this basic block:
+	   t0 == s1 word
+	   t1 == s2 word
+	   t7 == cmpgeb mask containing the zero.  */
+	.align 3
+$eos:
+	negl	t7, t6		# create bytemask of valid data
+	and	t6, t7, t8
+	subl	t8, 1, t6
+	or	t6, t8, t7
+	zapnot	t0, t7, t0	# kill the garbage
+	zapnot	t1, t7, t1
+	xor	t0, t1, v0	# ... and compare
+	beq	v0, $done
+
+	/* Here we have two differing co-aligned words in t0 & t1.
+	   Bytewise compare them and return (t0 > t1 ? 1 : -1).  */
+	.align 3
+$wordcmp:
+	cmpgeb	t0, t1, t2	# comparison yieflds bit mask of ge
+	cmpgeb	t1, t0, t3
+	xor	t2, t3, t0	# bits set iff t0/t1 bytes differ
+	negl	t0, t1		# clear all but least bit
+	and	t0, t1, t0
+	ldi	v0, -1
+	and	t0, t2, t1	# was bit set in t0 > t1?
+	selne	t1, 1, v0, v0
+$done:
+	ret
+
+	.align 3
+$zerolength:
+	clr	v0
+	ret
+
+	END(strncmp)
+libc_hidden_builtin_def (strncmp)
diff --git a/sysdeps/sw_64/sw8a/stxcpy.S b/sysdeps/sw_64/sw8a/stxcpy.S
new file mode 100644
index 00000000..a3cca303
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/stxcpy.S
@@ -0,0 +1,314 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy a null-terminated string from SRC to DST.
+
+   This is an internal routine used by strcpy, stpcpy, and strcat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+
+   On output:
+	t8  = bitmask (with one bit set) indicating the last byte written
+	a0  = unaligned address of the last *word* written
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+
+#include <sysdep.h>
+
+	.arch ev6
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxcpy, @function
+	.globl	__stxcpy
+	.usepv	__stxcpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 4
+stxcpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# E : build a mask against false zero
+	mask7b	t2, a1, t2	# U :   detection in the src word (stall)
+	mask7b	t1, a1, t3	# U :
+	ornot	t1, t2, t2	# E : (stall)
+
+	mask3b	t0, a1, t0	# U : assemble the first output word
+	cmpgeb	zero, t2, t10	# E : bits set iff null found
+	or	t0, t3, t1	# E : (stall)
+	bne	t10, $a_eos	# U : (stall)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == a source word not containing a null.  */
+	/* Nops here to separate store quads from load quads */
+
+$a_loop:
+	stl_u	t1, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	nop
+	nop
+
+	ldl_u	t1, 0(a1)	# L : Latency=3
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t1, t10	# E : (3 cycle stall)
+	beq	t10, $a_loop	# U : (stall for t10)
+
+	/* Take care of the final (partial) word store.
+	   On entry to this basic block we have:
+	   t1 == the source word containing the null
+	   t10 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t10, t6		# E : find low bit set
+	and	t10, t6, t8	# E : (stall)
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t0, 0(a0)	# L : Latency=3
+	subl	t8, 1, t6	# E :
+	zapnot	t1, t6, t1	# U : clear src bytes >= null (stall)
+	or	t8, t6, t10	# E : (stall)
+
+	zap	t0, t10, t0	# E : clear dst bytes <= null
+	or	t0, t1, t1	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t1, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	.align 4
+__stxcpy:
+	/* Are source and destination co-aligned?  */
+	xor	a0, a1, t0	# E :
+	unop			# E :
+	and	t0, 7, t0	# E : (stall)
+	bne	t0, $unaligned	# U : (stall)
+
+	/* We are co-aligned; take care of a partial first word.  */
+	ldl_u	t1, 0(a1)		# L : load first src word
+	and	a0, 7, t0		# E : take care not to load a word ...
+	addl	a1, 8, a1		# E :
+	beq	t0, stxcpy_aligned	# U : ... if we wont need it (stall)
+
+	ldl_u	t0, 0(a0)	# L :
+	br	stxcpy_aligned	# L0 : Latency=3
+	nop
+	nop
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 4
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, for masking back in, if needed else 0
+	   t1 == the low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# L :
+	addl	a1, 8, a1	# E :
+	ext3b	t1, a1, t1	# U : (stall on a1)
+	ext7b	t2, a1, t4	# U : (stall on a1)
+
+	mask3b	t0, a0, t0	# U :
+	or	t1, t4, t1	# E :
+	mask7b	t1, a0, t1	# U : (stall on t1)
+	or	t0, t1, t1	# E : (stall on t1)
+
+	or	t1, t6, t6	# E :
+	cmpgeb	zero, t6, t10	# E : (stall)
+	ldi	t6, -1		# E : for masking just below
+	bne	t10, $u_final	# U : (stall)
+
+	mask3b	t6, a1, t6		# U : mask out the bits we have
+	or	t6, t2, t2		# E :   already extracted before (stall)
+	cmpgeb	zero, t2, t10		# E :   testing eos (stall)
+	bne	t10, $u_late_head_exit	# U : (stall)
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+
+	stl_u	t1, 0(a0)	# L : store first output word
+	addl	a0, 8, a0	# E :
+	ext3b	t2, a1, t0	# U : position ho-bits of lo word
+	ldl_u	t2, 8(a1)	# U : read next high-order source word
+
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t2, t10	# E : (stall for t2)
+	nop			# E :
+	bne	t10, $u_eos	# U : (stall)
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 3
+$u_loop:
+	ext7b	t2, a1, t1	# U : extract high bits for current word
+	addl	a1, 8, a1	# E : (stall)
+	ext3b	t2, a1, t3	# U : extract low bits for next time (stall)
+	addl	a0, 8, a0	# E :
+
+	or	t0, t1, t1	# E : current dst word now complete
+	ldl_u	t2, 0(a1)	# L : Latency=3 load high word for next time
+	stl_u	t1, -8(a0)	# L : save the current word (stall)
+	mov	t3, t0		# E :
+
+	cmpgeb	zero, t2, t10	# E : test new word for eos
+	beq	t10, $u_loop	# U : (stall)
+	nop
+	nop
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	ext7b	t2, a1, t1	# U :
+	or	t0, t1, t1	# E : first (partial) source word complete (stall)
+	cmpgeb	zero, t1, t10	# E : is the null in this first bit? (stall)
+	bne	t10, $u_final	# U : (stall)
+
+$u_late_head_exit:
+	stl_u	t1, 0(a0)	# L : the null was in the high-order bits
+	addl	a0, 8, a0	# E :
+	ext3b	t2, a1, t1	# U :
+	cmpgeb	zero, t1, t10	# E : (stall)
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t1 == assembled source word
+	   t10 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t10, t6		# E : isolate low bit set
+	and	t6, t10, t8	# E : (stall)
+	and	t8, 0x80, t6	# E : avoid dest word load if we can (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t0, 0(a0)	# E :
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t10	# E : (stall)
+	zapnot	t1, t6, t1	# U : kill source bytes >= null (stall)
+
+	zap	t0, t10, t0	# U : kill dest bytes <= null (2 cycle data stall)
+	or	t0, t1, t1	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t1, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	/* Unaligned copy entry point.  */
+	.align 4
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# L : load first source word
+	and	a0, 7, t4	# E : find dest misalignment
+	and	a1, 7, t5	# E : find src misalignment
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+	mov	zero, t0	# E :
+
+	mov	zero, t6	# E :
+	beq	t4, 1f		# U :
+	ldl_u	t0, 0(a0)	# L :
+	ldi	t6, -1		# E :
+
+	mask3b	t6, a0, t6	# U :
+	nop
+	nop
+	nop
+1:
+	subl	a1, t4, a1	# E : sub dest misalignment from src addr
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+	cmplt	t4, t5, t8	# E :
+	beq	t8, $u_head	# U :
+	ldi	t2, -1		# E : mask out leading garbage in source
+
+	mask7b	t2, t5, t2	# U :
+	ornot	t1, t2, t3	# E : (stall)
+	cmpgeb	zero, t3, t10	# E : is there a zero? (stall)
+	beq	t10, $u_head	# U : (stall)
+
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+
+	ldl_u	t0, 0(a0)	# L :
+	negl	t10, t6		# E : build bitmask of bytes <= zero
+	and	t6, t10, t8	# E : (stall)
+	and	a1, 7, t5	# E :
+
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t10	# E : (stall)
+	srl	t8, t5, t8	# U : adjust final null return value
+	zapnot	t2, t10, t2	# U : prepare source word; mirror changes (stall)
+
+	and	t1, t2, t1	# E : to source validity mask
+	ext3b	t2, a1, t2	# U :
+	ext3b	t1, a1, t1	# U : (stall)
+	andnot	t0, t2, t0	# .. e1 : zero place for source to reside (stall)
+
+	or	t0, t1, t1	# e1    : and put it there
+	stl_u	t1, 0(a0)	# .. e0 : (stall)
+	ret	(t9)		# e1    :
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/sw8a/stxncpy.S b/sysdeps/sw_64/sw8a/stxncpy.S
new file mode 100644
index 00000000..2675d179
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/stxncpy.S
@@ -0,0 +1,392 @@
+/* Copyright (C) 2000-2018 Free Software Foundation, Inc.
+   Contributed by Richard Henderson (rth@tamu.edu)
+   SW6 optimized by Rick Gorton <rick.gorton@sw_64-processor.com>.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Copy no more than COUNT bytes of the null-terminated string from
+   SRC to DST.
+
+   This is an internal routine used by strncpy, stpncpy, and strncat.
+   As such, it uses special linkage conventions to make implementation
+   of these public functions more efficient.
+
+   On input:
+	t9 = return address
+	a0 = DST
+	a1 = SRC
+	a2 = COUNT
+
+   Furthermore, COUNT may not be zero.
+
+   On output:
+	t0  = last word written
+	t8  = bitmask (with one bit set) indicating the last byte written
+	t10 = bitmask (with one bit set) indicating the byte position of
+	      the end of the range specified by COUNT
+	a0  = unaligned address of the last *word* written
+	a2  = the number of full words left in COUNT
+
+   Furthermore, v0, a3-a5, t11, and t12 are untouched.
+*/
+
+#include <sysdep.h>
+
+	.arch ev6
+	.set noat
+	.set noreorder
+
+	.text
+	.type	__stxncpy, @function
+	.globl	__stxncpy
+	.usepv	__stxncpy, no
+
+	cfi_startproc
+	cfi_return_column (t9)
+
+	/* On entry to this basic block:
+	   t0 == the first destination word for masking back in
+	   t1 == the first source word.  */
+	.align 4
+stxncpy_aligned:
+	/* Create the 1st output word and detect 0's in the 1st input word.  */
+	ldi	t2, -1		# E : build a mask against false zero
+	mask7b	t2, a1, t2	# U :   detection in the src word (stall)
+	mask7b	t1, a1, t3	# U :
+	ornot	t1, t2, t2	# E : (stall)
+
+	mask3b	t0, a1, t0	# U : assemble the first output word
+	cmpgeb	zero, t2, t7	# E : bits set iff null found
+	or	t0, t3, t0	# E : (stall)
+	beq	a2, $a_eoc	# U :
+
+	bne	t7, $a_eos	# U :
+	nop
+	nop
+	nop
+
+	/* On entry to this basic block:
+	   t0 == a source word not containing a null.  */
+
+	/*
+	 * nops here to:
+	 *	separate store quads from load quads
+	 *	limit of 1 bcond/quad to permit training
+	 */
+$a_loop:
+	stl_u	t0, 0(a0)	# L :
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+
+	ldl_u	t0, 0(a1)	# L :
+	addl	a1, 8, a1	# E :
+	cmpgeb	zero, t0, t7	# E :
+	beq	a2, $a_eoc      # U :
+
+	beq	t7, $a_loop	# U :
+	nop
+	nop
+	nop
+
+	/* Take care of the final (partial) word store.  At this point
+	   the end-of-count bit is set in t7 iff it applies.
+
+	   On entry to this basic block we have:
+	   t0 == the source word containing the null
+	   t7 == the cmpgeb mask that found it.  */
+$a_eos:
+	negl	t7, t8		# E : find low bit set
+	and	t7, t8, t8	# E : (stall)
+	/* For the sake of the cache, don't read a destination word
+	   if we're not going to need it.  */
+	and	t8, 0x80, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	/* We're doing a partial word store and so need to combine
+	   our source and original destination words.  */
+	ldl_u	t1, 0(a0)	# L :
+	subl	t8, 1, t6	# E :
+	or	t8, t6, t7	# E : (stall)
+	zapnot	t0, t7, t0	# U : clear src bytes > null (stall)
+
+	zap	t1, t7, t1	# .. e1 : clear dst bytes <= null
+	or	t0, t1, t0	# e1    : (stall)
+	nop
+	nop
+
+1:	stl_u	t0, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+	nop
+	nop
+
+	/* Add the end-of-count bit to the eos detection bitmask.  */
+$a_eoc:
+	or	t10, t7, t7	# E :
+	br	$a_eos		# L0 : Latency=3
+	nop
+	nop
+
+	.align 4
+__stxncpy:
+	/* Are source and destination co-aligned?  */
+	ldi	t2, -1		# E :
+	xor	a0, a1, t1	# E :
+	and	a0, 7, t0	# E : find dest misalignment
+	nop			# E :
+
+	srl	t2, 1, t2	# U :
+	and	t1, 7, t1	# E :
+	sellt	a2, t2, a2, a2	# E : bound count to LONG_MAX (stall)
+	nop			# E :
+
+	addl	a2, t0, a2	# E : bias count by dest misalignment
+	subl	a2, 1, a2	# E : (stall)
+	and	a2, 7, t2	# E : (stall)
+	ldi	t10, 1		# E :
+
+	srl	a2, 3, a2	# U : a2 = loop counter = (count - 1)/8
+	sll	t10, t2, t10	# U : t10 = bitmask of last count byte
+	nop			# E :
+	bne	t1, $unaligned	# U : (stall)
+
+	/* We are co-aligned; take care of a partial first word.  */
+	ldl_u	t1, 0(a1)	# L : load first src word
+	addl	a1, 8, a1	# E :
+	beq	t0, stxncpy_aligned # U : avoid loading dest word if not needed
+	ldl_u	t0, 0(a0)	# L :
+
+	br	stxncpy_aligned	# U :
+	nop
+	nop
+	nop
+
+
+
+/* The source and destination are not co-aligned.  Align the destination
+   and cope.  We have to be very careful about not reading too much and
+   causing a SEGV.  */
+
+	.align 4
+$u_head:
+	/* We know just enough now to be able to assemble the first
+	   full source word.  We can still find a zero at the end of it
+	   that prevents us from outputting the whole thing.
+
+	   On entry to this basic block:
+	   t0 == the first dest word, unmasked
+	   t1 == the shifted low bits of the first source word
+	   t6 == bytemask that is -1 in dest word bytes */
+
+	ldl_u	t2, 8(a1)	# L : Latency=3 load second src word
+	addl	a1, 8, a1	# E :
+	mask3b	t0, a0, t0	# U : mask trailing garbage in dst
+	ext7b	t2, a1, t4	# U : (3 cycle stall on t2)
+
+	or	t1, t4, t1	# E : first aligned src word complete (stall)
+	mask7b	t1, a0, t1	# U : mask leading garbage in src (stall)
+	or	t0, t1, t0	# E : first output word complete (stall)
+	or	t0, t6, t6	# E : mask original data for zero test (stall)
+
+	cmpgeb	zero, t6, t7	# E :
+	beq	a2, $u_eocfin	# U :
+	ldi	t6, -1		# E :
+	nop
+
+	bne	t7, $u_final	# U :
+	mask3b	t6, a1, t6	# U : mask out bits already seen
+	stl_u	t0, 0(a0)	# L : store first output word
+	or      t6, t2, t2	# E :
+
+	cmpgeb	zero, t2, t7	# E : find nulls in second partial
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	bne	t7, $u_late_head_exit	# U :
+
+	/* Finally, we've got all the stupid leading edge cases taken care
+	   of and we can set up to enter the main loop.  */
+	ext3b	t2, a1, t1	# U : position hi-bits of lo word
+	beq	a2, $u_eoc	# U :
+	ldl_u	t2, 8(a1)	# L : read next high-order source word
+	addl	a1, 8, a1	# E :
+
+	ext7b	t2, a1, t0	# U : position lo-bits of hi word (stall)
+	cmpgeb	zero, t2, t7	# E :
+	nop
+	bne	t7, $u_eos	# U :
+
+	/* Unaligned copy main loop.  In order to avoid reading too much,
+	   the loop is structured to detect zeros in aligned source words.
+	   This has, unfortunately, effectively pulled half of a loop
+	   iteration out into the head and half into the tail, but it does
+	   prevent nastiness from accumulating in the very thing we want
+	   to run as fast as possible.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word
+
+	   We further know that t2 does not contain a null terminator.  */
+
+	.align 4
+$u_loop:
+	or	t0, t1, t0	# E : current dst word now complete
+	subl	a2, 1, a2	# E : decrement word count
+	ext3b	t2, a1, t1	# U : extract high bits for next time
+	addl	a0, 8, a0	# E :
+
+	stl_u	t0, -8(a0)	# L : save the current word
+	beq	a2, $u_eoc	# U :
+	ldl_u	t2, 8(a1)	# L : Latency=3 load high word for next time
+	addl	a1, 8, a1	# E :
+
+	ext7b	t2, a1, t0	# U : extract low bits (2 cycle stall)
+	cmpgeb	zero, t2, t7	# E : test new word for eos
+	nop
+	beq	t7, $u_loop	# U :
+
+	/* We've found a zero somewhere in the source word we just read.
+	   If it resides in the lower half, we have one (probably partial)
+	   word to write out, and if it resides in the upper half, we
+	   have one full and one partial word left to write out.
+
+	   On entry to this basic block:
+	   t0 == the shifted low-order bits from the current source word
+	   t1 == the shifted high-order bits from the previous source word
+	   t2 == the unshifted current source word.  */
+$u_eos:
+	or	t0, t1, t0	# E : first (partial) source word complete
+	nop
+	cmpgeb	zero, t0, t7	# E : is the null in this first bit? (stall)
+	bne	t7, $u_final	# U : (stall)
+
+	stl_u	t0, 0(a0)	# L : the null was in the high-order bits
+	addl	a0, 8, a0	# E :
+	subl	a2, 1, a2	# E :
+	nop
+
+$u_late_head_exit:
+	ext3b	t2, a1, t0	# U :
+	cmpgeb	zero, t0, t7	# E :
+	or	t7, t10, t6	# E : (stall)
+	seleq	a2, t6, t7, t7	# E : Latency=2, extra map slot (stall)
+
+	/* Take care of a final (probably partial) result word.
+	   On entry to this basic block:
+	   t0 == assembled source word
+	   t7 == cmpgeb mask that found the null.  */
+$u_final:
+	negl	t7, t6		# E : isolate low bit set
+	and	t6, t7, t8	# E : (stall)
+	and	t8, 0x80, t6	# E : avoid dest word load if we can (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t1, 0(a0)	# L :
+	subl	t8, 1, t6	# E :
+	or	t6, t8, t7	# E : (stall)
+	zapnot	t0, t7, t0	# U : kill source bytes > null
+
+	zap	t1, t7, t1	# U : kill dest bytes <= null
+	or	t0, t1, t0	# E : (stall)
+	nop
+	nop
+
+1:	stl_u	t0, 0(a0)	# L :
+	ret	(t9)		# L0 : Latency=3
+
+        /* Got to end-of-count before end of string.
+           On entry to this basic block:
+           t1 == the shifted high-order bits from the previous source word  */
+$u_eoc:
+	and	a1, 7, t6	# E :
+	sll	t10, t6, t6	# U : (stall)
+	and	t6, 0xff, t6	# E : (stall)
+	bne	t6, 1f		# U : (stall)
+
+	ldl_u	t2, 8(a1)	# L : load final src word
+	nop
+	ext7b	t2, a1, t0	# U : extract low bits for last word (stall)
+	or	t1, t0, t1	# E : (stall)
+
+1:	cmpgeb	zero, t1, t7	# E :
+	mov	t1, t0
+
+$u_eocfin:			# end-of-count, final word
+	or	t10, t7, t7	# E :
+	br	$u_final	# L0 : Latency=3
+
+	/* Unaligned copy entry point.  */
+	.align 4
+$unaligned:
+
+	ldl_u	t1, 0(a1)	# L : load first source word
+	and	a0, 7, t4	# E : find dest misalignment
+	and	a1, 7, t5	# E : find src misalignment
+	/* Conditionally load the first destination word and a bytemask
+	   with 0xff indicating that the destination byte is sacrosanct.  */
+	mov	zero, t0	# E :
+
+	mov	zero, t6	# E :
+	beq	t4, 1f		# U :
+	ldl_u	t0, 0(a0)	# L :
+	ldi	t6, -1		# E :
+
+	mask3b	t6, a0, t6	# U :
+	nop
+	nop
+1:	subl	a1, t4, a1	# E : sub dest misalignment from src addr
+
+	/* If source misalignment is larger than dest misalignment, we need
+	   extra startup checks to avoid SEGV.  */
+
+	cmplt	t4, t5, t8	# E :
+	ext3b	t1, a1, t1	# U : shift src into place
+	ldi	t2, -1		# E : for creating masks later
+	beq	t8, $u_head	# U : (stall)
+
+	mask7b	t2, t5, t2	# U : begin src byte validity mask
+	cmpgeb	zero, t1, t7	# E : is there a zero?
+	ext3b	t2, a1, t2	# U :
+	or	t7, t10, t5	# E : test for end-of-count too
+
+	cmpgeb	zero, t2, t3	# E :
+	seleq	a2, t5, t7, t7	# E : Latency=2, extra map slot
+	nop			# E : keep with seleq
+	andnot	t7, t3, t7	# E : (stall)
+
+	beq	t7, $u_head	# U :
+	/* At this point we've found a zero in the first partial word of
+	   the source.  We need to isolate the valid source data and mask
+	   it into the original destination data.  (Incidentally, we know
+	   that we'll need at least one byte of that original dest word.) */
+	ldl_u	t0, 0(a0)	# L :
+	negl	t7, t6		# E : build bitmask of bytes <= zero
+	mask7b	t1, t4, t1	# U :
+
+	and	t6, t7, t8	# E :
+	subl	t8, 1, t6	# E : (stall)
+	or	t6, t8, t7	# E : (stall)
+	zapnot	t2, t7, t2	# U : prepare source word; mirror changes (stall)
+
+	zapnot	t1, t7, t1	# U : to source validity mask
+	andnot	t0, t2, t0	# E : zero place for source to reside
+	or	t0, t1, t0	# E : and put it there (stall both t0, t1)
+	stl_u	t0, 0(a0)	# L : (stall)
+
+	ret	(t9)		# L0 : Latency=3
+
+	cfi_endproc
diff --git a/sysdeps/sw_64/sw8a/sub_n.S b/sysdeps/sw_64/sw8a/sub_n.S
new file mode 100644
index 00000000..d7fa7a0d
--- /dev/null
+++ b/sysdeps/sw_64/sw8a/sub_n.S
@@ -0,0 +1,147 @@
+ # Sw_64 __mpn_sub_n -- Subtract two limb vectors of the same length > 0 and
+ # store difference in a third limb vector.
+
+ # Copyright (C) 1995-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+
+ # INPUT PARAMETERS
+ # res_ptr	$16
+ # s1_ptr	$17
+ # s2_ptr	$18
+ # size		$19
+
+	.set	noreorder
+	.set	noat
+.text
+	.align	3
+	.globl	__mpn_sub_n
+	.ent	__mpn_sub_n
+__mpn_sub_n:
+	.frame	$30,0,$26,0
+
+	or	$31,$31,$25		# clear cy
+	subl	$19,4,$19		# decr loop cnt
+	blt	$19,.Lend2		# if less than 4 limbs, goto 2nd loop
+ # Start software pipeline for 1st loop
+	ldl	$0,0($18)
+	ldl	$1,8($18)
+	ldl	$4,0($17)
+	ldl	$5,8($17)
+	addl	$17,32,$17		# update s1_ptr
+	ldl	$2,16($18)
+	subl	$4,$0,$20		# 1st main sub
+	ldl	$3,24($18)
+	subl	$19,4,$19		# decr loop cnt
+	ldl	$6,-16($17)
+	cmpult	$4,$20,$25		# compute cy from last sub
+	ldl	$7,-8($17)
+	addl	$1,$25,$28		# cy add
+	addl	$18,32,$18		# update s2_ptr
+	subl	$5,$28,$21		# 2nd main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	blt	$19,.Lend1		# if less than 4 limbs remain, jump
+ # 1st loop handles groups of 4 limbs in a software pipeline
+	.align	4
+.Loop:	cmpult	$5,$21,$25		# compute cy from last add
+	ldl	$0,0($18)
+	or	$8,$25,$25		# combine cy from the two fadds
+	ldl	$1,8($18)
+	addl	$2,$25,$28		# cy add
+	ldl	$4,0($17)
+	subl	$6,$28,$22		# 3rd main sub
+	ldl	$5,8($17)
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$6,$22,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	subl	$7,$28,$23		# 4th main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$7,$23,$25		# compute cy from last add
+	addl	$17,32,$17		# update s1_ptr
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	addl	$0,$25,$28		# cy add
+	ldl	$2,16($18)
+	subl	$4,$28,$20		# 1st main sub
+	ldl	$3,24($18)
+	cmpult	$28,$25,$8		# compute cy from last add
+	ldl	$6,-16($17)
+	cmpult	$4,$20,$25		# compute cy from last add
+	ldl	$7,-8($17)
+	or	$8,$25,$25		# combine cy from the two fadds
+	subl	$19,4,$19		# decr loop cnt
+	stl	$22,-16($16)
+	addl	$1,$25,$28		# cy add
+	stl	$23,-8($16)
+	subl	$5,$28,$21		# 2nd main sub
+	addl	$18,32,$18		# update s2_ptr
+	cmpult	$28,$25,$8		# compute cy from last add
+	bge	$19,.Loop
+ # Finish software pipeline for 1st loop
+.Lend1:	cmpult	$5,$21,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$2,$25,$28		# cy add
+	subl	$6,$28,$22		# 3rd main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$6,$22,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+	stl	$21,8($16)
+	addl	$3,$25,$28		# cy add
+	subl	$7,$28,$23		# 4th main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$7,$23,$25		# compute cy from last add
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,32,$16		# update res_ptr
+	stl	$22,-16($16)
+	stl	$23,-8($16)
+.Lend2:	addl	$19,4,$19		# restore loop cnt
+	beq	$19,.Lret
+ # Start software pipeline for 2nd loop
+	ldl	$0,0($18)
+	ldl	$4,0($17)
+	subl	$19,1,$19
+	beq	$19,.Lend0
+ # 2nd loop handles remaining 1-3 limbs
+	.align	4
+.Loop0:	addl	$0,$25,$28		# cy add
+	ldl	$0,8($18)
+	subl	$4,$28,$20		# main sub
+	ldl	$1,8($17)
+	addl	$18,8,$18
+	cmpult	$28,$25,$8		# compute cy from last add
+	addl	$17,8,$17
+	stl	$20,0($16)
+	cmpult	$4,$20,$25		# compute cy from last add
+	subl	$19,1,$19		# decr loop cnt
+	or	$8,$25,$25		# combine cy from the two fadds
+	addl	$16,8,$16
+	or	$1,$31,$4
+	bne	$19,.Loop0
+.Lend0:	addl	$0,$25,$28		# cy add
+	subl	$4,$28,$20		# main sub
+	cmpult	$28,$25,$8		# compute cy from last add
+	cmpult	$4,$20,$25		# compute cy from last add
+	stl	$20,0($16)
+	or	$8,$25,$25		# combine cy from the two fadds
+
+.Lret:	or	$25,$31,$0		# return cy
+	ret	$31,($26),1
+	.end	__mpn_sub_n
diff --git a/sysdeps/sw_64/tininess.h b/sysdeps/sw_64/tininess.h
new file mode 100644
index 00000000..1db37790
--- /dev/null
+++ b/sysdeps/sw_64/tininess.h
@@ -0,0 +1 @@
+#define TININESS_AFTER_ROUNDING	1
diff --git a/sysdeps/sw_64/tls-macros.h b/sysdeps/sw_64/tls-macros.h
new file mode 100644
index 00000000..351b67e1
--- /dev/null
+++ b/sysdeps/sw_64/tls-macros.h
@@ -0,0 +1,25 @@
+/* Macros to support TLS testing in times of missing compiler support.  */
+
+extern void *__tls_get_addr (void *);
+
+# define TLS_GD(x)							\
+  ({ register void *__gp asm ("$29"); void *__result;			\
+     asm ("ldi %0, " #x "($gp) !tlsgd" : "=r" (__result) : "r"(__gp));	\
+     __tls_get_addr (__result); })
+
+# define TLS_LD(x)							\
+  ({ register void *__gp asm ("$29"); void *__result;			\
+     asm ("ldi %0, " #x "($gp) !tlsldm" : "=r" (__result) : "r"(__gp));	\
+     __result = __tls_get_addr (__result);				\
+     asm ("ldi %0, " #x "(%0) !dtprel" : "+r" (__result));		\
+     __result; })
+
+# define TLS_IE(x)							\
+  ({ register void *__gp asm ("$29"); long ofs;				\
+     asm ("ldl %0, " #x "($gp) !gottprel" : "=r"(ofs) : "r"(__gp));	\
+     __builtin_thread_pointer () + ofs; })
+
+# define TLS_LE(x)						\
+  ({ void *__result = __builtin_thread_pointer ();		\
+     asm ("ldi %0, " #x "(%0) !tprel" : "+r" (__result));	\
+     __result; })
diff --git a/sysdeps/sw_64/tst-audit.h b/sysdeps/sw_64/tst-audit.h
new file mode 100644
index 00000000..f8f4fa6e
--- /dev/null
+++ b/sysdeps/sw_64/tst-audit.h
@@ -0,0 +1,24 @@
+/* Definitions for testing PLT entry/exit auditing.  Sw_64 version.
+   Copyright (C) 2012-2020 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define pltenter la_sw_64_gnu_pltenter
+#define pltexit la_sw_64_gnu_pltexit
+#define La_regs La_sw_64_regs
+#define La_retval La_sw_64_retval
+#define int_retval lrv_r0
diff --git a/sysdeps/sw_64/tst-file-align.h b/sysdeps/sw_64/tst-file-align.h
new file mode 100644
index 00000000..40673717
--- /dev/null
+++ b/sysdeps/sw_64/tst-file-align.h
@@ -0,0 +1,20 @@
+/* Check file alignment.  Alpha version.
+   Copyright (C) 2021-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This should cover all possible alignments we currently support.  */
+#define ALIGN 0x10000
diff --git a/sysdeps/sw_64/udiv_qrnnd.S b/sysdeps/sw_64/udiv_qrnnd.S
new file mode 100644
index 00000000..29aae543
--- /dev/null
+++ b/sysdeps/sw_64/udiv_qrnnd.S
@@ -0,0 +1,159 @@
+ # Sw_64 1621 __udiv_qrnnd
+
+ # Copyright (C) 1992-2018 Free Software Foundation, Inc.
+
+ # This file is part of the GNU MP Library.
+
+ # The GNU MP Library is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU Lesser General Public License as published by
+ # the Free Software Foundation; either version 2.1 of the License, or (at your
+ # option) any later version.
+
+ # The GNU MP Library is distributed in the hope that it will be useful, but
+ # WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ # or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ # License for more details.
+
+ # You should have received a copy of the GNU Lesser General Public License
+ # along with the GNU MP Library.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sysdep.h>
+
+        .set noreorder
+        .set noat
+
+	.text
+
+LEAF(__udiv_qrnnd, 0)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.prologue 1
+#else
+        .prologue 0
+#endif
+
+#define cnt	$2
+#define tmp	$3
+#define rem_ptr	$16
+#define n1	$17
+#define n0	$18
+#define d	$19
+#define qb	$20
+
+	ldi	cnt,16
+	blt	d,$largedivisor
+
+$loop1:	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	d,n1,qb
+	subl	n1,d,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	d,n1,qb
+	subl	n1,d,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	d,n1,qb
+	subl	n1,d,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	d,n1,qb
+	subl	n1,d,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	subl	cnt,1,cnt
+	bgt	cnt,$loop1
+	stl	n1,0(rem_ptr)
+	bis	$31,n0,$0
+	ret	$31,($26),1
+
+$largedivisor:
+	and	n0,1,$4
+
+	srl	n0,1,n0
+	sll	n1,63,tmp
+	or	tmp,n0,n0
+	srl	n1,1,n1
+
+	and	d,1,$6
+	srl	d,1,$5
+	addl	$5,$6,$5
+
+$loop2:	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	$5,n1,qb
+	subl	n1,$5,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	$5,n1,qb
+	subl	n1,$5,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	$5,n1,qb
+	subl	n1,$5,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	cmplt	n0,0,tmp
+	addl	n1,n1,n1
+	bis	n1,tmp,n1
+	addl	n0,n0,n0
+	cmpule	$5,n1,qb
+	subl	n1,$5,tmp
+	selne	qb,tmp,n1,n1
+	bis	n0,qb,n0
+	subl	cnt,1,cnt
+	bgt	cnt,$loop2
+
+	addl	n1,n1,n1
+	addl	$4,n1,n1
+	bne	$6,$Odd
+	stl	n1,0(rem_ptr)
+	bis	$31,n0,$0
+	ret	$31,($26),1
+
+$Odd:
+	/* q' in n0. r' in n1 */
+	addl	n1,n0,n1
+
+	cmpult	n1,n0,tmp	# tmp := carry from addl
+	subl	n1,d,AT
+	addl	n0,tmp,n0
+	selne	tmp,AT,n1,n1
+
+	cmpult	n1,d,tmp
+	addl	n0,1,AT
+	seleq	tmp,AT,n0,n0
+	subl	n1,d,AT
+	seleq	tmp,AT,n1,n1
+
+	stl	n1,0(rem_ptr)
+	bis	$31,n0,$0
+	ret	$31,($26),1
+
+	.end	__udiv_qrnnd
diff --git a/sysdeps/sw_64/unwind-arch.h b/sysdeps/sw_64/unwind-arch.h
new file mode 100644
index 00000000..0017d50c
--- /dev/null
+++ b/sysdeps/sw_64/unwind-arch.h
@@ -0,0 +1,28 @@
+/* Dynamic loading of the libgcc unwinder.  sw_64 customization.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _ARCH_UNWIND_LINK_H
+#define _ARCH_UNWIND_LINK_H
+
+#define UNWIND_LINK_GETIP 1
+#define UNWIND_LINK_FRAME_STATE_FOR 1
+#define UNWIND_LINK_FRAME_ADJUSTMENT 0
+#define UNWIND_LINK_EXTRA_FIELDS
+#define UNWIND_LINK_EXTRA_INIT
+
+#endif /* _ARCH_UNWIND_LINK_H */
diff --git a/sysdeps/unix/sw_64/Makefile b/sysdeps/unix/sw_64/Makefile
new file mode 100644
index 00000000..0660847f
--- /dev/null
+++ b/sysdeps/unix/sw_64/Makefile
@@ -0,0 +1,4 @@
+ifeq ($(subdir),rt)
+librt-sysdep_routines += rt-sysdep
+librt-shared-only-routines += rt-sysdep
+endif
diff --git a/sysdeps/unix/sw_64/pipe.S b/sysdeps/unix/sw_64/pipe.S
new file mode 100644
index 00000000..55a14827
--- /dev/null
+++ b/sysdeps/unix/sw_64/pipe.S
@@ -0,0 +1,31 @@
+/* Copyright (C) 1993-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Mosberger (davidm@cs.arizona.edu).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* __pipe is a special syscall since it returns two values.  */
+
+#include <sysdep.h>
+
+PSEUDO (__pipe, pipe, 0)
+	stw	r0, 0(a0)
+	stw	r1, 4(a0)
+	mov	zero, v0
+	ret
+PSEUDO_END(__pipe)
+
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
diff --git a/sysdeps/unix/sw_64/rt-sysdep.S b/sysdeps/unix/sw_64/rt-sysdep.S
new file mode 100644
index 00000000..f966bf1e
--- /dev/null
+++ b/sysdeps/unix/sw_64/rt-sysdep.S
@@ -0,0 +1 @@
+#include <sysdep.S>
diff --git a/sysdeps/unix/sw_64/sysdep.S b/sysdeps/unix/sw_64/sysdep.S
new file mode 100644
index 00000000..cd320caa
--- /dev/null
+++ b/sysdeps/unix/sw_64/sysdep.S
@@ -0,0 +1,65 @@
+/* Copyright (C) 1993-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <features.h>
+
+#if defined(PIC)
+	/* Put this at the end of libc's text segment so that all of
+	   the direct branches from the syscalls are forward, and
+	   thus predicted not taken.  */
+	.section .text.last, "ax", @progbits
+#else
+	.text
+#endif
+
+#if IS_IN (libc)
+# define SYSCALL_ERROR_ERRNO __libc_errno
+#else
+# define SYSCALL_ERROR_ERRNO errno
+#endif
+
+	.align 4
+	.globl	__syscall_error
+	.ent	__syscall_error
+__syscall_error:
+	/* When building a shared library, we branch here without having
+	   loaded the GP.  Nor, since it was a direct branch, have we
+	   loaded PV with our address.
+
+	   When building a static library, we tail call here from another
+	   object file, possibly with a different GP, and must return with
+	   the GP of our caller in place so that linker relaxation works.
+
+	   Both issues are solved by computing the GP into T1 instead of
+	   clobbering the traditional GP register.  */
+	.prologue 0
+	mov	v0, t0
+	br	t1, 1f
+1:	ldih	t1, 0(t1) !gpdisp!1
+	sys_call HMC_rdunique
+
+	ldi	t1, 0(t1) !gpdisp!1
+	ldl	t1, SYSCALL_ERROR_ERRNO(t1) !gottprel
+	addl	v0, t1, t1
+	ldi	v0, -1
+
+	stw	t0, 0(t1)
+	ret
+
+	.end __syscall_error
diff --git a/sysdeps/unix/sysv/linux/sw_64/Implies b/sysdeps/unix/sysv/linux/sw_64/Implies
new file mode 100644
index 00000000..39fc59c0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/Implies
@@ -0,0 +1,6 @@
+sw_64/nptl
+        unix/sysv/linux/wordsize-64
+        ieee754/ldbl-64-128
+        ieee754/ldbl-opt
+        sw_64/sw6b
+        
diff --git a/sysdeps/unix/sysv/linux/sw_64/Makefile b/sysdeps/unix/sysv/linux/sw_64/Makefile
new file mode 100644
index 00000000..f18a7692
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/Makefile
@@ -0,0 +1,36 @@
+ifeq ($(subdir),stdlib)
+gen-as-const-headers += ucontext-offsets.sym
+endif
+
+ifeq ($(subdir),misc)
+sysdep_headers += sw_64/ptrace.h sw_64/regdef.h sys/io.h
+
+sysdep_routines += ieee_get_fp_control ieee_set_fp_control \
+		   ioperm
+
+# Support old timeval32 entry points
+sysdep_routines += osf_adjtime osf_gettimeofday osf_settimeofday \
+		   osf_getitimer osf_setitimer osf_utimes \
+		   osf_getrusage osf_wait4
+
+CFLAGS-ioperm.c = -Wa,-msw6a
+endif
+
+ifeq ($(subdir),signal)
+sysdep_routines += rt_sigaction
+endif
+
+ifeq ($(subdir),math)
+# These 2 routines are normally in libgcc{.a,_s.so.1}.
+# However, sw_64 -mlong-double-128 libgcc relies on
+# glibc providing _Ots* routines and without these files
+# glibc relies on __multc3/__divtc3 only provided
+# by libgcc if configured with -mlong-double-128.
+# Provide these routines here as well.
+libm-routines += multc3 divtc3
+endif   # math
+
+ifeq ($(subdir),conform)
+# For bug 21260.
+conformtest-xfail-conds += sw_64-linux
+endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/Versions b/sysdeps/unix/sysv/linux/sw_64/Versions
new file mode 100644
index 00000000..050a8d0e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/Versions
@@ -0,0 +1,105 @@
+libc {
+  GLIBC_2.0 {
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # Unfortunately in wider use.
+    _inb; _inw; _inl; _outb; _outw; _outl; _bus_base; _bus_base_sparse;
+    _hae_shift;
+
+    # Exception handling support functions from libgcc
+    __register_frame; __register_frame_table; __deregister_frame;
+    __frame_state_for; __register_frame_info_table;
+
+    # b*
+    bus_base; bus_base_sparse;
+
+    # h*
+    hae_shift;
+
+    # i*
+    inb; inl; inw; ioperm; iopl;
+
+    # o*
+    outb; outl; outw;
+
+    # p*
+    pciconfig_read; pciconfig_write; sethae;
+  }
+  GLIBC_2.1 {
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # Linux/Sw_64 64-bit timeval functions.
+    __select; select;
+    adjtime; adjtimex; __adjtimex;
+    __gettimeofday;
+
+    # glob interface change
+    glob; globfree;
+
+    # limit type change
+    getrusage;
+
+    # time type change
+    gettimeofday; getitimer;
+
+    # i*
+    ieee_get_fp_control; ieee_set_fp_control;
+
+    # s*
+    setitimer; settimeofday;
+
+    # u*
+    utimes;
+
+    # w*
+    wait4;
+  }
+  GLIBC_2.1.4 {
+    pciconfig_iobase;
+  }
+  GLIBC_2.2.2 {
+    # w*
+    wordexp;
+  }
+  GLIBC_2.3 {
+    _sys_errlist;
+    _sys_nerr;
+    aio_cancel64;
+    aio_cancel;
+    sys_errlist;
+    sys_nerr;
+  }
+  GLIBC_2.3.3 {
+    # Changed PTHREAD_STACK_MIN.
+    pthread_attr_setstack;
+    pthread_attr_setstacksize;
+  }
+  GLIBC_2.4 {
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.12 {
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.16 {
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.27 {
+    getrlimit; setrlimit; getrlimit64; setrlimit64;
+  }
+  GLIBC_2.34 {
+    aio_cancel64;
+  }
+  GLIBC_PRIVATE {
+    __libc_sw_64_cache_shape;
+  }
+}
+ld {
+  GLIBC_PRIVATE {
+    __libc_sw_64_cache_shape;
+  }
+}
+librt {
+  GLIBC_2.3 {
+    __librt_version_placeholder;
+  }
+}
diff --git a/sysdeps/unix/sysv/linux/sw_64/____longjmp_chk.S b/sysdeps/unix/sysv/linux/sw_64/____longjmp_chk.S
new file mode 100644
index 00000000..7ebdf573
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/____longjmp_chk.S
@@ -0,0 +1,149 @@
+/* Copyright (C) 1992-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <pointer_guard.h>
+#include <jmpbuf-offsets.h>
+
+
+	.section .rodata.str1.1,"aMS",@progbits,1
+	.type   longjmp_msg,@object
+longjmp_msg:
+	.string "longjmp causes uninitialized stack frame"
+	.size   longjmp_msg, .-longjmp_msg
+
+
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.
+   void __longjmp (__jmp_buf env, int val).  */
+	.text
+	.align	4
+	.globl	____longjmp_chk
+	.type	____longjmp_chk, @function
+	.usepv	____longjmp_chk, std
+
+	cfi_startproc
+____longjmp_chk:
+	ldgp    gp, 0(pv)
+#ifdef PROF
+	.set noat
+	ldi     AT, _mcount
+	call     AT, (AT), _mcount
+	.set at
+#endif
+
+	ldl     s2, JB_PC*8(a0)
+	mov	a0, s0
+	ldl     fp, JB_FP*8(a0)
+	mov     a1, s1
+	ldl     s3, JB_SP*8(a0)
+	seleq   s1, 1, s1, s1
+
+#ifdef PTR_DEMANGLE
+	PTR_DEMANGLE(s2, t1)
+	PTR_DEMANGLE2(s3, t1)
+	PTR_DEMANGLE2(fp, t1)
+#endif
+	/* ??? While this is a proper test for detecting a longjmp to an
+	   invalid frame within any given stack, the main thread stack is
+	   located *below* almost everything in the address space.  Which
+	   means that the test at Lfail vs the signal stack will almost
+	   certainly never pass.  We ought bounds check top and bottom of
+	   the current thread's stack.  */
+	cmpule	s3, sp, t1
+	bne	t1, $Lfail
+
+	.align	4
+$Lok:
+	mov	s0, a0
+	mov	s1, v0
+	mov	s3, t0
+	mov	s2, ra
+	cfi_remember_state
+	cfi_def_cfa(a0, 0)
+	cfi_register(sp, t0)
+	cfi_offset(s0, JB_S0*8)
+	cfi_offset(s1, JB_S1*8)
+	cfi_offset(s2, JB_S2*8)
+	cfi_offset(s3, JB_S3*8)
+	cfi_offset(s4, JB_S4*8)
+	cfi_offset(s5, JB_S5*8)
+	cfi_offset(s3, JB_S3*8)
+	cfi_offset($f2, JB_F2*8)
+	cfi_offset($f3, JB_F3*8)
+	cfi_offset($f4, JB_F4*8)
+	cfi_offset($f5, JB_F5*8)
+	cfi_offset($f6, JB_F6*8)
+	cfi_offset($f7, JB_F7*8)
+	cfi_offset($f8, JB_F8*8)
+	cfi_offset($f9, JB_F9*8)
+	ldl	s0, JB_S0*8(a0)
+	ldl	s1, JB_S1*8(a0)
+	ldl	s2, JB_S2*8(a0)
+	ldl	s3, JB_S3*8(a0)
+	ldl	s4, JB_S4*8(a0)
+	ldl	s5, JB_S5*8(a0)
+	fldd     $f2, JB_F2*8(a0)
+	fldd     $f3, JB_F3*8(a0)
+	fldd     $f4, JB_F4*8(a0)
+	fldd     $f5, JB_F5*8(a0)
+	fldd     $f6, JB_F6*8(a0)
+	fldd     $f7, JB_F7*8(a0)
+	fldd     $f8, JB_F8*8(a0)
+	fldd     $f9, JB_F9*8(a0)
+	mov     t0, sp
+	ret
+
+	.align	4
+$Lfail:
+	cfi_restore_state
+	ldi	v0, __NR_sigaltstack
+	ldi	a0, 0
+	ldi	a1, -32(sp)
+	ldi	sp, -32(sp)
+	cfi_adjust_cfa_offset(32)
+	sys_call 0x83
+	ldl	t0, 0(sp)	/* ss_sp */
+	ldw	t1, 8(sp)	/* ss_flags */
+	ldl	t2, 16(sp)	/* ss_size */
+	ldi	sp, 32(sp)
+	cfi_adjust_cfa_offset(-32)
+
+	/* Without working sigaltstack we cannot perform the test.  */
+	bne	a3, $Lok
+
+	addl	t0, t2, t0	/* t0 = ss_sp + ss_size */
+	subl	t0, s3, t0	/* t0 = (ss_sp + ss_size) - new_sp */
+	cmpule	t2, t0, t0	/* t0 = (t0 >= ss_size) */
+	and	t0, t1, t0	/* t0 = (t0 >= ss_size) & (ss_flags & SS_ONSTACK) */
+	bne	t0, $Lok
+
+	ldih	a0, longjmp_msg(gp)	!gprelhigh
+	ldi	a0, longjmp_msg(a0)	!gprellow
+#ifdef PIC
+	call	ra, HIDDEN_JUMPTARGET(__fortify_fail)
+#else
+	bsr	ra, HIDDEN_JUMPTARGET(__fortify_fail)	!samegp
+#endif
+#ifdef XWB20200328
+	bugchk
+#else
+	sys_call 0x81
+#endif
+
+	cfi_endproc
+	.size	____longjmp_chk, .-____longjmp_chk
diff --git a/sysdeps/unix/sysv/linux/sw_64/a.out.h b/sysdeps/unix/sysv/linux/sw_64/a.out.h
new file mode 100644
index 00000000..901b914d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/a.out.h
@@ -0,0 +1,197 @@
+#ifndef __A_OUT_GNU_H__
+#define __A_OUT_GNU_H__
+
+#include <bits/a.out.h>
+
+#define __GNU_EXEC_MACROS__
+
+/*
+ * OSF/1 ECOFF header structs.  ECOFF files consist of:
+ *      - a file header (struct filehdr),
+ *      - an a.out header (struct aouthdr),
+ *      - one or more section headers (struct scnhdr).
+ *        The filhdr's "f_nscns" field contains the
+ *        number of section headers.
+ */
+
+struct filehdr
+{
+  /* OSF/1 "file" header */
+  unsigned short f_magic, f_nscns;
+  unsigned int   f_timdat;
+  unsigned long  f_symptr;
+  unsigned int   f_nsyms;
+  unsigned short f_opthdr, f_flags;
+};
+
+struct aouthdr
+{
+  unsigned long info;		/* After that it looks quite normal..  */
+  unsigned long tsize;
+  unsigned long dsize;
+  unsigned long bsize;
+  unsigned long entry;
+  unsigned long text_start;	/* With a few additions that actually make sense.  */
+  unsigned long data_start;
+  unsigned long bss_start;
+  unsigned int  gprmask, fprmask; /* Bitmask of general & floating point regs used in binary.  */
+  unsigned long gpvalue;
+};
+
+struct scnhdr
+{
+  char           s_name[8];
+  unsigned long  s_paddr;
+  unsigned long  s_vaddr;
+  unsigned long  s_size;
+  unsigned long  s_scnptr;
+  unsigned long  s_relptr;
+  unsigned long  s_lnnoptr;
+  unsigned short s_nreloc;
+  unsigned short s_nlnno;
+  unsigned int   s_flags;
+};
+
+struct exec
+{
+  /* OSF/1 "file" header */
+  struct filehdr fh;
+  struct aouthdr ah;
+};
+
+#define a_info		ah.info
+#define a_text		ah.tsize
+#define a_data		ah.dsize
+#define a_bss		ah.bsize
+#define a_entry		ah.entry
+#define a_textstart	ah.text_start
+#define a_datastart	ah.data_start
+#define a_bssstart	ah.bss_start
+#define a_gprmask	ah.gprmask
+#define a_fprmask	ah.fprmask
+#define a_gpvalue	ah.gpvalue
+
+
+#define AOUTHSZ		sizeof (struct aouthdr)
+#define SCNHSZ		sizeof (struct scnhdr)
+#define SCNROUND	16
+
+enum machine_type
+{
+  M_OLDSUN2 = 0,
+  M_68010 = 1,
+  M_68020 = 2,
+  M_SPARC = 3,
+  M_386 = 100,
+  M_MIPS1 = 151,
+  M_MIPS2 = 152
+};
+
+#define N_MAGIC(exec)	((exec).a_info & 0xffff)
+#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
+#define N_FLAGS(exec)	(((exec).a_info >> 24) & 0xff)
+#define N_SET_INFO(exec, magic, type, flags) \
+  ((exec).a_info = ((magic) & 0xffff)					\
+   | (((int)(type) & 0xff) << 16)					\
+   | (((flags) & 0xff) << 24))
+#define N_SET_MAGIC(exec, magic) \
+  ((exec).a_info = ((exec).a_info & 0xffff0000) | ((magic) & 0xffff))
+#define N_SET_MACHTYPE(exec, machtype) \
+  ((exec).a_info =							\
+   ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
+#define N_SET_FLAGS(exec, flags) \
+  ((exec).a_info =							\
+   ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
+
+/* Code indicating object file or impure executable.  */
+#define OMAGIC 0407
+/* Code indicating pure executable.  */
+#define NMAGIC 0410
+/* Code indicating demand-paged executable.  */
+#define ZMAGIC 0413
+/* This indicates a demand-paged executable with the header in the text.
+   The first page is unmapped to help trap NULL pointer references.  */
+#define QMAGIC 0314
+/* Code indicating core file.  */
+#define CMAGIC 0421
+
+#define N_TRSIZE(x)	0
+#define N_DRSIZE(x)	0
+#define N_SYMSIZE(x)	0
+#define N_BADMAG(x) \
+  (N_MAGIC(x) != OMAGIC	&& N_MAGIC(x) != NMAGIC				\
+   && N_MAGIC(x) != ZMAGIC && N_MAGIC(x) != QMAGIC)
+#define _N_HDROFF(x)	(1024 - sizeof (struct exec))
+#define N_TXTOFF(x) \
+  ((long) N_MAGIC(x) == ZMAGIC ? 0					\
+   : ((sizeof (struct exec) + (x).fh.f_nscns * SCNHSZ + SCNROUND - 1)	\
+      & ~(SCNROUND - 1)))
+
+#define N_DATOFF(x)	(N_TXTOFF(x) + (x).a_text)
+#define N_TRELOFF(x)	(N_DATOFF(x) + (x).a_data)
+#define N_DRELOFF(x)	(N_TRELOFF(x) + N_TRSIZE(x))
+#define N_SYMOFF(x)	(N_DRELOFF(x) + N_DRSIZE(x))
+#define N_STROFF(x)	(N_SYMOFF(x) + N_SYMSIZE(x))
+
+/* Address of text segment in memory after it is loaded.  */
+#define N_TXTADDR(x)	((x).a_textstart)
+
+/* Address of data segment in memory after it is loaded.  */
+#define SEGMENT_SIZE	1024
+
+#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))
+#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)
+
+#define N_DATADDR(x)	((x).a_datastart)
+#define N_BSSADDR(x)	((x).a_bssstart)
+
+#if !defined (N_NLIST_DECLARED)
+struct nlist
+{
+  union
+    {
+      char *n_name;
+      struct nlist *n_next;
+      long n_strx;
+    } n_un;
+  unsigned char n_type;
+  char n_other;
+  short n_desc;
+  unsigned long n_value;
+};
+#endif /* no N_NLIST_DECLARED.  */
+
+#define N_UNDF	0
+#define N_ABS	2
+#define N_TEXT	4
+#define N_DATA	6
+#define N_BSS	8
+#define N_FN	15
+#define N_EXT	1
+#define N_TYPE	036
+#define N_STAB	0340
+#define N_INDR	0xa
+#define	N_SETA	0x14	/* Absolute set element symbol.  */
+#define	N_SETT	0x16	/* Text set element symbol.  */
+#define	N_SETD	0x18	/* Data set element symbol.  */
+#define	N_SETB	0x1A	/* Bss set element symbol.  */
+#define N_SETV	0x1C	/* Pointer to set vector in data area.  */
+
+#if !defined (N_RELOCATION_INFO_DECLARED)
+/* This structure describes a single relocation to be performed.
+   The text-relocation section of the file is a vector of these structures,
+   all of which apply to the text section.
+   Likewise, the data-relocation section applies to the data section.  */
+
+struct relocation_info
+{
+  int r_address;
+  unsigned int r_symbolnum:24;
+  unsigned int r_pcrel:1;
+  unsigned int r_length:2;
+  unsigned int r_extern:1;
+  unsigned int r_pad:4;
+};
+#endif /* no N_RELOCATION_INFO_DECLARED.  */
+
+#endif /* __A_OUT_GNU_H__ */
diff --git a/sysdeps/unix/sysv/linux/sw_64/adjtime.c b/sysdeps/unix/sysv/linux/sw_64/adjtime.c
new file mode 100644
index 00000000..782b494e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/adjtime.c
@@ -0,0 +1,22 @@
+/* adjtime -- Adjust the current time of day.  Linux/Sw_64/tv64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* We can use the generic Linux implementation, but we have to override its
+   default symbol version.  */
+#define VERSION_adjtime GLIBC_2.1
+#include <sysdeps/unix/sysv/linux/adjtime.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/adjtimex.c b/sysdeps/unix/sysv/linux/sw_64/adjtimex.c
new file mode 100644
index 00000000..6f329035
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/adjtimex.c
@@ -0,0 +1,22 @@
+/* adjtimex -- Adjust the current time of day.  Linux/Sw_64/tv64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We can use the generic Linux implementation, but we have to override its
+   default symbol version.  */
+#define VERSION_adjtimex GLIBC_2.1
+#include <sysdeps/unix/sysv/linux/adjtimex.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/aio_cancel.c b/sysdeps/unix/sysv/linux/sw_64/aio_cancel.c
new file mode 100644
index 00000000..6e4352a9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/aio_cancel.c
@@ -0,0 +1,35 @@
+#include <shlib-compat.h>
+
+#define aio_cancel64 XXX
+#include <aio.h>
+#undef aio_cancel64
+#include <errno.h>
+
+extern __typeof (aio_cancel) __new_aio_cancel;
+extern __typeof (aio_cancel) __old_aio_cancel;
+
+#define __aio_cancel	__new_aio_cancel
+
+#include <rt/aio_cancel.c>
+
+#undef __aio_cancel
+versioned_symbol (libc, __new_aio_cancel, aio_cancel, GLIBC_2_34);
+versioned_symbol (libc, __new_aio_cancel, aio_cancel64, GLIBC_2_34);
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_3, GLIBC_2_34)
+compat_symbol (librt, __new_aio_cancel, aio_cancel, GLIBC_2_3);
+compat_symbol (librt, __new_aio_cancel, aio_cancel64, GLIBC_2_3);
+#endif
+
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_1, GLIBC_2_3)
+
+#undef ECANCELED
+#define __aio_cancel	__old_aio_cancel
+#define ECANCELED	125
+
+#include <rt/aio_cancel.c>
+
+#undef __aio_cancel
+compat_symbol (librt, __old_aio_cancel, aio_cancel, GLIBC_2_1);
+compat_symbol (librt, __old_aio_cancel, aio_cancel64, GLIBC_2_1);
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/arch-syscall.h b/sysdeps/unix/sysv/linux/sw_64/arch-syscall.h
new file mode 100644
index 00000000..62597a14
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/arch-syscall.h
@@ -0,0 +1,376 @@
+/* AUTOGENERATED by update-syscall-lists.py.  */
+#define __NR_accept 99
+#define __NR_accept4 502
+#define __NR_access 33
+#define __NR_acct 51
+#define __NR_add_key 439
+#define __NR_adjtimex 366
+#define __NR_afs_syscall 338
+#define __NR_bdflush 300
+#define __NR_bind 104
+#define __NR_bpf 170
+#define __NR_brk 17
+#define __NR_cachestat 190
+#define __NR_capget 368
+#define __NR_capset 369
+#define __NR_chdir 12
+#define __NR_chmod 15
+#define __NR_chown 16
+#define __NR_chroot 61
+#define __NR_clock_adjtime 499
+#define __NR_clock_getres 421
+#define __NR_clock_gettime 420
+#define __NR_clock_nanosleep 422
+#define __NR_clock_settime 419
+#define __NR_clone 312
+#define __NR_clone3 282
+#define __NR_close 6
+#define __NR_close_range 283
+#define __NR_connect 98
+#define __NR_copy_file_range 515
+#define __NR_create_module 306
+#define __NR_delete_module 308
+#define __NR_dipc 373
+#define __NR_dup 41
+#define __NR_dup2 90
+#define __NR_dup3 487
+#define __NR_epoll_create 407
+#define __NR_epoll_create1 486
+#define __NR_epoll_ctl 408
+#define __NR_epoll_pwait 474
+#define __NR_epoll_pwait2 180
+#define __NR_epoll_wait 409
+#define __NR_eventfd 478
+#define __NR_eventfd2 485
+#define __NR_execve 59
+#define __NR_execveat 513
+#define __NR_exit 1
+#define __NR_exit_group 405
+#define __NR_faccessat 462
+#define __NR_faccessat2 286
+#define __NR_fadvise64 413
+#define __NR_fallocate 480
+#define __NR_fanotify_init 494
+#define __NR_fanotify_mark 495
+#define __NR_fchdir 13
+#define __NR_fchmod 124
+#define __NR_fchmodat 461
+#define __NR_fchmodat2 191
+#define __NR_fchown 123
+#define __NR_fchownat 453
+#define __NR_fcntl 92
+#define __NR_fdatasync 447
+#define __NR_fgetxattr 387
+#define __NR_finit_module 507
+#define __NR_flistxattr 390
+#define __NR_flock 131
+#define __NR_fork 2
+#define __NR_fremovexattr 393
+#define __NR_fsconfig 278
+#define __NR_fsetxattr 384
+#define __NR_fsmount 279
+#define __NR_fsopen 277
+#define __NR_fspick 280
+#define __NR_fstat 91
+#define __NR_fstat64 427
+#define __NR_fstatat64 455
+#define __NR_fstatfs 329
+#define __NR_fstatfs64 230
+#define __NR_fsync 95
+#define __NR_ftruncate 130
+#define __NR_futex 394
+#define __NR_futex_waitv 188
+#define __NR_futimesat 454
+#define __NR_get_kernel_syms 309
+#define __NR_get_mempolicy 430
+#define __NR_get_robust_list 467
+#define __NR_getcpu 473
+#define __NR_getcwd 367
+#define __NR_getdents 305
+#define __NR_getdents64 377
+#define __NR_getegid 179
+#define __NR_geteuid 177
+#define __NR_getgid 178
+#define __NR_getgroups 79
+#define __NR_gethostname 87
+#define __NR_getitimer 361
+#define __NR_getpeername 141
+#define __NR_getpgid 233
+#define __NR_getpgrp 63
+#define __NR_getpid 174
+#define __NR_getppid 175
+#define __NR_getpriority 298
+#define __NR_getrandom 511
+#define __NR_getresgid 372
+#define __NR_getresuid 344
+#define __NR_getrlimit 144
+#define __NR_getrusage 364
+#define __NR_getsid 234
+#define __NR_getsockname 150
+#define __NR_getsockopt 118
+#define __NR_getsysinfo 256
+#define __NR_gettid 378
+#define __NR_gettimeofday 359
+#define __NR_getuid 176
+#define __NR_getxattr 385
+#define __NR_getxgid 47
+#define __NR_getxpid 20
+#define __NR_getxuid 24
+#define __NR_init_module 307
+#define __NR_inotify_add_watch 445
+#define __NR_inotify_init 444
+#define __NR_inotify_init1 489
+#define __NR_inotify_rm_watch 446
+#define __NR_io_cancel 402
+#define __NR_io_destroy 399
+#define __NR_io_getevents 400
+#define __NR_io_pgetevents 403
+#define __NR_io_setup 398
+#define __NR_io_submit 401
+#define __NR_io_uring_enter 273
+#define __NR_io_uring_register 274
+#define __NR_io_uring_setup 272
+#define __NR_ioctl 54
+#define __NR_ioprio_get 443
+#define __NR_ioprio_set 442
+#define __NR_kcmp 506
+#define __NR_kexec_load 448
+#define __NR_keyctl 441
+#define __NR_kill 37
+#define __NR_landlock_add_rule 184
+#define __NR_landlock_create_ruleset 183
+#define __NR_landlock_restrict_self 185
+#define __NR_lchown 208
+#define __NR_lgetxattr 386
+#define __NR_link 9
+#define __NR_linkat 458
+#define __NR_listen 106
+#define __NR_listxattr 388
+#define __NR_llistxattr 389
+#define __NR_lookup_dcookie 406
+#define __NR_lremovexattr 392
+#define __NR_lseek 19
+#define __NR_lsetxattr 383
+#define __NR_lstat 68
+#define __NR_lstat64 426
+#define __NR_madvise 75
+#define __NR_mbind 429
+#define __NR_membarrier 172
+#define __NR_memfd_create 512
+#define __NR_migrate_pages 449
+#define __NR_mincore 375
+#define __NR_mkdir 136
+#define __NR_mkdirat 451
+#define __NR_mknod 14
+#define __NR_mknodat 452
+#define __NR_mlock 314
+#define __NR_mlock2 173
+#define __NR_mlockall 316
+#define __NR_mmap 71
+#define __NR_mount 302
+#define __NR_mount_setattr 181
+#define __NR_move_mount 276
+#define __NR_move_pages 472
+#define __NR_mprotect 74
+#define __NR_mq_getsetattr 437
+#define __NR_mq_notify 436
+#define __NR_mq_open 432
+#define __NR_mq_timedreceive 435
+#define __NR_mq_timedsend 434
+#define __NR_mq_unlink 433
+#define __NR_mremap 341
+#define __NR_msgctl 200
+#define __NR_msgget 201
+#define __NR_msgrcv 202
+#define __NR_msgsnd 203
+#define __NR_msync 217
+#define __NR_munlock 315
+#define __NR_munlockall 317
+#define __NR_munmap 73
+#define __NR_name_to_handle_at 497
+#define __NR_nanosleep 340
+#define __NR_nfsservctl 342
+#define __NR_odd_getpriority 100
+#define __NR_odd_sigprocmask 48
+#define __NR_oldumount 321
+#define __NR_open 45
+#define __NR_open_by_handle_at 498
+#define __NR_open_tree 275
+#define __NR_openat 450
+#define __NR_openat2 284
+#define __NR_pciconfig_iobase 376
+#define __NR_pciconfig_read 345
+#define __NR_pciconfig_write 346
+#define __NR_perf_event_open 493
+#define __NR_personality 324
+#define __NR_pidfd_getfd 285
+#define __NR_pidfd_open 281
+#define __NR_pidfd_send_signal 271
+#define __NR_pipe 42
+#define __NR_pipe2 488
+#define __NR_pivot_root 374
+#define __NR_pkey_alloc 289
+#define __NR_pkey_free 290
+#define __NR_pkey_mprotect 288
+#define __NR_poll 94
+#define __NR_ppoll 464
+#define __NR_prctl 348
+#define __NR_pread64 349
+#define __NR_preadv 490
+#define __NR_preadv2 516
+#define __NR_prlimit64 496
+#define __NR_process_madvise 287
+#define __NR_process_mrelease 187
+#define __NR_process_vm_readv 504
+#define __NR_process_vm_writev 505
+#define __NR_pselect6 463
+#define __NR_ptrace 26
+#define __NR_pwrite64 350
+#define __NR_pwritev 491
+#define __NR_pwritev2 517
+#define __NR_query_module 347
+#define __NR_quotactl 148
+#define __NR_quotactl_fd 182
+#define __NR_read 3
+#define __NR_readahead 379
+#define __NR_readlink 58
+#define __NR_readlinkat 460
+#define __NR_readv 120
+#define __NR_reboot 311
+#define __NR_recv 102
+#define __NR_recvfrom 125
+#define __NR_recvmmsg 479
+#define __NR_recvmsg 113
+#define __NR_remap_file_pages 410
+#define __NR_removexattr 391
+#define __NR_rename 128
+#define __NR_renameat 457
+#define __NR_renameat2 510
+#define __NR_request_key 440
+#define __NR_restart_syscall 412
+#define __NR_rmdir 137
+#define __NR_rseq 404
+#define __NR_rt_sigaction 352
+#define __NR_rt_sigpending 354
+#define __NR_rt_sigprocmask 353
+#define __NR_rt_sigqueueinfo 356
+#define __NR_rt_sigreturn 351
+#define __NR_rt_sigsuspend 357
+#define __NR_rt_sigtimedwait 355
+#define __NR_rt_tgsigqueueinfo 492
+#define __NR_sched_get_priority_max 335
+#define __NR_sched_get_priority_min 336
+#define __NR_sched_getaffinity 396
+#define __NR_sched_getattr 509
+#define __NR_sched_getparam 331
+#define __NR_sched_getscheduler 333
+#define __NR_sched_rr_get_interval 337
+#define __NR_sched_setaffinity 395
+#define __NR_sched_setattr 508
+#define __NR_sched_setparam 330
+#define __NR_sched_setscheduler 332
+#define __NR_sched_yield 334
+#define __NR_seccomp 514
+#define __NR_select 358
+#define __NR_semctl 204
+#define __NR_semget 205
+#define __NR_semop 206
+#define __NR_semtimedop 423
+#define __NR_send 101
+#define __NR_sendfile 370
+#define __NR_sendmmsg 503
+#define __NR_sendmsg 114
+#define __NR_sendto 133
+#define __NR_set_mempolicy 431
+#define __NR_set_mempolicy_home_node 189
+#define __NR_set_robust_list 466
+#define __NR_set_tid_address 411
+#define __NR_setdomainname 166
+#define __NR_setfsgid 326
+#define __NR_setfsuid 325
+#define __NR_setgid 132
+#define __NR_setgroups 80
+#define __NR_sethostname 88
+#define __NR_setitimer 362
+#define __NR_setns 501
+#define __NR_setpgid 39
+#define __NR_setpgrp 82
+#define __NR_setpriority 96
+#define __NR_setregid 127
+#define __NR_setresgid 371
+#define __NR_setresuid 343
+#define __NR_setreuid 126
+#define __NR_setrlimit 145
+#define __NR_setsid 147
+#define __NR_setsockopt 105
+#define __NR_setsysinfo 257
+#define __NR_settimeofday 360
+#define __NR_setuid 23
+#define __NR_setxattr 382
+#define __NR_shmat 209
+#define __NR_shmctl 210
+#define __NR_shmdt 211
+#define __NR_shmget 212
+#define __NR_shutdown 134
+#define __NR_sigaction 156
+#define __NR_sigaltstack 235
+#define __NR_signalfd 476
+#define __NR_signalfd4 484
+#define __NR_sigpending 52
+#define __NR_sigprocmask 299
+#define __NR_sigreturn 103
+#define __NR_sigsuspend 111
+#define __NR_socket 97
+#define __NR_socketcall 119
+#define __NR_socketpair 135
+#define __NR_splice 468
+#define __NR_stat 67
+#define __NR_stat64 425
+#define __NR_statfs 328
+#define __NR_statfs64 229
+#define __NR_statx 518
+#define __NR_swapoff 304
+#define __NR_swapon 322
+#define __NR_symlink 57
+#define __NR_symlinkat 459
+#define __NR_sync 36
+#define __NR_sync_file_range 469
+#define __NR_syncfs 500
+#define __NR_sysfs 254
+#define __NR_sysinfo 318
+#define __NR_syslog 310
+#define __NR_tee 470
+#define __NR_tgkill 424
+#define __NR_timer_create 414
+#define __NR_timer_delete 418
+#define __NR_timer_getoverrun 417
+#define __NR_timer_gettime 416
+#define __NR_timer_settime 415
+#define __NR_timerfd 477
+#define __NR_timerfd_create 481
+#define __NR_timerfd_gettime 483
+#define __NR_timerfd_settime 482
+#define __NR_times 323
+#define __NR_tkill 381
+#define __NR_truncate 129
+#define __NR_tuxcall 397
+#define __NR_umask 60
+#define __NR_umount 22
+#define __NR_umount2 22
+#define __NR_uname 339
+#define __NR_unlink 10
+#define __NR_unlinkat 456
+#define __NR_unshare 465
+#define __NR_uselib 313
+#define __NR_userfaultfd 171
+#define __NR_ustat 327
+#define __NR_utimensat 475
+#define __NR_utimes 363
+#define __NR_vfork 66
+#define __NR_vhangup 76
+#define __NR_vmsplice 471
+#define __NR_vserver 428
+#define __NR_wait4 365
+#define __NR_waitid 438
+#define __NR_write 4
+#define __NR_writev 121
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/a.out.h b/sysdeps/unix/sysv/linux/sw_64/bits/a.out.h
new file mode 100644
index 00000000..82a3dd4c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/a.out.h
@@ -0,0 +1,9 @@
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/dirent.h b/sysdeps/unix/sysv/linux/sw_64/bits/dirent.h
new file mode 100644
index 00000000..a9aff770
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/dirent.h
@@ -0,0 +1,57 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_DIRENT_H
+#define _BITS_DIRENT_H	1
+
+struct dirent
+  {
+#if (defined __USE_FILE_OFFSET64 || defined __sw_64__ )
+    __ino64_t d_ino;
+#else
+    __ino_t d_ino;
+    int __pad;
+#endif
+    __off_t d_off;
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];		/* We must not include limits.h! */
+  };
+
+#ifdef __USE_LARGEFILE64
+/* Note dirent64 is the same as dirent.  */
+struct dirent64
+  {
+    __ino64_t d_ino;
+    __off64_t d_off;
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];		/* We must not include limits.h! */
+  };
+#endif
+
+#define d_fileno	d_ino	/* Backwards compatibility.  */
+
+#undef  _DIRENT_HAVE_D_NAMLEN
+#define _DIRENT_HAVE_D_RECLEN
+#define _DIRENT_HAVE_D_OFF
+#define _DIRENT_HAVE_D_TYPE
+
+/* Inform libc code that these two types are effectively identical.  */
+#define _DIRENT_MATCHES_DIRENT64	1
+
+#endif /* bits/dirent.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/elfclass.h b/sysdeps/unix/sysv/linux/sw_64/bits/elfclass.h
new file mode 100644
index 00000000..51f147a7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/elfclass.h
@@ -0,0 +1,14 @@
+/* This file specifies the native word size of the machine, which indicates
+   the ELF file class used for executables and shared objects on this
+   machine.  */
+
+#ifndef _LINK_H
+# error "Never use <bits/elfclass.h> directly; include <link.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#define __ELF_NATIVE_CLASS __WORDSIZE
+
+/* Linux/Sw_64 is exceptional as it has .hash section with 64 bit entries.  */
+typedef uint64_t Elf_Symndx;
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/epoll.h b/sysdeps/unix/sysv/linux/sw_64/bits/epoll.h
new file mode 100644
index 00000000..95144223
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/epoll.h
@@ -0,0 +1,27 @@
+/* Copyright (C) 2002-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_EPOLL_H
+# error "Never use <bits/epoll.h> directly; include <sys/epoll.h> instead."
+#endif
+
+/* Flags to be passed to epoll_create1.  */
+enum
+  {
+    EPOLL_CLOEXEC  = 010000000
+#define EPOLL_CLOEXEC EPOLL_CLOEXEC
+  };
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/errno.h b/sysdeps/unix/sysv/linux/sw_64/bits/errno.h
new file mode 100644
index 00000000..6f41ee71
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/errno.h
@@ -0,0 +1,53 @@
+/* Error constants.  Linux/Sw_64 specific version.
+   Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_ERRNO_H
+#define _BITS_ERRNO_H 1
+
+#if !defined _ERRNO_H
+# error "Never include <bits/errno.h> directly; use <errno.h> instead."
+#endif
+
+# include <linux/errno.h>
+
+/* Older Linux headers do not define these constants.  */
+# ifndef ENOTSUP
+#  define ENOTSUP		EOPNOTSUPP
+# endif
+
+# ifndef ECANCELED
+#  define ECANCELED		131
+# endif
+
+# ifndef EOWNERDEAD
+#  define EOWNERDEAD		136
+# endif
+
+# ifndef ENOTRECOVERABLE
+#  define ENOTRECOVERABLE	137
+# endif
+
+# ifndef ERFKILL
+#  define ERFKILL		138
+# endif
+
+# ifndef EHWPOISON
+#  define EHWPOISON		139
+# endif
+
+#endif /* bits/errno.h.  */
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/eventfd.h b/sysdeps/unix/sysv/linux/sw_64/bits/eventfd.h
new file mode 100644
index 00000000..78fa0498
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/eventfd.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 2007-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_EVENTFD_H
+# error "Never use <bits/eventfd.h> directly; include <sys/eventfd.h> instead."
+#endif
+
+/* Flags for eventfd.  */
+enum
+  {
+    EFD_SEMAPHORE = 000000001,
+#define EFD_SEMAPHORE EFD_SEMAPHORE
+    EFD_CLOEXEC   = 010000000,
+#define EFD_CLOEXEC EFD_CLOEXEC
+    EFD_NONBLOCK  = 000000004
+#define EFD_NONBLOCK EFD_NONBLOCK
+  };
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/fcntl.h b/sysdeps/unix/sysv/linux/sw_64/bits/fcntl.h
new file mode 100644
index 00000000..b9abc650
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/fcntl.h
@@ -0,0 +1,87 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#define O_CREAT		 01000	/* not fcntl */
+#define O_TRUNC		 02000	/* not fcntl */
+#define O_EXCL		 04000	/* not fcntl */
+#define O_NOCTTY	010000	/* not fcntl */
+
+#define O_NONBLOCK	 00004
+#define O_APPEND	 00010
+#define O_SYNC		020040000
+
+#define __O_DIRECTORY	0100000	/* Must be a directory.  */
+#define __O_NOFOLLOW	0200000	/* Do not follow links.  */
+#define __O_CLOEXEC	010000000 /* Set close_on_exec.  */
+
+#define __O_DIRECT	02000000 /* Direct disk access.  */
+#define __O_NOATIME	04000000 /* Do not set atime.  */
+#define __O_PATH	040000000 /* Resolve pathname but do not open file.  */
+#define __O_TMPFILE	0100100000 /* Atomically create nameless file.  */
+
+/* Not necessary, files are always with 64bit off_t.  */
+#define __O_LARGEFILE	0
+
+#define __O_DSYNC	040000	/* Synchronize data.  */
+
+#define F_GETLK		7	/* Get record locking info.  */
+#define F_SETLK		8	/* Set record locking info (non-blocking).  */
+#define F_SETLKW	9	/* Set record locking info (blocking).  */
+#define F_GETLK64	F_GETLK	/* Get record locking info.  */
+#define F_SETLK64	F_SETLK	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	F_SETLKW /* Set record locking info (blocking).  */
+
+#define __F_SETOWN	5	/* Get owner of socket (receiver of SIGIO).  */
+#define __F_GETOWN	6	/* Set owner of socket (receiver of SIGIO).  */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf() */
+#define F_RDLCK		1	/* Read lock.  */
+#define F_WRLCK		2	/* Write lock.  */
+#define F_UNLCK		8	/* Remove lock.  */
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		16	/* or 3 */
+#define F_SHLCK		32	/* or 4 */
+
+/* We don't need to support __USE_FILE_OFFSET64.  */
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Include generic Linux declarations.  */
+#include <bits/fcntl-linux.h>
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/inotify.h b/sysdeps/unix/sysv/linux/sw_64/bits/inotify.h
new file mode 100644
index 00000000..282d03a6
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/inotify.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2005-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_INOTIFY_H
+# error "Never use <bits/inotify.h> directly; include <sys/inotify.h> instead."
+#endif
+
+/* Flags for the parameter of inotify_init1.  */
+enum
+  {
+    IN_CLOEXEC  = 010000000,
+#define IN_CLOEXEC IN_CLOEXEC
+    IN_NONBLOCK = 000000004
+#define IN_NONBLOCK IN_NONBLOCK
+  };
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/ioctls.h b/sysdeps/unix/sysv/linux/sw_64/bits/ioctls.h
new file mode 100644
index 00000000..a0a78624
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/ioctls.h
@@ -0,0 +1,36 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctls.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+/* Use the definitions from the kernel header files.  */
+#include <asm/ioctls.h>
+
+/* Oh well, this is necessary since the kernel data structure is
+   different from the user-level version.  */
+#undef  TCGETS
+#undef  TCSETS
+#undef  TCSETSW
+#undef  TCSETSF
+#define TCGETS	_IOR ('t', 19, char[44])
+#define TCSETS	_IOW ('t', 20, char[44])
+#define TCSETSW	_IOW ('t', 21, char[44])
+#define TCSETSF	_IOW ('t', 22, char[44])
+
+#include <linux/sockios.h>
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/mman.h b/sysdeps/unix/sysv/linux/sw_64/bits/mman.h
new file mode 100644
index 00000000..d9c366b1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/mman.h
@@ -0,0 +1,66 @@
+/* Definitions for POSIX memory map interface.  Linux/Sw_64 version.
+   Copyright (C) 1997-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+#define __MAP_ANONYMOUS	  0x10		/* Don't use a file.  */
+
+/* These are Linux-specific.  */
+# define MAP_GROWSDOWN	  0x01000	/* Stack-like segment.  */
+# define MAP_DENYWRITE	  0x02000	/* ETXTBSY */
+# define MAP_EXECUTABLE	  0x04000	/* Mark it as an executable.  */
+# define MAP_LOCKED	  0x08000	/* Lock the mapping.  */
+# define MAP_NORESERVE	  0x10000	/* Don't check for reservations.  */
+# define MAP_POPULATE	  0x20000	/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	  0x40000	/* Do not block on IO.  */
+# define MAP_STACK	  0x80000	/* Allocation is for a stack.  */
+# define MAP_HUGETLB	  0x100000	/* Create huge page mapping.  */
+# define MAP_FIXED_NOREPLACE 0x200000	/* MAP_FIXED but do not unmap
+					   underlying mapping.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	  8192
+#define MCL_FUTURE	  16384
+#define MCL_ONFAULT	  32768
+
+#include <bits/mman-linux.h>
+
+/* Values that differ from standard <mman-linux.h>.  For the most part newer
+   values are shared, but older values are skewed.  */
+
+#undef  MAP_FIXED
+#define MAP_FIXED	  0x100
+
+#undef  MS_SYNC
+#define MS_SYNC		  2
+#undef  MS_INVALIDATE
+#define MS_INVALIDATE	  4
+
+#ifdef __USE_MISC
+# undef  MADV_DONTNEED
+# define MADV_DONTNEED    6
+#endif
+#ifdef __USE_XOPEN2K
+# undef  POSIX_MADV_DONTNEED
+# define POSIX_MADV_DONTNEED	6
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/netdb.h b/sysdeps/unix/sysv/linux/sw_64/bits/netdb.h
new file mode 100644
index 00000000..634aca74
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/netdb.h
@@ -0,0 +1,38 @@
+/* Copyright (C) 1996-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _NETDB_H
+# error "Never include <bits/netdb.h> directly; use <netdb.h> instead."
+#endif
+
+
+/* Description of data base entry for a single network.  NOTE: here a
+   poor assumption is made.  The network number is expected to fit
+   into an unsigned long int variable.  */
+struct netent
+{
+  char *n_name;			/* Official name of network.  */
+  char **n_aliases;		/* Alias list.  */
+  int n_addrtype;		/* Net address type.  */
+  /* XXX We should probably use uint32_t for the field and ensure
+     compatibility by adding appropriate padding.  */
+#ifndef GX20230823
+  uint32_t n_net;	/* Network number.  */
+#else
+  unsigned long int n_net;
+#endif
+};
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/procfs-prregset.h b/sysdeps/unix/sysv/linux/sw_64/bits/procfs-prregset.h
new file mode 100644
index 00000000..93643720
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/procfs-prregset.h
@@ -0,0 +1,25 @@
+/* Types of prgregset_t and prfpregset_t.  SW_64 version.
+   Copyright (C) 2018-2021 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PROCFS_H
+# error "Never include <bits/procfs-prregset.h> directly; use <sys/procfs.h> instead."
+#endif
+
+typedef gregset_t __prgregset_t;
+typedef fpregset_t __prfpregset_t;
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/procfs.h b/sysdeps/unix/sysv/linux/sw_64/bits/procfs.h
new file mode 100644
index 00000000..797af7ac
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/procfs.h
@@ -0,0 +1,38 @@
+/* Types for registers for sys/procfs.h.  SW_64 version.
+   Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PROCFS_H
+# error "Never include <bits/procfs.h> directly; use <sys/procfs.h> instead."
+#endif
+
+#include <signal.h>
+#include <sys/ucontext.h>
+
+/*
+ * The OSF/1 version of <sys/procfs.h> makes gregset_t 46 entries long.
+ * I have no idea why that is so.  For now, we just leave it at 33
+ * (32 general regs + processor status word).
+ */
+#define ELF_NGREG       33
+#define ELF_NFPREG      32
+
+typedef unsigned long elf_greg_t;
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef double elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/pthread_stack_min.h b/sysdeps/unix/sysv/linux/sw_64/bits/pthread_stack_min.h
new file mode 100644
index 00000000..8c5ec1e8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/pthread_stack_min.h
@@ -0,0 +1,20 @@
+/* Definition of PTHREAD_STACK_MIN.  Linux/SW_64 version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	24576
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/resource.h b/sysdeps/unix/sysv/linux/sw_64/bits/resource.h
new file mode 100644
index 00000000..7fcdd27b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/resource.h
@@ -0,0 +1,223 @@
+/* Bit values & structures for resource limits.  Sw_64/Linux version.
+   Copyright (C) 1994-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 6,
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
+
+  /* Address space limit (?) */
+  RLIMIT_AS = 7,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 8,
+#define RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 9,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
+
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
+
+  /* Maximum CPU time in microseconds that a process scheduled under a real-time
+     scheduling policy may consume without making a blocking system
+     call before being forcibly descheduled.  */
+  __RLIMIT_RTTIME = 15,
+#define RLIMIT_RTTIME __RLIMIT_RTTIME
+
+  __RLIMIT_NLIMITS = 16,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((__rlim_t) -1)
+#else
+# define RLIM_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+#ifdef __USE_GNU
+  ,
+  /* The calling thread.  */
+  RUSAGE_THREAD = 1
+# define RUSAGE_THREAD RUSAGE_THREAD
+  /* Name for the same functionality on Solaris.  */
+# define RUSAGE_LWP RUSAGE_THREAD
+#endif
+};
+
+#include <bits/types/struct_timeval.h>
+#include <bits/types/struct_rusage.h>
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
+
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+/* Modify and return resource limits of a process atomically.  */
+# ifndef __USE_FILE_OFFSET64
+extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
+		    const struct rlimit *__new_limit,
+		    struct rlimit *__old_limit) __THROW;
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (prlimit, (__pid_t __pid,
+				     enum __rlimit_resource __resource,
+				     const struct rlimit *__new_limit,
+				     struct rlimit *__old_limit), prlimit64);
+#  else
+#   define prlimit prlimit64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
+		      const struct rlimit64 *__new_limit,
+		      struct rlimit64 *__old_limit) __THROW;
+# endif
+#endif
+
+__END_DECLS
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/sigaction.h b/sysdeps/unix/sysv/linux/sw_64/bits/sigaction.h
new file mode 100644
index 00000000..3c744bb7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/sigaction.h
@@ -0,0 +1,80 @@
+/* The proper definitions for Linux/Sw_64 sigaction.
+   Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SIGACTION_H
+#define _BITS_SIGACTION_H 1
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Signal handler.  */
+#if defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler	__sigaction_handler.sa_handler
+# define sa_sigaction	__sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+
+    /* Special flags.  */
+    int sa_flags;
+  };
+
+/* Bits in `sa_flags'.  */
+#define	SA_NOCLDSTOP  0x00000004 /* Don't send SIGCHLD when children stop.  */
+#define SA_NOCLDWAIT  0x00000020 /* Don't create zombie on child death.  */
+#define SA_SIGINFO    0x00000040 /* Invoke signal-catching function with
+				    three arguments instead of one.  */
+#if defined __USE_XOPEN_EXTENDED || defined __USE_MISC
+# define SA_ONSTACK   0x00000001 /* Use signal stack by using `sa_restorer'. */
+#endif
+#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+# define SA_RESTART   0x00000002 /* Restart syscall on signal return.  */
+# define SA_NODEFER   0x00000008 /* Don't automatically block the signal
+				    when its handler is being executed.  */
+# define SA_RESETHAND 0x00000010 /* Reset to SIG_DFL on entry to handler.  */
+#endif
+#ifdef __USE_MISC
+# define SA_INTERRUPT 0x20000000 /* Historical no-op.  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define	SIG_BLOCK     1		 /* Block signals.  */
+#define	SIG_UNBLOCK   2		 /* Unblock signals.  */
+#define	SIG_SETMASK   3		 /* Set the set of blocked signals.  */
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/signalfd.h b/sysdeps/unix/sysv/linux/sw_64/bits/signalfd.h
new file mode 100644
index 00000000..5eb056ea
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/signalfd.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2007-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_SIGNALFD_H
+# error "Never use <bits/signalfd.h> directly; include <sys/signalfd.h> instead."
+#endif
+
+/* Flags for signalfd.  */
+enum
+  {
+    SFD_CLOEXEC  = 010000000,
+#define SFD_CLOEXEC SFD_CLOEXEC
+    SFD_NONBLOCK = 000000004
+#define SFD_NONBLOCK SFD_NONBLOCK
+  };
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/signum-arch.h b/sysdeps/unix/sysv/linux/sw_64/bits/signum-arch.h
new file mode 100644
index 00000000..fcbbe771
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/signum-arch.h
@@ -0,0 +1,67 @@
+/* Signal number definitions.  Linux/Sw_64 version.
+   Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SIGNUM_ARCH_H
+#define _BITS_SIGNUM_ARCH_H 1
+
+#ifndef _SIGNAL_H
+#error "Never include <bits/signum-arch.h> directly; use <signal.h> instead."
+#endif
+
+/* Adjustments and additions to the signal number constants for
+   Linux/Sw_64.  Signal values on this platform were chosen for OSF/1
+   binary compatibility, and are therefore almost identical to the
+   BSD-derived defaults.  */
+
+#define SIGEMT		 7	/* Emulator trap (4.2 BSD).  */
+#define SIGINFO		29	/* Information request (BSD).  */
+#define SIGPWR		SIGINFO	/* Power failure imminent (System V).  */
+
+/* Historical signals specified by POSIX. */
+#define SIGBUS		10	/* Bus error.  */
+#define SIGSYS		12	/* Bad system call.  */
+
+/* New(er) POSIX signals (1003.1-2008, 1003.1-2013).  */
+#define SIGURG		16	/* Urgent data is available at a socket.  */
+#define SIGSTOP		17	/* Stop, unblockable.  */
+#define SIGTSTP		18	/* Keyboard stop.  */
+#define SIGCONT		19	/* Continue.  */
+#define SIGCHLD		20	/* Child terminated or stopped.  */
+#define SIGTTIN		21	/* Background read from control terminal.  */
+#define SIGTTOU		22	/* Background write to control terminal.  */
+#define SIGPOLL		23	/* Pollable event occurred (System V).  */
+#define SIGXCPU		24	/* CPU time limit exceeded.  */
+#define SIGVTALRM	26	/* Virtual timer expired.  */
+#define SIGPROF		27	/* Profiling timer expired.  */
+#define SIGXFSZ		25	/* File size limit exceeded.  */
+#define SIGUSR1		30	/* User-defined signal 1.  */
+#define SIGUSR2		31	/* User-defined signal 2.  */
+
+/* Nonstandard signals found in all modern POSIX systems
+   (including both BSD and Linux).  */
+#define SIGWINCH	28
+
+/* Archaic names for compatibility.  */
+#define SIGIO		SIGPOLL	/* I/O now possible (4.2 BSD).  */
+#define SIGIOT		SIGABRT	/* IOT instruction, abort() on a PDP-11.  */
+#define SIGCLD		SIGCHLD /* Old System V name */
+
+#define __SIGRTMIN	32
+#define __SIGRTMAX	64
+
+#endif	/* <signal.h> included.  */
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/sigstack.h b/sysdeps/unix/sysv/linux/sw_64/bits/sigstack.h
new file mode 100644
index 00000000..fe60c542
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/sigstack.h
@@ -0,0 +1,32 @@
+/* sigstack, sigaltstack definitions.
+   Copyright (C) 1998-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SIGSTACK_H
+#define _BITS_SIGSTACK_H 1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+/* Minimum stack size for a signal handler.  */
+#define MINSIGSTKSZ	4096
+
+/* System default stack size.  */
+#define SIGSTKSZ	16384
+
+#endif /* bits/sigstack.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/socket-constants.h b/sysdeps/unix/sysv/linux/sw_64/bits/socket-constants.h
new file mode 100644
index 00000000..5674dbae
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/socket-constants.h
@@ -0,0 +1,50 @@
+/* Socket constants which vary among Linux architectures.  Version for sw_64.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SOCKET_H
+# error "Never include <bits/socket-constants.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define SOL_SOCKET 65535
+#define SO_ACCEPTCONN 4116
+#define SO_BROADCAST 32
+#define SO_DONTROUTE 16
+#define SO_ERROR 4103
+#define SO_KEEPALIVE 8
+#define SO_LINGER 128
+#define SO_OOBINLINE 256
+#define SO_RCVBUF 4098
+#define SO_RCVLOWAT 4112
+#define SO_RCVTIMEO 4114
+#define SO_REUSEADDR 4
+#define SO_SNDBUF 4097
+#define SO_SNDLOWAT 4113
+#define SO_SNDTIMEO 4115
+#define SO_TYPE 4104
+
+#  define SO_RCVTIMEO_OLD 4114
+#  define SO_SNDTIMEO_OLD 4115
+#  define SO_RCVTIMEO_NEW 66
+#  define SO_SNDTIMEO_NEW 67
+
+#  define SO_TIMESTAMP_OLD 29
+#  define SO_TIMESTAMPNS_OLD 35
+#  define SO_TIMESTAMPING_OLD 37
+#  define SO_TIMESTAMP_NEW 63
+#  define SO_TIMESTAMPNS_NEW 64
+#  define SO_TIMESTAMPING_NEW 65
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/socket_type.h b/sysdeps/unix/sysv/linux/sw_64/bits/socket_type.h
new file mode 100644
index 00000000..02b7ddea
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/socket_type.h
@@ -0,0 +1,55 @@
+/* Define enum __socket_type for Linux/Sw_64.
+   Copyright (C) 1991-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SOCKET_H
+# error "Never include <bits/socket_type.h> directly; use <sys/socket.h> instead."
+#endif
+
+/* Types of sockets.  */
+enum __socket_type
+{
+  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
+				   byte streams.  */
+#define SOCK_STREAM SOCK_STREAM
+  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
+				   of fixed maximum length.  */
+#define SOCK_DGRAM SOCK_DGRAM
+  SOCK_RAW = 3,			/* Raw protocol interface.  */
+#define SOCK_RAW SOCK_RAW
+  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
+#define SOCK_RDM SOCK_RDM
+  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
+				   datagrams of fixed maximum length.  */
+#define SOCK_SEQPACKET SOCK_SEQPACKET
+  SOCK_DCCP = 6,		/* Datagram Congestion Control Protocol.  */
+#define SOCK_DCCP SOCK_DCCP
+  SOCK_PACKET = 10,		/* Linux specific way of getting packets
+				   at the dev level.  For writing rarp and
+				   other similar things on the user level. */
+#define SOCK_PACKET SOCK_PACKET
+
+  /* Flags to be ORed into the type parameter of socket and socketpair and
+     used for the flags parameter of paccept.  */
+
+  SOCK_CLOEXEC = 010000000,	/* Atomically set close-on-exec flag for the
+				   new descriptor(s).  */
+#define SOCK_CLOEXEC SOCK_CLOEXEC
+  SOCK_NONBLOCK = 0x40000000	/* Atomically mark descriptor(s) as
+				   non-blocking.  */
+#define SOCK_NONBLOCK SOCK_NONBLOCK
+};
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/statfs.h b/sysdeps/unix/sysv/linux/sw_64/bits/statfs.h
new file mode 100644
index 00000000..1ee2e2db
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/statfs.h
@@ -0,0 +1,64 @@
+/* Copyright (C) 1997-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>  /* for __fsid_t and __fsblkcnt_t.  */
+
+#ifndef __statfs_word
+#define __statfs_word long
+#endif
+
+struct statfs
+  {
+     __statfs_word f_type;
+     __statfs_word f_bsize;
+     __statfs_word f_blocks;
+     __statfs_word f_bfree;
+     __statfs_word f_bavail;
+     __statfs_word f_files;
+     __statfs_word f_ffree;
+     __fsid_t f_fsid;
+     __statfs_word f_namelen;
+     __statfs_word f_frsize;
+     __statfs_word f_flags;
+     __statfs_word f_spare[4];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+     __statfs_word f_type;
+     __statfs_word f_bsize;
+     __fsblkcnt64_t f_blocks;
+     __fsblkcnt64_t f_bfree;
+     __fsblkcnt64_t f_bavail;
+     __fsfilcnt64_t f_files;
+     __fsfilcnt64_t f_ffree;
+     __fsid_t f_fsid;
+     __statfs_word f_namelen;
+     __statfs_word f_frsize;
+     __statfs_word f_flags;
+     __statfs_word f_spare[4];
+  };
+#endif
+
+/* Tell code we have this member.  */
+#define _STATFS_F_NAMELEN
+#define _STATFS_F_FRSIZE
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/struct_stat.h b/sysdeps/unix/sysv/linux/sw_64/bits/struct_stat.h
new file mode 100644
index 00000000..e21d4727
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/struct_stat.h
@@ -0,0 +1,119 @@
+/* Definition for struct stat.
+   Copyright (C) 2020-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#if !defined _SYS_STAT_H && !defined _FCNTL_H
+# error "Never include <bits/struct_stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+#ifndef _BITS_STRUCT_STAT_H
+#define _BITS_STRUCT_STAT_H	1
+
+struct stat
+  {
+    __dev_t st_dev;		/* Device.  */
+#if (defined __USE_FILE_OFFSET64 || defined __sw_64__) /* mod by XWB */
+    __ino64_t st_ino;		/* File serial number.  */
+#else
+    __ino_t st_ino;		/* File serial number.	*/
+    int __pad0;			/* 64-bit st_ino.  */
+#endif
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __off_t st_size;		/* Size of file, in bytes.  */
+#ifdef __USE_FILE_OFFSET64
+    __blkcnt64_t st_blocks;	/* Nr. 512-byte blocks allocated.  */
+#else
+    __blkcnt_t st_blocks;	/* Nr. 512-byte blocks allocated.  */
+    int __pad1;			/* 64-bit st_blocks.  */
+#endif
+    __mode_t st_mode;		/* File mode.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    int __pad2;			/* Real padding.  */
+#ifdef __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+    long __glibc_reserved[3];
+  };
+
+#ifdef __USE_LARGEFILE64
+/* Note stat64 is the same shape as stat.  */
+struct stat64
+  {
+    __dev_t st_dev;		/* Device.  */
+    __ino64_t st_ino;		/* File serial number.  */
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __off_t st_size;		/* Size of file, in bytes.  */
+    __blkcnt64_t st_blocks;	/* Nr. 512-byte blocks allocated.  */
+    __mode_t st_mode;		/* File mode.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    int __pad0;			/* Real padding.  */
+#ifdef __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+    long __glibc_reserved[3];
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+#define _STATBUF_ST_RDEV
+#define _STATBUF_ST_NSEC
+
+
+#endif /* _BITS_STRUCT_STAT_H  */
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/termios-baud.h b/sysdeps/unix/sysv/linux/sw_64/bits/termios-baud.h
new file mode 100644
index 00000000..12b8dc58
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/termios-baud.h
@@ -0,0 +1,46 @@
+/* termios baud rate selection definitions.  Linux/sw_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-baud.h> directly; use <termios.h> instead."
+#endif
+
+#ifdef __USE_MISC
+# define CBAUD	0000037
+# define CBAUDEX 0000000
+# define CMSPAR	  010000000000		/* mark or space (stick) parity */
+# define CRTSCTS  020000000000		/* flow control */
+#endif
+
+#define  B57600   00020
+#define  B115200  00021
+#define  B230400  00022
+#define  B460800  00023
+#define  B500000  00024
+#define  B576000  00025
+#define  B921600  00026
+#define  B1000000 00027
+#define  B1152000 00030
+#define  B1500000 00031
+#define  B2000000 00032
+#define  B2500000 00033
+#define  B3000000 00034
+#define  B3500000 00035
+#define  B4000000 00036
+
+#define __MAX_BAUD B4000000
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cc.h b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cc.h
new file mode 100644
index 00000000..643c7220
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cc.h
@@ -0,0 +1,40 @@
+/* termios c_cc symbolic constant definitions.  Linux/sw_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_cc.h> directly; use <termios.h> instead."
+#endif
+
+/* c_cc characters */
+#define VEOF 0
+#define VEOL 1
+#define VEOL2 2
+#define VERASE 3
+#define VWERASE 4
+#define VKILL 5
+#define VREPRINT 6
+#define VSWTC 7
+#define VINTR 8
+#define VQUIT 9
+#define VSUSP 10
+#define VSTART 12
+#define VSTOP 13
+#define VLNEXT 14
+#define VDISCARD 15
+#define VMIN 16
+#define VTIME 17
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cflag.h b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cflag.h
new file mode 100644
index 00000000..abc46c92
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_cflag.h
@@ -0,0 +1,38 @@
+/* termios control mode definitions.  Linux/sw_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_cflag.h> directly; use <termios.h> instead."
+#endif
+
+#define CSIZE	00001400
+#define   CS5	00000000
+#define   CS6	00000400
+#define   CS7	00001000
+#define   CS8	00001400
+
+#define CSTOPB	00002000
+#define CREAD	00004000
+#define PARENB	00010000
+#define PARODD	00020000
+#define HUPCL	00040000
+
+#define CLOCAL	00100000
+#ifdef __USE_MISC
+# define ADDRB 04000000000
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_iflag.h b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_iflag.h
new file mode 100644
index 00000000..806c92ba
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_iflag.h
@@ -0,0 +1,38 @@
+/* termios input mode definitions.  Linux/sw_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_iflags.h> directly; use <termios.h> instead."
+#endif
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IXON	0001000
+#define IXOFF	0002000
+#define IXANY	0004000
+#define IUCLC	0010000
+#define IMAXBEL	0020000
+#define IUTF8	0040000
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_lflag.h b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_lflag.h
new file mode 100644
index 00000000..f6993dc0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_lflag.h
@@ -0,0 +1,42 @@
+/* termios local mode definitions.  Linux/sw_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_lflag.h> directly; use <termios.h> instead."
+#endif
+
+/* c_lflag bits */
+#define ISIG	0x00000080
+#define ICANON	0x00000100
+#if defined __USE_MISC || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
+# define XCASE	0x00004000
+#endif
+#define ECHO	0x00000008
+#define ECHOE	0x00000002
+#define ECHOK	0x00000004
+#define ECHONL	0x00000010
+#define NOFLSH	0x80000000
+#define TOSTOP	0x00400000
+#ifdef __USE_MISC
+# define ECHOCTL	0x00000040
+# define ECHOPRT	0x00000020
+# define ECHOKE	0x00000001
+# define FLUSHO	0x00800000
+# define PENDIN	0x20000000
+#endif
+#define IEXTEN	0x00000400
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_oflag.h b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_oflag.h
new file mode 100644
index 00000000..09172c71
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/termios-c_oflag.h
@@ -0,0 +1,66 @@
+/* termios output mode definitions.  Linux/sw_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_oflag.h> directly; use <termios.h> instead."
+#endif
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define ONLCR	0000002
+#define OLCUC	0000004
+
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+
+#define OFILL	00000100
+#define OFDEL	00000200
+#if defined __USE_MISC || defined __USE_XOPEN
+# define NLDLY	00001400
+# define   NL0	00000000
+# define   NL1	00000400
+# if defined __USE_MISC
+#  define   NL2	00001000
+#  define   NL3	00001400
+# endif
+# define TABDLY	00006000
+# define   TAB0	00000000
+# define   TAB1	00002000
+# define   TAB2	00004000
+# define   TAB3	00006000
+# define CRDLY	00030000
+# define   CR0	00000000
+# define   CR1	00010000
+# define   CR2	00020000
+# define   CR3	00030000
+# define FFDLY	00040000
+# define   FF0	00000000
+# define   FF1	00040000
+# define BSDLY	00100000
+# define   BS0	00000000
+# define   BS1	00100000
+#endif
+
+#define VTDLY	00200000
+#define   VT0	00000000
+#define   VT1	00200000
+
+#ifdef __USE_MISC
+# define XTABS	TAB3
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/termios-struct.h b/sysdeps/unix/sysv/linux/sw_64/bits/termios-struct.h
new file mode 100644
index 00000000..08185de7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/termios-struct.h
@@ -0,0 +1,37 @@
+/* struct termios definition.  Linux/sw_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-struct.h> directly; use <termios.h> instead."
+#endif
+
+/* SW_64 has C_CC before C_LINE compare to Linux generic definition.  */
+#define NCCS 32
+struct termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_cc[NCCS];		/* control characters */
+    cc_t c_line;		/* line discipline (== c_cc[33]) */
+    speed_t c_ispeed;		/* input speed */
+    speed_t c_ospeed;		/* output speed */
+#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
+#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
+  };
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/timerfd.h b/sysdeps/unix/sysv/linux/sw_64/bits/timerfd.h
new file mode 100644
index 00000000..851467e8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/timerfd.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2008-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_TIMERFD_H
+# error "Never use <bits/timerfd.h> directly; include <sys/timerfd.h> instead."
+#endif
+
+/* Bits to be set in the FLAGS parameter of `timerfd_create'.  */
+enum
+  {
+    TFD_CLOEXEC  = 010000000,
+#define TFD_CLOEXEC TFD_CLOEXEC
+    TFD_NONBLOCK = 000000004
+#define TFD_NONBLOCK TFD_NONBLOCK
+  };
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/typesizes.h b/sysdeps/unix/sysv/linux/sw_64/bits/typesizes.h
new file mode 100644
index 00000000..9b7a4b54
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/typesizes.h
@@ -0,0 +1,83 @@
+/* bits/typesizes.h -- underlying types for *_t.  Linux/Sw_64 version.
+   Copyright (C) 2002-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U64_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U64_TYPE
+#define __INO64_T_TYPE		__U64_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __NLINK_T_TYPE		__U32_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __OFF64_T_TYPE		__S64_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define __RLIM64_T_TYPE		__U64_TYPE
+#define	__BLKCNT_T_TYPE		__U32_TYPE
+#define	__BLKCNT64_T_TYPE	__U64_TYPE
+#define	__FSBLKCNT_T_TYPE	__S32_TYPE
+#define	__FSBLKCNT64_T_TYPE	__S64_TYPE
+#define	__FSFILCNT_T_TYPE	__U32_TYPE
+#define	__FSFILCNT64_T_TYPE	__U64_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__S64_TYPE
+#define __SUSECONDS64_T_TYPE	__S64_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		void *
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
+#define __CPU_MASK_TYPE 	__ULONGWORD_TYPE
+#define __FSWORD_T_TYPE		__S32_TYPE
+
+/* Tell the libc code that off_t and off64_t are actually the same type
+   for all ABI purposes, even if possibly expressed as different base types
+   for C type-checking purposes.  */
+#define __OFF_T_MATCHES_OFF64_T	1
+
+/* And for __rlim_t and __rlim64_t.  */
+#define __RLIM_T_MATCHES_RLIM64_T 1
+
+/* Not for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.  */
+# define __STATFS_MATCHES_STATFS64  0
+
+/* And for getitimer, setitimer and rusage  */
+#define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/bits/wordsize.h b/sysdeps/unix/sysv/linux/sw_64/bits/wordsize.h
new file mode 100644
index 00000000..cb3c41dd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/bits/wordsize.h
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE	64
+#define __WORDSIZE_TIME64_COMPAT32	0
diff --git a/sysdeps/unix/sysv/linux/sw_64/brk_call.h b/sysdeps/unix/sysv/linux/sw_64/brk_call.h
new file mode 100644
index 00000000..c675e21b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/brk_call.h
@@ -0,0 +1,27 @@
+/* Invoke the brk system call.  Alpha version.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+static inline void *
+__brk_call (void *addr)
+{
+  unsigned long int result = INTERNAL_SYSCALL_CALL (brk, addr);
+  if (result == -ENOMEM)
+    /* Mimic the default error reporting behavior.  */
+    result = INTERNAL_SYSCALL_CALL (brk,0);
+  return (void *) result;
+}
diff --git a/sysdeps/unix/sysv/linux/sw_64/c++-types.data b/sysdeps/unix/sysv/linux/sw_64/c++-types.data
new file mode 100644
index 00000000..ac4f133f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/c++-types.data
@@ -0,0 +1,67 @@
+blkcnt64_t:m
+blkcnt_t:j
+blksize_t:j
+caddr_t:Pc
+clockid_t:i
+clock_t:l
+daddr_t:i
+dev_t:m
+fd_mask:l
+fsblkcnt64_t:l
+fsblkcnt_t:i
+fsfilcnt64_t:m
+fsfilcnt_t:j
+fsid_t:8__fsid_t
+gid_t:j
+id_t:j
+ino64_t:m
+ino_t:m
+int16_t:s
+int32_t:i
+int64_t:l
+int8_t:a
+intptr_t:l
+key_t:i
+loff_t:l
+mode_t:j
+nlink_t:j
+off64_t:l
+off_t:l
+pid_t:i
+pthread_attr_t:14pthread_attr_t
+pthread_barrier_t:17pthread_barrier_t
+pthread_barrierattr_t:21pthread_barrierattr_t
+pthread_cond_t:14pthread_cond_t
+pthread_condattr_t:18pthread_condattr_t
+pthread_key_t:j
+pthread_mutex_t:15pthread_mutex_t
+pthread_mutexattr_t:19pthread_mutexattr_t
+pthread_once_t:i
+pthread_rwlock_t:16pthread_rwlock_t
+pthread_rwlockattr_t:20pthread_rwlockattr_t
+pthread_spinlock_t:i
+pthread_t:m
+quad_t:l
+register_t:l
+rlim64_t:m
+rlim_t:m
+sigset_t:10__sigset_t
+size_t:m
+socklen_t:j
+ssize_t:l
+suseconds_t:l
+time_t:l
+u_char:h
+uid_t:j
+uint:j
+u_int:j
+u_int16_t:t
+u_int32_t:j
+u_int64_t:m
+u_int8_t:h
+ulong:m
+u_long:m
+u_quad_t:m
+useconds_t:j
+ushort:t
+u_short:t
diff --git a/sysdeps/unix/sysv/linux/sw_64/clone.S b/sysdeps/unix/sysv/linux/sw_64/clone.S
new file mode 100644
index 00000000..eef8776a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/clone.S
@@ -0,0 +1,117 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags,
+	     void *arg, pid_t *ptid, void *tls, pid_t *ctid);
+
+   Note that everything past ARG is technically optional, based
+   on FLAGS, and that CTID is arg 7, and thus is on the stack.
+   However, since a load from top-of-stack better be legal always,
+   we don't bother checking FLAGS.  */
+
+        .text
+	.align	4
+	.globl	__clone
+	.ent	__clone
+	.usepv	__clone, USEPV_PROF
+
+	cfi_startproc
+__clone:
+#ifdef PROF
+	.set noat
+	ldgp	gp,0(pv)
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+#endif
+
+	/* Sanity check arguments.  */
+	ldi	v0, EINVAL
+	beq	a0, SYSCALL_ERROR_LABEL	/* no NULL function pointers */
+        bic     a1, 0xf,a1 /*Align sp. By zyl */
+	beq	a1, SYSCALL_ERROR_LABEL	/* no NULL stack pointers */
+
+	/* Save the fn ptr and arg on the new stack.  */
+	subl	a1, 32, a1
+	stl	a0, 0(a1)
+	stl	a3, 8(a1)
+	stl	a2, 16(a1)
+
+	/* The syscall is of the form clone(flags, usp, ptid, ctid, tls).
+	   Shift the flags, ptid, ctid, tls arguments into place; the
+	   child_stack argument is already correct.  */
+	mov	a2, a0
+	mov	a4, a2
+	ldl	a3, 0(sp)
+	mov	a5, a4
+
+	/* Do the system call.  */
+	ldi	v0, __NR_clone
+	sys_call HMC_callsys
+
+	bne	a3, SYSCALL_ERROR_LABEL
+	beq	v0, thread_start
+
+	/* Successful return from the parent.  */
+	ret
+
+PSEUDO_END(__clone)
+	cfi_endproc
+
+/* Load up the arguments to the function.  Put this block of code in
+   its own function so that we can terminate the stack trace with our
+   debug info.  */
+
+	.align	4
+	.ent thread_start
+	cfi_startproc
+thread_start:
+	mov	0, fp
+	cfi_def_cfa_register(fp)
+	cfi_undefined(ra)
+
+	/* Load up the arguments.  */
+	ldl	pv, 0(sp)
+	ldl	a0, 8(sp)
+	addl	sp, 32, sp
+
+	/* Call the user's function.  */
+	call	ra, (pv)
+	ldgp	gp, 0(ra)
+
+	mov     v0, a0
+	ldi	v0, __NR_exit
+	sys_call HMC_callsys
+
+	/* Die horribly.  */
+	.align	4
+	halt
+
+	.align	4
+	cfi_endproc
+	.end thread_start
+
+libc_hidden_def (__clone)
+weak_alias (__clone, clone)
diff --git a/sysdeps/unix/sysv/linux/sw_64/configure b/sysdeps/unix/sysv/linux/sw_64/configure
new file mode 100644
index 00000000..a8d00a78
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/configure
@@ -0,0 +1,5 @@
+# This file is generated from configure.ac by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/sysv/linux/sw_64
+
+# We did historically export the unwinder from glibc.
+libc_cv_gcc_unwind_find_fde=yes
diff --git a/sysdeps/unix/sysv/linux/sw_64/configure.ac b/sysdeps/unix/sysv/linux/sw_64/configure.ac
new file mode 100644
index 00000000..d837c72e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/configure.ac
@@ -0,0 +1,5 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/sw_64
+
+# We did historically export the unwinder from glibc.
+libc_cv_gcc_unwind_find_fde=yes
diff --git a/sysdeps/unix/sysv/linux/sw_64/dl-auxv.h b/sysdeps/unix/sysv/linux/sw_64/dl-auxv.h
new file mode 100644
index 00000000..2d73da0d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/dl-auxv.h
@@ -0,0 +1,40 @@
+/* Auxiliary vector processing for Linux/Sw_64.
+   Copyright (C) 2007-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Scan the Aux Vector for the cache shape entries.  */
+
+extern long __libc_sw_64_cache_shape[4];
+#define DL_PLATFORM_AUXV					\
+  __libc_sw_64_cache_shape[0] = auxv_values[AT_L1I_CACHESHAPE]; \
+  __libc_sw_64_cache_shape[1] = auxv_values[AT_L1D_CACHESHAPE]; \
+  __libc_sw_64_cache_shape[2] = auxv_values[AT_L2_CACHESHAPE];	\
+  __libc_sw_64_cache_shape[3] = auxv_values[AT_L3_CACHESHAPE];
+/*#define DL_PLATFORM_AUXV				\
+      case AT_L1I_CACHESHAPE:				\
+	__libc_sw_64_cache_shape[0] = av->a_un.a_val;	\
+	break;						\
+      case AT_L1D_CACHESHAPE:				\
+	__libc_sw_64_cache_shape[1] = av->a_un.a_val;	\
+	break;						\
+      case AT_L2_CACHESHAPE:				\
+	__libc_sw_64_cache_shape[2] = av->a_un.a_val;	\
+	break;						\
+      case AT_L3_CACHESHAPE:				\
+	__libc_sw_64_cache_shape[3] = av->a_un.a_val;	\
+	break;
+*/
diff --git a/sysdeps/unix/sysv/linux/sw_64/dl-support.c b/sysdeps/unix/sysv/linux/sw_64/dl-support.c
new file mode 100644
index 00000000..29021767
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/dl-support.c
@@ -0,0 +1,2 @@
+#include "dl-auxv.h"
+#include <elf/dl-support.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/dl-sysdep.c b/sysdeps/unix/sysv/linux/sw_64/dl-sysdep.c
new file mode 100644
index 00000000..be352fd9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/dl-sysdep.c
@@ -0,0 +1,5 @@
+#include "dl-auxv.h"
+
+long __libc_sw_64_cache_shape[4] = { -2, -2, -2, -2 };
+
+#include <sysdeps/unix/sysv/linux/dl-sysdep.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/errlist-compat.c b/sysdeps/unix/sysv/linux/sw_64/errlist-compat.c
new file mode 100644
index 00000000..0a8d88f1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/errlist-compat.c
@@ -0,0 +1,43 @@
+/* Linux sys_errlist compat symbol definitions.  Sw_64 version.
+   Copyright (C) 2020-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errlist-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+DEFINE_COMPAT_ERRLIST (131, GLIBC_2_0)
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_3)
+DEFINE_COMPAT_ERRLIST (131, GLIBC_2_1)
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3, GLIBC_2_4)
+DEFINE_COMPAT_ERRLIST (132, GLIBC_2_3)
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_4, GLIBC_2_12)
+DEFINE_COMPAT_ERRLIST (138, GLIBC_2_4)
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_12, GLIBC_2_16)
+DEFINE_COMPAT_ERRLIST (139, GLIBC_2_12)
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_16, GLIBC_2_32)
+DEFINE_COMPAT_ERRLIST (140, GLIBC_2_16)
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/fpu/Implies b/sysdeps/unix/sysv/linux/sw_64/fpu/Implies
new file mode 100644
index 00000000..7fda688c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/fpu/Implies
@@ -0,0 +1,2 @@
+# Override ldbl-opt with sw_64 specific routines.
+sw_64/fpu
diff --git a/sysdeps/unix/sysv/linux/sw_64/fraiseexcpt.S b/sysdeps/unix/sysv/linux/sw_64/fraiseexcpt.S
new file mode 100644
index 00000000..d5407368
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/fraiseexcpt.S
@@ -0,0 +1,58 @@
+/* Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include "kernel_sysinfo.h"
+
+
+	.text
+
+ENTRY(__feraiseexcept)
+	cfi_startproc
+	PSEUDO_PROLOGUE
+
+	ldi	sp, -16(sp)
+	cfi_adjust_cfa_offset(16)
+
+	ldi	v0, __NR_setsysinfo
+	stl	a0, 0(sp)
+	mov	sp, a1
+	ldi	a0, SSI_IEEE_RAISE_EXCEPTION
+	sys_call HMC_callsys
+
+	ldi	sp, 16(sp)
+	cfi_adjust_cfa_offset(-16)
+
+	/* Here in libm we can't use SYSCALL_ERROR_LABEL.  Nor is it clear
+	   that we'd want to set errno anyway.  All we're required to do is
+	   return non-zero on error.  Which is exactly A3.  */
+	mov	a3, v0
+	ret
+
+END(__feraiseexcept)
+	cfi_endproc
+
+#if IS_IN (libm)
+# include <shlib-compat.h>
+# if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__feraiseexcept, __old_feraiseexcept)
+compat_symbol (libm, __old_feraiseexcept, feraiseexcept, GLIBC_2_1);
+# endif
+libm_hidden_def (__feraiseexcept)
+libm_hidden_ver (__feraiseexcept, feraiseexcept)
+versioned_symbol (libm, __feraiseexcept, feraiseexcept, GLIBC_2_2);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/fstatfs.c b/sysdeps/unix/sysv/linux/sw_64/fstatfs.c
new file mode 100644
index 00000000..0b8c38d2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/fstatfs.c
@@ -0,0 +1,30 @@
+/* Get filesystem statistics.  Linux/sw_64.
+   Copyright (C) 2011-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/statfs.h>
+#include <kernel_stat.h>
+#include <sysdep.h>
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs (int fd, struct statfs *buf)
+{
+  return INLINE_SYSCALL_CALL (fstatfs, fd, buf);
+}
+libc_hidden_def (__fstatfs)
+weak_alias (__fstatfs, fstatfs)
diff --git a/sysdeps/unix/sysv/linux/sw_64/fxstat64.c b/sysdeps/unix/sysv/linux/sw_64/fxstat64.c
new file mode 100644
index 00000000..da658500
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/fxstat64.c
@@ -0,0 +1,45 @@
+/* fxstat64 using old-style Unix stat system call.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __fxstat __redirect___fxstat64
+#include <sys/stat.h>
+#undef __fxstat
+#include <kernel_stat.h>
+#include <sysdep.h>
+#include <xstatconv.h>
+
+/* Get information about the file NAME in BUF.  */
+int
+__fxstat64 (int vers, int fd, struct stat64 *buf)
+{
+  switch (vers)
+    {
+    case _STAT_VER_KERNEL64:
+      return INLINE_SYSCALL_CALL (fstat64, fd, buf);
+
+    default:
+      {
+        struct kernel_stat kbuf;
+	int r = INTERNAL_SYSCALL_CALL (fstat, fd, &kbuf);
+	if (r == 0)
+	  return __xstat_conv (vers, &kbuf, buf);
+	return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
+      }
+    }
+}
+strong_alias (__fxstat64, __fxstat);
diff --git a/sysdeps/unix/sysv/linux/sw_64/fxstatat64.c b/sysdeps/unix/sysv/linux/sw_64/fxstatat64.c
new file mode 100644
index 00000000..0692a7f2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/fxstatat64.c
@@ -0,0 +1,32 @@
+/* fxstat using old-style Unix stat system call.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __fxstatat __redirect___fxstatat64
+#include <sys/stat.h>
+#undef __fxstatat
+#include <kernel_stat.h>
+#include <sysdep.h>
+#include <xstatconv.h>
+
+/* Get information about the file NAME in BUF.  */
+int
+__fxstatat64 (int vers, int fd, const char *file, struct stat64 *st, int flag)
+{
+  return INLINE_SYSCALL_CALL (fstatat64, fd, file, st, flag);
+}
+strong_alias (__fxstatat64, __fxstatat);
diff --git a/sysdeps/unix/sysv/linux/sw_64/getclktck.c b/sysdeps/unix/sysv/linux/sw_64/getclktck.c
new file mode 100644
index 00000000..6636bbe6
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/getclktck.c
@@ -0,0 +1,2 @@
+#define SYSTEM_CLK_TCK	1024
+#include <sysdeps/unix/sysv/linux/getclktck.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/getcontext.S b/sysdeps/unix/sysv/linux/sw_64/getcontext.S
new file mode 100644
index 00000000..39f97522
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/getcontext.S
@@ -0,0 +1,440 @@
+/* Save current context.
+   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <ucontext-offsets.h>
+
+/* ??? Should be a better place for this that's asm friendly.  */
+#define SIG_BLOCK     1
+
+
+ENTRY (__getcontext)
+#ifdef PROF
+	ldgp    gp, 0(pv)
+	.set noat
+	ldi     AT, _mcount
+	call     AT, (AT), _mcount
+	.set at
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	bsr	$0, __getcontext_x
+	mov	$31, $0
+	ret
+
+END(__getcontext)
+weak_alias (__getcontext, getcontext)
+
+
+/* An internal routine used by getcontext and setcontext.
+   The incomming return address register is $0.  */
+
+	.align	4
+	.globl	__getcontext_x
+	.hidden	__getcontext_x
+	.usepv	__getcontext_x, no
+
+	cfi_startproc
+	cfi_return_column (64)
+__getcontext_x:
+	cfi_register (64, 0)
+
+	.set noat
+
+	/* Return value of getcontext.  $0 is the only register
+	   whose value is not preserved. */
+	stl	$31, UC_SIGCTX+SC_REGS($16)
+
+	/* Store all registers into the context.  */
+	stl	$1, UC_SIGCTX+SC_REGS+1*8($16)
+	stl	$2, UC_SIGCTX+SC_REGS+2*8($16)
+	stl	$3, UC_SIGCTX+SC_REGS+3*8($16)
+	stl	$4, UC_SIGCTX+SC_REGS+4*8($16)
+	stl	$5, UC_SIGCTX+SC_REGS+5*8($16)
+	stl	$6, UC_SIGCTX+SC_REGS+6*8($16)
+	stl	$7, UC_SIGCTX+SC_REGS+7*8($16)
+	stl	$8, UC_SIGCTX+SC_REGS+8*8($16)
+	stl	$9, UC_SIGCTX+SC_REGS+9*8($16)
+	stl	$10, UC_SIGCTX+SC_REGS+10*8($16)
+	stl	$11, UC_SIGCTX+SC_REGS+11*8($16)
+	stl	$12, UC_SIGCTX+SC_REGS+12*8($16)
+	stl	$13, UC_SIGCTX+SC_REGS+13*8($16)
+	stl	$14, UC_SIGCTX+SC_REGS+14*8($16)
+	stl	$15, UC_SIGCTX+SC_REGS+15*8($16)
+	stl	$16, UC_SIGCTX+SC_REGS+16*8($16)
+	stl	$17, UC_SIGCTX+SC_REGS+17*8($16)
+	stl	$18, UC_SIGCTX+SC_REGS+18*8($16)
+	stl	$19, UC_SIGCTX+SC_REGS+19*8($16)
+	stl	$20, UC_SIGCTX+SC_REGS+20*8($16)
+	stl	$21, UC_SIGCTX+SC_REGS+21*8($16)
+	stl	$22, UC_SIGCTX+SC_REGS+22*8($16)
+	stl	$23, UC_SIGCTX+SC_REGS+23*8($16)
+	stl	$24, UC_SIGCTX+SC_REGS+24*8($16)
+	stl	$25, UC_SIGCTX+SC_REGS+25*8($16)
+	stl	$26, UC_SIGCTX+SC_REGS+26*8($16)
+	stl	$27, UC_SIGCTX+SC_REGS+27*8($16)
+	stl	$28, UC_SIGCTX+SC_REGS+28*8($16)
+	stl	$29, UC_SIGCTX+SC_REGS+29*8($16)
+	stl	$30, UC_SIGCTX+SC_REGS+30*8($16)
+	stl	$31, UC_SIGCTX+SC_REGS+31*8($16)
+#ifndef SW_64
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+1*8($16)
+        srlow   $f0, 0x40, $f0 
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+2*8($16)
+        srlow   $f0, 0x40, $f0 
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+3*8($16)
+        srlow   $f0, 0x40, $f0 
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+4*8($16)
+    
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+5*8($16)
+        srlow   $f1, 0x40, $f1 
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+6*8($16)
+        srlow   $f1, 0x40, $f1 
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+7*8($16)
+        srlow   $f1, 0x40, $f1 
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+8*8($16)
+    
+        fstd    $f2, UC_SIGCTX+SC_FPREGS+9*8($16)
+        srlow   $f2, 0x40, $f0 
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+10*8($16)
+        srlow   $f0, 0x40, $f0 
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+11*8($16)
+        srlow   $f0, 0x40, $f0 
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+12*8($16)
+    
+        fstd    $f3, UC_SIGCTX+SC_FPREGS+13*8($16)
+        srlow   $f3, 0x40, $f1 
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+14*8($16)
+        srlow   $f1, 0x40, $f1 
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+15*8($16)
+        srlow   $f1, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+16*8($16)
+
+        fstd    $f4, UC_SIGCTX+SC_FPREGS+17*8($16)
+        srlow   $f4, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+18*8($16)
+        srlow   $f0, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+19*8($16)
+        srlow   $f0, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+20*8($16) 
+
+        fstd    $f5, UC_SIGCTX+SC_FPREGS+21*8($16)
+        srlow   $f5, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+22*8($16)
+        srlow   $f1, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+23*8($16)
+        srlow   $f1, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+24*8($16)
+
+        fstd    $f6, UC_SIGCTX+SC_FPREGS+25*8($16)
+        srlow   $f6, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+26*8($16)
+        srlow   $f0, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+27*8($16)
+        srlow   $f0, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+28*8($16)
+
+        fstd    $f7, UC_SIGCTX+SC_FPREGS+29*8($16)
+        srlow   $f7, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+30*8($16)
+        srlow   $f1, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+31*8($16)
+        srlow   $f1, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+32*8($16)
+
+        fstd    $f8, UC_SIGCTX+SC_FPREGS+33*8($16)
+        srlow   $f8, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+34*8($16)
+        srlow   $f0, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+35*8($16)
+        srlow   $f0, 0x40, $f0
+        fstd    $f0, UC_SIGCTX+SC_FPREGS+36*8($16)
+
+        fstd    $f9, UC_SIGCTX+SC_FPREGS+37*8($16)
+        srlow   $f9, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+38*8($16)
+        srlow   $f1, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+39*8($16)
+        srlow   $f1, 0x40, $f1
+        fstd    $f1, UC_SIGCTX+SC_FPREGS+40*8($16)
+
+        fstd    $f10, UC_SIGCTX+SC_FPREGS+41*8($16)
+        srlow   $f10, 0x40, $f10
+        fstd    $f10, UC_SIGCTX+SC_FPREGS+42*8($16)
+        srlow   $f10, 0x40, $f10
+        fstd    $f10, UC_SIGCTX+SC_FPREGS+43*8($16)
+        srlow   $f10, 0x40, $f10
+        fstd    $f10, UC_SIGCTX+SC_FPREGS+44*8($16)
+
+        fstd    $f11, UC_SIGCTX+SC_FPREGS+45*8($16)
+        srlow   $f11, 0x40, $f11
+        fstd    $f11, UC_SIGCTX+SC_FPREGS+46*8($16)
+        srlow   $f11, 0x40, $f11
+        fstd    $f11, UC_SIGCTX+SC_FPREGS+47*8($16)
+        srlow   $f11, 0x40, $f11
+        fstd    $f11, UC_SIGCTX+SC_FPREGS+48*8($16)
+
+        fstd    $f12, UC_SIGCTX+SC_FPREGS+49*8($16)
+        srlow   $f12, 0x40, $f12
+        fstd    $f12, UC_SIGCTX+SC_FPREGS+50*8($16)
+        srlow   $f12, 0x40, $f12
+        fstd    $f12, UC_SIGCTX+SC_FPREGS+51*8($16)
+        srlow   $f12, 0x40, $f12
+        fstd    $f12, UC_SIGCTX+SC_FPREGS+52*8($16)
+
+        fstd    $f13, UC_SIGCTX+SC_FPREGS+53*8($16)
+        srlow   $f13, 0x40, $f13
+        fstd    $f13, UC_SIGCTX+SC_FPREGS+54*8($16)
+        srlow   $f13, 0x40, $f13
+        fstd    $f13, UC_SIGCTX+SC_FPREGS+55*8($16)
+        srlow   $f13, 0x40, $f13
+        fstd    $f13, UC_SIGCTX+SC_FPREGS+56*8($16)
+
+        fstd    $f14, UC_SIGCTX+SC_FPREGS+57*8($16)
+        srlow   $f14, 0x40, $f14
+        fstd    $f14, UC_SIGCTX+SC_FPREGS+58*8($16)
+        srlow   $f14, 0x40, $f14
+        fstd    $f14, UC_SIGCTX+SC_FPREGS+59*8($16)
+        srlow   $f14, 0x40, $f14
+        fstd    $f14, UC_SIGCTX+SC_FPREGS+60*8($16)
+
+        fstd    $f15, UC_SIGCTX+SC_FPREGS+61*8($16)
+        srlow   $f15, 0x40, $f15
+        fstd    $f15, UC_SIGCTX+SC_FPREGS+62*8($16)
+        srlow   $f15, 0x40, $f15
+        fstd    $f15, UC_SIGCTX+SC_FPREGS+63*8($16)
+        srlow   $f15, 0x40, $f15
+        fstd    $f15, UC_SIGCTX+SC_FPREGS+64*8($16)
+
+        fstd    $f16, UC_SIGCTX+SC_FPREGS+65*8($16)
+        srlow   $f16, 0x40, $f16
+        fstd    $f16, UC_SIGCTX+SC_FPREGS+66*8($16)
+        srlow   $f16, 0x40, $f16
+        fstd    $f16, UC_SIGCTX+SC_FPREGS+67*8($16)
+        srlow   $f16, 0x40, $f16
+        fstd    $f16, UC_SIGCTX+SC_FPREGS+68*8($16)
+
+        fstd    $f17, UC_SIGCTX+SC_FPREGS+69*8($16)
+        srlow   $f17, 0x40, $f17
+        fstd    $f17, UC_SIGCTX+SC_FPREGS+70*8($16)
+        srlow   $f17, 0x40, $f17
+        fstd    $f17, UC_SIGCTX+SC_FPREGS+71*8($16)
+        srlow   $f17, 0x40, $f17
+        fstd    $f17, UC_SIGCTX+SC_FPREGS+72*8($16)
+
+        fstd    $f18, UC_SIGCTX+SC_FPREGS+73*8($16)
+        srlow   $f18, 0x40, $f18
+        fstd    $f18, UC_SIGCTX+SC_FPREGS+74*8($16)
+        srlow   $f18, 0x40, $f18
+        fstd    $f18, UC_SIGCTX+SC_FPREGS+75*8($16)
+        srlow   $f18, 0x40, $f18
+        fstd    $f18, UC_SIGCTX+SC_FPREGS+76*8($16)
+
+        fstd    $f19, UC_SIGCTX+SC_FPREGS+77*8($16)
+        srlow   $f19, 0x40, $f19
+        fstd    $f19, UC_SIGCTX+SC_FPREGS+78*8($16)
+        srlow   $f19, 0x40, $f19
+        fstd    $f19, UC_SIGCTX+SC_FPREGS+79*8($16)
+        srlow   $f19, 0x40, $f19
+        fstd    $f19, UC_SIGCTX+SC_FPREGS+80*8($16)
+
+        fstd    $f20, UC_SIGCTX+SC_FPREGS+81*8($16)
+        srlow   $f20, 0x40, $f20
+        fstd    $f20, UC_SIGCTX+SC_FPREGS+82*8($16)
+        srlow   $f20, 0x40, $f20
+        fstd    $f20, UC_SIGCTX+SC_FPREGS+83*8($16)
+        srlow   $f20, 0x40, $f20
+        fstd    $f20, UC_SIGCTX+SC_FPREGS+84*8($16)
+
+        fstd    $f21, UC_SIGCTX+SC_FPREGS+85*8($16)
+        srlow   $f21, 0x40, $f21
+        fstd    $f21, UC_SIGCTX+SC_FPREGS+86*8($16)
+        srlow   $f21, 0x40, $f21
+        fstd    $f21, UC_SIGCTX+SC_FPREGS+87*8($16)
+        srlow   $f21, 0x40, $f21
+        fstd    $f21, UC_SIGCTX+SC_FPREGS+88*8($16)
+
+        fstd    $f22, UC_SIGCTX+SC_FPREGS+89*8($16)
+        srlow   $f22, 0x40, $f22
+        fstd    $f22, UC_SIGCTX+SC_FPREGS+90*8($16)
+        srlow   $f22, 0x40, $f22
+        fstd    $f22, UC_SIGCTX+SC_FPREGS+91*8($16)
+        srlow   $f22, 0x40, $f22
+        fstd    $f22, UC_SIGCTX+SC_FPREGS+92*8($16)
+
+        fstd    $f23, UC_SIGCTX+SC_FPREGS+93*8($16)
+        srlow   $f23, 0x40, $f23
+        fstd    $f23, UC_SIGCTX+SC_FPREGS+94*8($16)
+        srlow   $f23, 0x40, $f23
+        fstd    $f23, UC_SIGCTX+SC_FPREGS+95*8($16)
+        srlow   $f23, 0x40, $f23
+        fstd    $f23, UC_SIGCTX+SC_FPREGS+96*8($16)
+
+        fstd    $f24, UC_SIGCTX+SC_FPREGS+97*8($16)
+        srlow   $f24, 0x40, $f24
+        fstd    $f24, UC_SIGCTX+SC_FPREGS+98*8($16)
+        srlow   $f24, 0x40, $f24
+        fstd    $f24, UC_SIGCTX+SC_FPREGS+99*8($16)
+        srlow   $f24, 0x40, $f24
+        fstd    $f24, UC_SIGCTX+SC_FPREGS+100*8($16)
+
+        fstd    $f25, UC_SIGCTX+SC_FPREGS+101*8($16)
+        srlow   $f25, 0x40, $f25
+        fstd    $f25, UC_SIGCTX+SC_FPREGS+102*8($16)
+        srlow   $f25, 0x40, $f25
+        fstd    $f25, UC_SIGCTX+SC_FPREGS+103*8($16)
+        srlow   $f25, 0x40, $f25
+        fstd    $f25, UC_SIGCTX+SC_FPREGS+104*8($16)
+
+        fstd    $f26, UC_SIGCTX+SC_FPREGS+105*8($16)
+        srlow   $f26, 0x40, $f26
+        fstd    $f26, UC_SIGCTX+SC_FPREGS+106*8($16)
+        srlow   $f26, 0x40, $f26
+        fstd    $f26, UC_SIGCTX+SC_FPREGS+107*8($16)
+        srlow   $f26, 0x40, $f26
+        fstd    $f26, UC_SIGCTX+SC_FPREGS+108*8($16)
+
+        fstd    $f27, UC_SIGCTX+SC_FPREGS+109*8($16)
+        srlow   $f27, 0x40, $f27
+        fstd    $f27, UC_SIGCTX+SC_FPREGS+110*8($16)
+        srlow   $f27, 0x40, $f27
+        fstd    $f27, UC_SIGCTX+SC_FPREGS+111*8($16)
+        srlow   $f27, 0x40, $f27
+        fstd    $f27, UC_SIGCTX+SC_FPREGS+112*8($16)
+
+        fstd    $f28, UC_SIGCTX+SC_FPREGS+113*8($16)
+        srlow   $f28, 0x40, $f28
+        fstd    $f28, UC_SIGCTX+SC_FPREGS+114*8($16)
+        srlow   $f28, 0x40, $f28
+        fstd    $f28, UC_SIGCTX+SC_FPREGS+115*8($16)
+        srlow   $f28, 0x40, $f28
+        fstd    $f28, UC_SIGCTX+SC_FPREGS+116*8($16)
+
+        fstd    $f29, UC_SIGCTX+SC_FPREGS+117*8($16)
+        srlow   $f29, 0x40, $f29
+        fstd    $f29, UC_SIGCTX+SC_FPREGS+118*8($16)
+        srlow   $f29, 0x40, $f29
+        fstd    $f29, UC_SIGCTX+SC_FPREGS+119*8($16)
+        srlow   $f29, 0x40, $f29
+        fstd    $f29, UC_SIGCTX+SC_FPREGS+120*8($16)
+
+        fstd    $f30, UC_SIGCTX+SC_FPREGS+121*8($16)
+        srlow   $f30, 0x40, $f30
+        fstd    $f30, UC_SIGCTX+SC_FPREGS+122*8($16)
+        srlow   $f30, 0x40, $f30
+        fstd    $f30, UC_SIGCTX+SC_FPREGS+123*8($16)
+        srlow   $f30, 0x40, $f30
+        fstd    $f30, UC_SIGCTX+SC_FPREGS+124*8($16)
+#else
+	fstd	$f0, UC_SIGCTX+SC_FPREGS+0*8($16)
+	fstd	$f1, UC_SIGCTX+SC_FPREGS+1*8($16)
+	fstd	$f2, UC_SIGCTX+SC_FPREGS+2*8($16)
+	fstd	$f3, UC_SIGCTX+SC_FPREGS+3*8($16)
+	fstd	$f4, UC_SIGCTX+SC_FPREGS+4*8($16)
+	fstd	$f5, UC_SIGCTX+SC_FPREGS+5*8($16)
+	fstd	$f6, UC_SIGCTX+SC_FPREGS+6*8($16)
+	fstd	$f7, UC_SIGCTX+SC_FPREGS+7*8($16)
+	fstd	$f8, UC_SIGCTX+SC_FPREGS+8*8($16)
+	fstd	$f9, UC_SIGCTX+SC_FPREGS+9*8($16)
+	fstd	$f10, UC_SIGCTX+SC_FPREGS+10*8($16)
+	fstd	$f11, UC_SIGCTX+SC_FPREGS+11*8($16)
+	fstd	$f12, UC_SIGCTX+SC_FPREGS+12*8($16)
+	fstd	$f13, UC_SIGCTX+SC_FPREGS+13*8($16)
+	fstd	$f14, UC_SIGCTX+SC_FPREGS+14*8($16)
+	fstd	$f15, UC_SIGCTX+SC_FPREGS+15*8($16)
+	fstd	$f16, UC_SIGCTX+SC_FPREGS+16*8($16)
+	fstd	$f17, UC_SIGCTX+SC_FPREGS+17*8($16)
+	fstd	$f18, UC_SIGCTX+SC_FPREGS+18*8($16)
+	fstd	$f19, UC_SIGCTX+SC_FPREGS+19*8($16)
+	fstd	$f20, UC_SIGCTX+SC_FPREGS+20*8($16)
+	fstd	$f21, UC_SIGCTX+SC_FPREGS+21*8($16)
+	fstd	$f22, UC_SIGCTX+SC_FPREGS+22*8($16)
+	fstd	$f23, UC_SIGCTX+SC_FPREGS+23*8($16)
+	fstd	$f24, UC_SIGCTX+SC_FPREGS+24*8($16)
+	fstd	$f25, UC_SIGCTX+SC_FPREGS+25*8($16)
+	fstd	$f26, UC_SIGCTX+SC_FPREGS+26*8($16)
+	fstd	$f27, UC_SIGCTX+SC_FPREGS+27*8($16)
+	fstd	$f28, UC_SIGCTX+SC_FPREGS+28*8($16)
+	fstd	$f29, UC_SIGCTX+SC_FPREGS+29*8($16)
+	fstd	$f30, UC_SIGCTX+SC_FPREGS+30*8($16)
+	fstd	$f31, UC_SIGCTX+SC_FPREGS+31*8($16)
+#endif
+	rfpcr $f0
+	ldi	$1, 8
+	fstd	$f0, UC_SIGCTX+SC_FPCR($16)
+
+	/* The return address of getcontext is the restart pc.  */
+	stl	$26, UC_SIGCTX+SC_PC($16)
+
+	/* Userlevel always has a processor status word of 8.  */
+	stl	$1, UC_SIGCTX+SC_PS($16)
+
+	/* Save registers around the syscall.  We preserve $17
+	   for the benefit of swapcontext.  */
+	subl	$30, 4*8, $30
+	cfi_adjust_cfa_offset(4*8)
+	stl	$0, 0($30)
+	cfi_rel_offset(64, 0)
+	stl	$16, 8($30)
+	stl	$17, 16($30)
+
+	/* Save the current signal mask.  Whee, there are three
+	   copies of this in the sw_64 ucontext_t.  */
+/* osf_sigprocmask change to rt_sigprocmask */
+/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+        ldi     $19, _NSIG8       
+	ldi	$18, UC_SIGMASK($16)
+	ldi	$17, 0
+	ldi	$16, SIG_BLOCK
+	
+        ldi	$0, __NR_rt_sigprocmask
+	sys_call 0x83
+	
+        ldl	$16, 8($30)
+	ldl	$17, 16($30)
+	
+        stl	$18, UC_OSF_SIGMASK($16)
+	stl	$18, UC_SIGCTX+SC_MASK($16)
+
+	stl	$31, UC_SIGMASK + 1*8($16)
+	stl	$31, UC_SIGMASK + 2*8($16)
+	stl	$31, UC_SIGMASK + 3*8($16)
+	stl	$31, UC_SIGMASK + 4*8($16)
+	stl	$31, UC_SIGMASK + 5*8($16)
+	stl	$31, UC_SIGMASK + 6*8($16)
+	stl	$31, UC_SIGMASK + 7*8($16)
+	stl	$31, UC_SIGMASK + 8*8($16)
+	stl	$31, UC_SIGMASK + 9*8($16)
+	stl	$31, UC_SIGMASK +10*8($16)
+	stl	$31, UC_SIGMASK +11*8($16)
+	stl	$31, UC_SIGMASK +12*8($16)
+	stl	$31, UC_SIGMASK +13*8($16)
+	stl	$31, UC_SIGMASK +14*8($16)
+	stl	$31, UC_SIGMASK +15*8($16)
+
+	ldl	$0, 0($30)
+	addl	$30, 4*8, $30
+	cfi_register (64, 0)
+	cfi_adjust_cfa_offset(-4*8)
+	ret	$31, ($0), 1
+
+	cfi_endproc
+	.size	__getcontext_x, .-__getcontext_x
+	.type	__getcontext_x, @function
diff --git a/sysdeps/unix/sysv/linux/sw_64/getdents.c b/sysdeps/unix/sysv/linux/sw_64/getdents.c
new file mode 100644
index 00000000..5885ff7d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/getdents.c
@@ -0,0 +1,13 @@
+/* Although Sw_64 defines _DIRENT_MATCHES_DIRENT64, 'struct dirent' and
+   'struct dirent64' have slight different internal layout with d_ino
+   being a __ino_t on non-LFS version with an extra __pad field which should
+   be zeroed.  */
+
+#include <dirent.h>
+#undef _DIRENT_MATCHES_DIRENT64
+#define _DIRENT_MATCHES_DIRENT64 0
+#ifdef SW_64
+#define DIRENT_SET_DP_INO(dp, value) \
+  do { (dp)->d_ino = (value); (dp)->__pad = 0; } while (0)
+#endif
+#include <sysdeps/unix/sysv/linux/getdents.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/getdents64.c b/sysdeps/unix/sysv/linux/sw_64/getdents64.c
new file mode 100644
index 00000000..f24cc638
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/getdents64.c
@@ -0,0 +1,10 @@
+/* Although Sw_64 defines _DIRENT_MATCHES_DIRENT64, 'struct dirent' and
+   'struct dirent64' have slight different internal layout with d_ino
+   being a __ino_t on non-LFS version with an extra __pad field which should
+   be zeroed.  */
+
+#include <dirent.h>
+/* It suppresses the __getdents64 to __getdents alias.  */
+#undef _DIRENT_MATCHES_DIRENT64
+#define _DIRENT_MATCHES_DIRENT64 0
+#include <sysdeps/unix/sysv/linux/getdents64.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/getegid.S b/sysdeps/unix/sysv/linux/sw_64/getegid.S
new file mode 100644
index 00000000..ab631962
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/getegid.S
@@ -0,0 +1,26 @@
+/* Copyright (C) 1991-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+
+PSEUDO (__getegid, getxgid, 0)
+	MOVE (r1, r0)
+	ret
+PSEUDO_END (__getegid)
+
+weak_alias (__getegid, getegid)
diff --git a/sysdeps/unix/sysv/linux/sw_64/geteuid.S b/sysdeps/unix/sysv/linux/sw_64/geteuid.S
new file mode 100644
index 00000000..c731e78a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/geteuid.S
@@ -0,0 +1,26 @@
+/* Copyright (C) 1991-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+
+PSEUDO (__geteuid, getxuid, 0)
+	MOVE (r1, r0)
+	ret
+PSEUDO_END (__geteuid)
+
+weak_alias (__geteuid, geteuid)
diff --git a/sysdeps/unix/sysv/linux/sw_64/gethostname.c b/sysdeps/unix/sysv/linux/sw_64/gethostname.c
new file mode 100644
index 00000000..850b8bec
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/gethostname.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2001-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+int
+__gethostname (char *name, size_t len)
+{
+  int result;
+
+  result = INLINE_SYSCALL (gethostname, 2, name, len);
+
+  if (result == 0
+      /* See whether the string is terminated.  If not we will return
+	 an error.  */
+      && memchr (name, '\0', len) == NULL)
+    {
+      __set_errno (EOVERFLOW);
+      result = -1;
+    }
+
+  return result;
+}
+
+weak_alias (__gethostname, gethostname)
diff --git a/sysdeps/unix/sysv/linux/sw_64/getppid.S b/sysdeps/unix/sysv/linux/sw_64/getppid.S
new file mode 100644
index 00000000..b47e8ab9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/getppid.S
@@ -0,0 +1,26 @@
+/* Copyright (C) 1991-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+
+PSEUDO (__getppid, getxpid, 0)
+	MOVE (r1, r0)
+	ret
+PSEUDO_END (__getppid)
+
+weak_alias (__getppid, getppid)
diff --git a/sysdeps/unix/sysv/linux/sw_64/getrlimit64.c b/sysdeps/unix/sysv/linux/sw_64/getrlimit64.c
new file mode 100644
index 00000000..e5cc9d9d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/getrlimit64.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 2018-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define USE_VERSIONED_RLIMIT
+#include <sysdeps/unix/sysv/linux/getrlimit64.c>
+versioned_symbol (libc, __getrlimit, getrlimit, GLIBC_2_27);
+versioned_symbol (libc, __getrlimit64, getrlimit64, GLIBC_2_27);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_27)
+/* RLIM64_INFINITY was supposed to be a glibc convention rather than
+   anything seen by the kernel, but it ended being passed to the kernel
+   through the prlimit64 syscall.  Given that a lot of binaries with
+   the wrong constant value are in the wild, provide a wrapper function
+   fixing the value after the syscall.  */
+# define OLD_RLIM64_INFINITY           0x7fffffffffffffffULL
+
+int
+attribute_compat_text_section
+__old_getrlimit64 (enum __rlimit_resource resource,
+		   struct rlimit64 *rlimits)
+{
+  struct rlimit64 krlimits;
+
+  if (__getrlimit64 (resource, &krlimits) < 0)
+    return -1;
+
+  if (krlimits.rlim_cur == RLIM64_INFINITY)
+    rlimits->rlim_cur = OLD_RLIM64_INFINITY;
+  else
+    rlimits->rlim_cur = krlimits.rlim_cur;
+  if (krlimits.rlim_max == RLIM64_INFINITY)
+    rlimits->rlim_max = OLD_RLIM64_INFINITY;
+  else
+    rlimits->rlim_max = krlimits.rlim_max;
+
+  return 0;
+}
+
+strong_alias (__old_getrlimit64, __old_getrlimit)
+compat_symbol (libc, __old_getrlimit, getrlimit, GLIBC_2_0);
+compat_symbol (libc, __old_getrlimit64, getrlimit64, GLIBC_2_1);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/gettimeofday.c b/sysdeps/unix/sysv/linux/sw_64/gettimeofday.c
new file mode 100644
index 00000000..05dd6eed
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/gettimeofday.c
@@ -0,0 +1,26 @@
+/* gettimeofday -- Get the current time of day.  Linux/Sw_64/tv64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* We can use the generic implementation, but we have to override its
+   default symbol version.  */
+#define SET_VERSION
+#include <time/gettimeofday.c>
+
+weak_alias (___gettimeofday, __wgettimeofday);
+default_symbol_version (___gettimeofday, __gettimeofday, GLIBC_2.1);
+default_symbol_version (__wgettimeofday,   gettimeofday, GLIBC_2.1);
diff --git a/sysdeps/unix/sysv/linux/sw_64/glob-lstat-compat.c b/sysdeps/unix/sysv/linux/sw_64/glob-lstat-compat.c
new file mode 100644
index 00000000..a76471d4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/glob-lstat-compat.c
@@ -0,0 +1,2 @@
+#define GLOB_LSTAT_VERSION GLIBC_2_1
+#include <sysdeps/unix/sysv/linux/glob-lstat-compat.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/globfree.c b/sysdeps/unix/sysv/linux/sw_64/globfree.c
new file mode 100644
index 00000000..aa063b14
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/globfree.c
@@ -0,0 +1,37 @@
+/* Compat globfree.  Linux/sw_64 version.
+   Copyright (C) 2017-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define globfree64 __no_globfree64_decl
+#include <sys/types.h>
+#include <glob.h>
+#include <shlib-compat.h>
+
+#define globfree(pglob) \
+  __new_globfree (pglob)
+
+extern void __new_globfree (glob_t *__pglob);
+
+#include <posix/globfree.c>
+
+#undef globfree64
+
+versioned_symbol (libc, __new_globfree, globfree, GLIBC_2_1);
+libc_hidden_ver (__new_globfree, globfree)
+
+weak_alias (__new_globfree, globfree64)
+libc_hidden_ver (__new_globfree, globfree64)
diff --git a/sysdeps/unix/sysv/linux/sw_64/ieee_get_fp_control.S b/sysdeps/unix/sysv/linux/sw_64/ieee_get_fp_control.S
new file mode 100644
index 00000000..a5250baf
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/ieee_get_fp_control.S
@@ -0,0 +1,50 @@
+/* Copyright (C) 1993-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Mosberger <davidm@azstarnet.com>, 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include "kernel_sysinfo.h"
+
+
+	.text
+
+ENTRY(__ieee_get_fp_control)
+	cfi_startproc
+	PSEUDO_PROLOGUE
+
+	ldi	sp, -16(sp)
+	cfi_adjust_cfa_offset(16)
+
+	mov	sp, a1
+	ldi	a0, GSI_IEEE_FP_CONTROL
+	ldi	v0, __NR_getsysinfo
+	sys_call HMC_callsys
+
+	ldl	t0, 0(sp)
+	ldi	sp, 16(sp)
+	cfi_adjust_cfa_offset(-16)
+
+	bne	a3, SYSCALL_ERROR_LABEL
+
+	mov	t0, v0
+	ret
+
+PSEUDO_END(__ieee_get_fp_control)
+	cfi_endproc
+
+libc_hidden_def(__ieee_get_fp_control)
+weak_alias (__ieee_get_fp_control, ieee_get_fp_control)
diff --git a/sysdeps/unix/sysv/linux/sw_64/ieee_set_fp_control.S b/sysdeps/unix/sysv/linux/sw_64/ieee_set_fp_control.S
new file mode 100644
index 00000000..e73c4fe4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/ieee_set_fp_control.S
@@ -0,0 +1,46 @@
+/* Copyright (C) 1993-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Mosberger <davidm@azstarnet.com>, 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include "kernel_sysinfo.h"
+
+
+ENTRY(__ieee_set_fp_control)
+	cfi_startproc
+	PSEUDO_PROLOGUE
+
+	ldi	sp, -16(sp)
+	cfi_adjust_cfa_offset(16)
+
+	ldi	v0, __NR_setsysinfo
+	stl	a0, 0(sp)
+	mov	sp, a1
+	ldi	a0, SSI_IEEE_FP_CONTROL
+	sys_call HMC_callsys
+
+	ldi	sp, 16(sp)
+	cfi_adjust_cfa_offset(-16)
+
+	bne	a3, SYSCALL_ERROR_LABEL
+	ret
+
+PSEUDO_END(__ieee_set_fp_control)
+	cfi_endproc
+
+libc_hidden_def(__ieee_set_fp_control)
+weak_alias (__ieee_set_fp_control, ieee_set_fp_control)
diff --git a/sysdeps/unix/sysv/linux/sw_64/ioperm.c b/sysdeps/unix/sysv/linux/sw_64/ioperm.c
new file mode 100644
index 00000000..83673229
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/ioperm.c
@@ -0,0 +1,877 @@
+/* Copyright (C) 1992-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Mosberger.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* I/O access is restricted to ISA port space (ports 0..65535).
+   Modern devices hopefully are sane enough not to put any performance
+   critical registers in i/o space.
+
+   On the first call to ioperm, the entire (E)ISA port space is mapped
+   into the virtual address space at address io.base.  mprotect calls
+   are then used to enable/disable access to ports.  Per page, there
+   are PAGE_SIZE>>IO_SHIFT I/O ports (e.g., 256 ports on a Low Cost Sw_64
+   based system using 8KB pages).
+
+   Keep in mind that this code should be able to run in a 32bit address
+   space.  It is therefore unreasonable to expect mmap'ing the entire
+   sparse address space would work (e.g., the Low Cost Sw_64 chip has an
+   I/O address space that's 512MB large!).  */
+
+/* Make sure the ldbu/stb asms below are not expaneded to macros.  */
+#ifndef __sw_64_bwx__
+asm(".arch sw6f");
+#endif
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/io.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#define PATH_SW_64_SYSTYPE	"/etc/sw_64_systype"
+#define PATH_CPUINFO		"/proc/cpuinfo"
+
+#define MAX_PORT	0x10000
+#define vip		volatile int *
+#define vuip		volatile unsigned int *
+#define vusp		volatile unsigned short *
+#define vucp		volatile unsigned char *
+
+#define JENSEN_IO_BASE		(0x300000000UL)
+#define JENSEN_SPARSE_MEM	(0x200000000UL)
+
+/* With respect to the I/O architecture, APECS and LCA are identical,
+   so the following defines apply to LCA as well.  */
+#define APECS_IO_BASE		(0x1c0000000UL)
+#define APECS_SPARSE_MEM	(0x200000000UL)
+#define APECS_DENSE_MEM		(0x300000000UL)
+
+/* The same holds for CIA and PYXIS, except for PYXIS we prefer BWX.  */
+#define CIA_IO_BASE		(0x8580000000UL)
+#define CIA_SPARSE_MEM		(0x8000000000UL)
+#define CIA_DENSE_MEM		(0x8600000000UL)
+
+#define PYXIS_IO_BASE		(0x8900000000UL)
+#define PYXIS_DENSE_MEM		(0x8800000000UL)
+
+/* SABLE is EV4, GAMMA is EV5 */
+#define T2_IO_BASE		(0x3a0000000UL)
+#define T2_SPARSE_MEM		(0x200000000UL)
+#define T2_DENSE_MEM		(0x3c0000000UL)
+
+#define GAMMA_IO_BASE		(0x83a0000000UL)
+#define GAMMA_SPARSE_MEM	(0x8200000000UL)
+#define GAMMA_DENSE_MEM		(0x83c0000000UL)
+
+/* NOTE: these are hardwired to PCI bus 0 addresses!!! */
+#define MCPCIA_IO_BASE		(0xf980000000UL)
+#define MCPCIA_SPARSE_MEM	(0xf800000000UL)
+#define MCPCIA_DENSE_MEM	(0xf900000000UL)
+
+/* Tsunami and Irongate use the same offsets, at least for hose 0.  */
+#define TSUNAMI_IO_BASE		(0x801fc000000UL)
+#define TSUNAMI_DENSE_MEM	(0x80000000000UL)
+
+/* Polaris has SPARSE space, but we prefer to use only DENSE
+   because of some idiosyncracies in actually using SPARSE.  */
+#define POLARIS_IO_BASE		(0xf9fc000000UL)
+#define POLARIS_DENSE_MEM	(0xf900000000UL)
+
+typedef enum {
+  IOSYS_UNKNOWN, IOSYS_JENSEN, IOSYS_APECS, IOSYS_CIA, IOSYS_PYXIS, IOSYS_T2,
+  IOSYS_TSUNAMI, IOSYS_MCPCIA, IOSYS_GAMMA, IOSYS_POLARIS,
+  IOSYS_CPUDEP, IOSYS_PCIDEP
+} iosys_t;
+
+typedef enum {
+  IOSWIZZLE_JENSEN, IOSWIZZLE_SPARSE, IOSWIZZLE_DENSE
+} ioswizzle_t;
+
+static struct io_system {
+  unsigned long	int bus_memory_base;
+  unsigned long	int sparse_bus_mem_base;
+  unsigned long	int bus_io_base;
+} io_system[] = { /* NOTE! must match iosys_t enumeration */
+/* UNKNOWN */	{0, 0, 0},
+/* JENSEN */	{0, JENSEN_SPARSE_MEM, JENSEN_IO_BASE},
+/* APECS */	{APECS_DENSE_MEM, APECS_SPARSE_MEM, APECS_IO_BASE},
+/* CIA */	{CIA_DENSE_MEM, CIA_SPARSE_MEM, CIA_IO_BASE},
+/* PYXIS */	{PYXIS_DENSE_MEM, 0, PYXIS_IO_BASE},
+/* T2 */	{T2_DENSE_MEM, T2_SPARSE_MEM, T2_IO_BASE},
+/* TSUNAMI */	{TSUNAMI_DENSE_MEM, 0, TSUNAMI_IO_BASE},
+/* MCPCIA */	{MCPCIA_DENSE_MEM, MCPCIA_SPARSE_MEM, MCPCIA_IO_BASE},
+/* GAMMA */	{GAMMA_DENSE_MEM, GAMMA_SPARSE_MEM, GAMMA_IO_BASE},
+/* POLARIS */	{POLARIS_DENSE_MEM, 0, POLARIS_IO_BASE},
+/* CPUDEP */	{0, 0, 0}, /* for platforms dependent on CPU type */
+/* PCIDEP */	{0, 0, 0}, /* for platforms dependent on core logic */
+};
+
+static struct platform {
+  const char	   *name;
+  iosys_t	    io_sys;
+} platform[] = {
+  {"Alcor",	IOSYS_CIA},
+  {"Avanti",	IOSYS_APECS},
+  {"Cabriolet",	IOSYS_APECS},
+  {"EB164",	IOSYS_PCIDEP},
+  {"EB64+",	IOSYS_APECS},
+  {"EB66",	IOSYS_APECS},
+  {"EB66P",	IOSYS_APECS},
+  {"Jensen",	IOSYS_JENSEN},
+  {"Miata",	IOSYS_PYXIS},
+  {"Mikasa",	IOSYS_CPUDEP},
+  {"Nautilus",	IOSYS_TSUNAMI},
+  {"Noname",	IOSYS_APECS},
+  {"Noritake",	IOSYS_CPUDEP},
+  {"Rawhide",	IOSYS_MCPCIA},
+  {"Ruffian",	IOSYS_PYXIS},
+  {"Sable",	IOSYS_CPUDEP},
+  {"Takara",	IOSYS_CIA},
+  {"Tsunami",	IOSYS_TSUNAMI},
+  {"XL",	IOSYS_APECS},
+};
+
+struct ioswtch {
+  void		(*sethae)(unsigned long int addr);
+  void		(*outb)(unsigned char b, unsigned long int port);
+  void		(*outw)(unsigned short b, unsigned long int port);
+  void		(*outl)(unsigned int b, unsigned long int port);
+  unsigned int	(*inb)(unsigned long int port);
+  unsigned int	(*inw)(unsigned long int port);
+  unsigned int	(*inl)(unsigned long int port);
+};
+
+static struct {
+  unsigned long int hae_cache;
+  unsigned long int	base;
+  struct ioswtch *	swp;
+  unsigned long int	bus_memory_base;
+  unsigned long int	sparse_bus_memory_base;
+  unsigned long int	io_base;
+  ioswizzle_t		swiz;
+} io;
+
+static inline void
+stb_mb(unsigned char val, unsigned long addr)
+{
+  __asm__("stb %1,%0; memb" : "=m"(*(vucp)addr) : "r"(val));
+}
+
+static inline void
+stw_mb(unsigned short val, unsigned long addr)
+{
+  __asm__("sth %1,%0; memb" : "=m"(*(vusp)addr) : "r"(val));
+}
+
+static inline void
+stl_mb(unsigned int val, unsigned long addr)
+{
+  __asm__("stw %1,%0; memb" : "=m"(*(vip)addr) : "r"(val));
+}
+
+/* No need to examine error -- sethae never fails.  */
+static inline void
+__sethae(unsigned long value)
+{
+  fprintf(stderr, " __sethae already abandoned\n");
+  __builtin_unreachable();
+}
+
+extern long __pciconfig_iobase(enum __pciconfig_iobase_which __which,
+			       unsigned long int __bus,
+			       unsigned long int __dfn);
+
+static inline unsigned long int
+port_to_cpu_addr (unsigned long int port, ioswizzle_t ioswiz, int size)
+{
+  if (ioswiz == IOSWIZZLE_SPARSE)
+    return io.base + (port << 5) + ((size - 1) << 3);
+  else if (ioswiz == IOSWIZZLE_DENSE)
+    return port + io.base;
+  else
+    return io.base + (port << 7) + ((size - 1) << 5);
+}
+
+static inline __attribute__((always_inline)) void
+inline_sethae (unsigned long int addr, ioswizzle_t ioswiz)
+{
+  if (ioswiz == IOSWIZZLE_SPARSE)
+    {
+      unsigned long int msb;
+
+      /* no need to set hae if msb is 0: */
+      msb = addr & 0xf8000000;
+      if (msb && msb != io.hae_cache)
+	{
+	  io.hae_cache = msb;
+	  __sethae (msb);
+	}
+    }
+  else if (ioswiz == IOSWIZZLE_JENSEN)
+    {
+      /* HAE on the Jensen is bits 31:25 shifted right.  */
+      addr >>= 25;
+      if (addr != io.hae_cache)
+	{
+	  io.hae_cache = addr;
+	  __sethae (addr);
+	}
+    }
+}
+
+static inline void
+inline_outb (unsigned char b, unsigned long int port, ioswizzle_t ioswiz)
+{
+  unsigned int w;
+  unsigned long int addr = port_to_cpu_addr (port, ioswiz, 1);
+
+  asm ("ins0b %2,%1,%0" : "=r" (w) : "ri" (port & 0x3), "r" (b));
+  stl_mb(w, addr);
+}
+
+
+static inline void
+inline_outw (unsigned short int b, unsigned long int port, ioswizzle_t ioswiz)
+{
+  unsigned long w;
+  unsigned long int addr = port_to_cpu_addr (port, ioswiz, 2);
+
+  asm ("ins1b %2,%1,%0" : "=r" (w) : "ri" (port & 0x3), "r" (b));
+  stl_mb(w, addr);
+}
+
+
+static inline void
+inline_outl (unsigned int b, unsigned long int port, ioswizzle_t ioswiz)
+{
+  unsigned long int addr = port_to_cpu_addr (port, ioswiz, 4);
+
+  stl_mb(b, addr);
+}
+
+
+static inline unsigned int
+inline_inb (unsigned long int port, ioswizzle_t ioswiz)
+{
+  unsigned long int addr = port_to_cpu_addr (port, ioswiz, 1);
+  int result;
+
+  result = *(vip) addr;
+  result >>= (port & 3) * 8;
+  return 0xffUL & result;
+}
+
+
+static inline unsigned int
+inline_inw (unsigned long int port, ioswizzle_t ioswiz)
+{
+  unsigned long int addr = port_to_cpu_addr (port, ioswiz, 2);
+  int result;
+
+  result = *(vip) addr;
+  result >>= (port & 3) * 8;
+  return 0xffffUL & result;
+}
+
+
+static inline unsigned int
+inline_inl (unsigned long int port, ioswizzle_t ioswiz)
+{
+  unsigned long int addr = port_to_cpu_addr (port, ioswiz, 4);
+
+  return *(vuip) addr;
+}
+
+/*
+ * Now define the inline functions for CPUs supporting byte/word insns,
+ * and whose core logic supports I/O space accesses utilizing them.
+ *
+ * These routines could be used by MIATA, for example, because it has
+ * and EV56 plus PYXIS, but it currently uses SPARSE anyway. This is
+ * also true of RX164 which used POLARIS, but we will choose to use
+ * these routines in that case instead of SPARSE.
+ *
+ * These routines are necessary for TSUNAMI/TYPHOON based platforms,
+ * which will have (at least) EV6.
+ */
+
+static inline unsigned long int
+dense_port_to_cpu_addr (unsigned long int port)
+{
+  return port + io.base;
+}
+
+static inline void
+inline_bwx_outb (unsigned char b, unsigned long int port)
+{
+  unsigned long int addr = dense_port_to_cpu_addr (port);
+  stb_mb (b, addr);
+}
+
+static inline void
+inline_bwx_outw (unsigned short int b, unsigned long int port)
+{
+  unsigned long int addr = dense_port_to_cpu_addr (port);
+  stw_mb (b, addr);
+}
+
+static inline void
+inline_bwx_outl (unsigned int b, unsigned long int port)
+{
+  unsigned long int addr = dense_port_to_cpu_addr (port);
+  stl_mb (b, addr);
+}
+
+static inline unsigned int
+inline_bwx_inb (unsigned long int port)
+{
+  unsigned long int addr = dense_port_to_cpu_addr (port);
+  unsigned char r;
+
+  __asm__ ("ldbu %0,%1" : "=r"(r) : "m"(*(vucp)addr));
+  return r;
+}
+
+static inline unsigned int
+inline_bwx_inw (unsigned long int port)
+{
+  unsigned long int addr = dense_port_to_cpu_addr (port);
+  unsigned short r;
+
+  __asm__ ("ldhu %0,%1" : "=r"(r) : "m"(*(vusp)addr));
+  return r;
+}
+
+static inline unsigned int
+inline_bwx_inl (unsigned long int port)
+{
+  unsigned long int addr = dense_port_to_cpu_addr (port);
+
+  return *(vuip) addr;
+}
+
+/* macros to define routines with appropriate names and functions */
+
+/* these do either SPARSE or JENSEN swizzle */
+
+#define DCL_SETHAE(name, ioswiz)                        \
+static void                                             \
+name##_sethae (unsigned long int addr)                  \
+{                                                       \
+  inline_sethae (addr, IOSWIZZLE_##ioswiz);             \
+}
+
+#define DCL_OUT(name, func, type, ioswiz)		\
+static void						\
+name##_##func (unsigned type b, unsigned long int addr)	\
+{							\
+  inline_##func (b, addr, IOSWIZZLE_##ioswiz);		\
+}
+
+#define DCL_IN(name, func, ioswiz)			\
+static unsigned int					\
+name##_##func (unsigned long int addr)			\
+{							\
+  return inline_##func (addr, IOSWIZZLE_##ioswiz);	\
+}
+
+/* these do DENSE, so no swizzle is needed */
+
+#define DCL_OUT_BWX(name, func, type)			\
+static void						\
+name##_##func (unsigned type b, unsigned long int addr)	\
+{							\
+  inline_bwx_##func (b, addr);				\
+}
+
+#define DCL_IN_BWX(name, func)				\
+static unsigned int					\
+name##_##func (unsigned long int addr)			\
+{							\
+  return inline_bwx_##func (addr);			\
+}
+
+/* now declare/define the necessary routines */
+
+DCL_SETHAE(jensen, JENSEN)
+DCL_OUT(jensen, outb, char,  JENSEN)
+DCL_OUT(jensen, outw, short int, JENSEN)
+DCL_OUT(jensen, outl, int,   JENSEN)
+DCL_IN(jensen, inb, JENSEN)
+DCL_IN(jensen, inw, JENSEN)
+DCL_IN(jensen, inl, JENSEN)
+
+DCL_SETHAE(sparse, SPARSE)
+DCL_OUT(sparse, outb, char,  SPARSE)
+DCL_OUT(sparse, outw, short int, SPARSE)
+DCL_OUT(sparse, outl, int,   SPARSE)
+DCL_IN(sparse, inb, SPARSE)
+DCL_IN(sparse, inw, SPARSE)
+DCL_IN(sparse, inl, SPARSE)
+
+DCL_SETHAE(dense, DENSE)
+DCL_OUT_BWX(dense, outb, char)
+DCL_OUT_BWX(dense, outw, short int)
+DCL_OUT_BWX(dense, outl, int)
+DCL_IN_BWX(dense, inb)
+DCL_IN_BWX(dense, inw)
+DCL_IN_BWX(dense, inl)
+
+/* define the "swizzle" switch */
+static struct ioswtch ioswtch[] = {
+  {
+    jensen_sethae,
+    jensen_outb, jensen_outw, jensen_outl,
+    jensen_inb, jensen_inw, jensen_inl
+  },
+  {
+    sparse_sethae,
+    sparse_outb, sparse_outw, sparse_outl,
+    sparse_inb, sparse_inw, sparse_inl
+  },
+  {
+    dense_sethae,
+    dense_outb, dense_outw, dense_outl,
+    dense_inb, dense_inw, dense_inl
+  }
+};
+
+#undef DEBUG_IOPERM
+
+/* Routine to process the /proc/cpuinfo information into the fields
+   that are required for correctly determining the platform parameters.  */
+
+struct cpuinfo_data
+{
+  char systype[256];		/* system type field */
+  char sysvari[256];		/* system variation field */
+  char cpumodel[256];		/* cpu model field */
+};
+
+static inline int
+process_cpuinfo(struct cpuinfo_data *data)
+{
+  int got_type, got_vari, got_model;
+  char dummy[256];
+  FILE * fp;
+  int n;
+
+  data->systype[0] = 0;
+  data->sysvari[0] = 0;
+  data->cpumodel[0] = 0;
+
+  /* If there's an /etc/sw_64_systype link, we're intending to override
+     whatever's in /proc/cpuinfo.  */
+  n = __readlink (PATH_SW_64_SYSTYPE, data->systype, 256 - 1);
+  if (n > 0)
+    {
+      data->systype[n] = '\0';
+      return 1;
+    }
+
+  fp = fopen (PATH_CPUINFO, "rce");
+  if (!fp)
+    return 0;
+
+  got_type = got_vari = got_model = 0;
+
+  while (1)
+    {
+      if (fgets_unlocked (dummy, 256, fp) == NULL)
+	break;
+      if (!got_type
+	  && sscanf (dummy, "system type : %256[^\n]\n", data->systype) == 1)
+	got_type = 1;
+      if (!got_vari
+	  && (sscanf (dummy, "system variation : %256[^\n]\n", data->sysvari)
+	      == 1))
+	got_vari = 1;
+      if (!got_model
+	  && sscanf (dummy, "cpu model : %256[^\n]\n", data->cpumodel) == 1)
+	got_model = 1;
+    }
+
+  fclose (fp);
+
+#ifdef DEBUG_IOPERM
+  fprintf(stderr, "system type: `%s'\n", data->systype);
+  fprintf(stderr, "system vari: `%s'\n", data->sysvari);
+  fprintf(stderr, "cpu model: `%s'\n", data->cpumodel);
+#endif
+
+  return got_type + got_vari + got_model;
+}
+
+
+/*
+ * Initialize I/O system.
+ */
+static int
+init_iosys (void)
+{
+  long addr;
+  int i, olderrno = errno;
+  struct cpuinfo_data data;
+
+  /* First try the pciconfig_iobase syscall added to 2.2.15 and 2.3.99.  */
+
+  addr = __pciconfig_iobase (IOBASE_DENSE_MEM, 0, 0);
+  if (addr != -1)
+    {
+      ioswizzle_t io_swiz;
+
+      if (addr == 0)
+        {
+	  /* Only Jensen doesn't have dense mem space.  */
+	  io.sparse_bus_memory_base
+	    = io_system[IOSYS_JENSEN].sparse_bus_mem_base;
+	  io.io_base = io_system[IOSYS_JENSEN].bus_io_base;
+	  io_swiz = IOSWIZZLE_JENSEN;
+	}
+      else
+	{
+	  io.bus_memory_base = addr;
+
+	  addr = __pciconfig_iobase (IOBASE_DENSE_IO, 0, 0);
+	  if (addr != 0)
+	    {
+	      /* The X server uses _bus_base_sparse == 0 to know that
+		 BWX access are supported to dense mem space.  This is
+		 true of every system that supports dense io space, so
+	         never fill in io.sparse_bus_memory_base in this case.  */
+	      io_swiz = IOSWIZZLE_DENSE;
+              io.io_base = addr;
+	    }
+	  else
+	    {
+	      io.sparse_bus_memory_base
+		= __pciconfig_iobase (IOBASE_SPARSE_MEM, 0, 0);
+	      io.io_base = __pciconfig_iobase (IOBASE_SPARSE_IO, 0, 0);
+	      io_swiz = IOSWIZZLE_SPARSE;
+	    }
+	}
+
+      io.swiz = io_swiz;
+      io.swp = &ioswtch[io_swiz];
+
+      return 0;
+    }
+
+  /* Second, collect the contents of /etc/sw_64_systype or /proc/cpuinfo.  */
+
+  if (process_cpuinfo(&data) == 0)
+    {
+      /* This can happen if the format of /proc/cpuinfo changes.  */
+      fprintf (stderr,
+	       "ioperm.init_iosys: Unable to determine system type.\n"
+	       "\t(May need " PATH_SW_64_SYSTYPE " symlink?)\n");
+      __set_errno (ENODEV);
+      return -1;
+    }
+
+  /* Translate systype name into i/o system.  */
+  for (i = 0; i < sizeof (platform) / sizeof (platform[0]); ++i)
+    {
+      if (strcmp (platform[i].name, data.systype) == 0)
+	{
+	  iosys_t io_sys = platform[i].io_sys;
+
+	  /* Some platforms can have either EV4 or EV5 CPUs.  */
+	  if (io_sys == IOSYS_CPUDEP)
+	    {
+	      /* SABLE or MIKASA or NORITAKE so far.  */
+	      if (strcmp (platform[i].name, "Sable") == 0)
+		{
+		  if (strncmp (data.cpumodel, "EV4", 3) == 0)
+		    io_sys = IOSYS_T2;
+		  else if (strncmp (data.cpumodel, "EV5", 3) == 0)
+		    io_sys = IOSYS_GAMMA;
+		}
+	      else
+		{
+		  /* This covers MIKASA/NORITAKE.  */
+		  if (strncmp (data.cpumodel, "EV4", 3) == 0)
+		    io_sys = IOSYS_APECS;
+		  else if (strncmp (data.cpumodel, "EV5", 3) == 0)
+		    io_sys = IOSYS_CIA;
+		}
+	      if (io_sys == IOSYS_CPUDEP)
+		{
+		  /* This can happen if the format of /proc/cpuinfo changes.*/
+		  fprintf (stderr, "ioperm.init_iosys: Unable to determine"
+			   " CPU model.\n");
+		  __set_errno (ENODEV);
+		  return -1;
+		}
+	    }
+	  /* Some platforms can have different core logic chipsets */
+	  if (io_sys == IOSYS_PCIDEP)
+	    {
+	      /* EB164 so far */
+	      if (strcmp (data.systype, "EB164") == 0)
+		{
+		  if (strncmp (data.sysvari, "RX164", 5) == 0)
+		    io_sys = IOSYS_POLARIS;
+		  else if (strncmp (data.sysvari, "LX164", 5) == 0
+			   || strncmp (data.sysvari, "SX164", 5) == 0)
+		    io_sys = IOSYS_PYXIS;
+		  else
+		    io_sys = IOSYS_CIA;
+		}
+	      if (io_sys == IOSYS_PCIDEP)
+		{
+		  /* This can happen if the format of /proc/cpuinfo changes.*/
+		  fprintf (stderr, "ioperm.init_iosys: Unable to determine"
+			   " core logic chipset.\n");
+		  __set_errno (ENODEV);
+		  return -1;
+		}
+	    }
+	  io.bus_memory_base = io_system[io_sys].bus_memory_base;
+	  io.sparse_bus_memory_base = io_system[io_sys].sparse_bus_mem_base;
+	  io.io_base = io_system[io_sys].bus_io_base;
+
+	  if (io_sys == IOSYS_JENSEN)
+	    io.swiz = IOSWIZZLE_JENSEN;
+	  else if (io_sys == IOSYS_TSUNAMI
+		   || io_sys == IOSYS_POLARIS
+		   || io_sys == IOSYS_PYXIS)
+	    io.swiz = IOSWIZZLE_DENSE;
+	  else
+	    io.swiz = IOSWIZZLE_SPARSE;
+	  io.swp = &ioswtch[io.swiz];
+
+	  __set_errno (olderrno);
+	  return 0;
+	}
+    }
+
+  __set_errno (ENODEV);
+  fprintf(stderr, "ioperm.init_iosys: Platform not recognized.\n"
+	  "\t(May need " PATH_SW_64_SYSTYPE " symlink?)\n");
+  return -1;
+}
+
+
+int
+_ioperm (unsigned long int from, unsigned long int num, int turn_on)
+{
+  unsigned long int addr, len, pagesize = __getpagesize();
+  int prot;
+
+  if (!io.swp && init_iosys() < 0)
+    {
+#ifdef DEBUG_IOPERM
+      fprintf(stderr, "ioperm: init_iosys() failed (%m)\n");
+#endif
+      return -1;
+    }
+
+  /* This test isn't as silly as it may look like; consider overflows! */
+  if (from >= MAX_PORT || from + num > MAX_PORT)
+    {
+      __set_errno (EINVAL);
+#ifdef DEBUG_IOPERM
+      fprintf(stderr, "ioperm: from/num out of range\n");
+#endif
+      return -1;
+    }
+
+#ifdef DEBUG_IOPERM
+  fprintf(stderr, "ioperm: turn_on %d io.base %ld\n", turn_on, io.base);
+#endif
+
+  if (turn_on)
+    {
+      if (!io.base)
+	{
+	  int fd;
+
+	  io.hae_cache = 0;
+	  if (io.swiz != IOSWIZZLE_DENSE)
+	    {
+	      /* Synchronize with hw.  */
+	      __sethae (0);
+	    }
+
+	  fd = __open ("/dev/mem", O_RDWR);
+	  if (fd < 0)
+	    {
+#ifdef DEBUG_IOPERM
+	      fprintf(stderr, "ioperm: /dev/mem open failed (%m)\n");
+#endif
+	      return -1;
+	    }
+
+	  addr = port_to_cpu_addr (0, io.swiz, 1);
+	  len = port_to_cpu_addr (MAX_PORT, io.swiz, 1) - addr;
+	  io.base =
+	    (unsigned long int) __mmap (0, len, PROT_NONE, MAP_SHARED,
+					fd, io.io_base);
+	  __close (fd);
+#ifdef DEBUG_IOPERM
+	  fprintf(stderr, "ioperm: mmap of len 0x%lx  returned 0x%lx\n",
+		  len, io.base);
+#endif
+	  if ((long) io.base == -1)
+	    return -1;
+	}
+      prot = PROT_READ | PROT_WRITE;
+    }
+  else
+    {
+      if (!io.base)
+	return 0;	/* never was turned on... */
+
+      /* turnoff access to relevant pages: */
+      prot = PROT_NONE;
+    }
+  addr = port_to_cpu_addr (from, io.swiz, 1);
+  addr &= ~(pagesize - 1);
+  len = port_to_cpu_addr (from + num, io.swiz, 1) - addr;
+  return __mprotect ((void *) addr, len, prot);
+}
+
+
+int
+_iopl (int level)
+{
+  switch (level)
+    {
+    case 0:
+      return 0;
+
+    case 1: case 2: case 3:
+      return _ioperm (0, MAX_PORT, 1);
+
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+
+
+void
+_sethae (unsigned long int addr)
+{
+  if (!io.swp && init_iosys () < 0)
+    return;
+
+  io.swp->sethae (addr);
+}
+
+
+void
+_outb (unsigned char b, unsigned long int port)
+{
+  if (port >= MAX_PORT)
+    return;
+
+  io.swp->outb (b, port);
+}
+
+
+void
+_outw (unsigned short b, unsigned long int port)
+{
+  if (port >= MAX_PORT)
+    return;
+
+  io.swp->outw (b, port);
+}
+
+
+void
+_outl (unsigned int b, unsigned long int port)
+{
+  if (port >= MAX_PORT)
+    return;
+
+  io.swp->outl (b, port);
+}
+
+
+unsigned int
+_inb (unsigned long int port)
+{
+  return io.swp->inb (port);
+}
+
+
+unsigned int
+_inw (unsigned long int port)
+{
+  return io.swp->inw (port);
+}
+
+
+unsigned int
+_inl (unsigned long int port)
+{
+  return io.swp->inl (port);
+}
+
+
+unsigned long int
+_bus_base(void)
+{
+  if (!io.swp && init_iosys () < 0)
+    return -1;
+  return io.bus_memory_base;
+}
+
+unsigned long int
+_bus_base_sparse(void)
+{
+  if (!io.swp && init_iosys () < 0)
+    return -1;
+  return io.sparse_bus_memory_base;
+}
+
+int
+_hae_shift(void)
+{
+  if (!io.swp && init_iosys () < 0)
+    return -1;
+  if (io.swiz == IOSWIZZLE_JENSEN)
+    return 7;
+  if (io.swiz == IOSWIZZLE_SPARSE)
+    return 5;
+  return 0;
+}
+
+weak_alias (_sethae, sethae);
+weak_alias (_ioperm, ioperm);
+weak_alias (_iopl, iopl);
+weak_alias (_inb, inb);
+weak_alias (_inw, inw);
+weak_alias (_inl, inl);
+weak_alias (_outb, outb);
+weak_alias (_outw, outw);
+weak_alias (_outl, outl);
+weak_alias (_bus_base, bus_base);
+weak_alias (_bus_base_sparse, bus_base_sparse);
+weak_alias (_hae_shift, hae_shift);
diff --git a/sysdeps/unix/sysv/linux/sw_64/ipc_priv.h b/sysdeps/unix/sysv/linux/sw_64/ipc_priv.h
new file mode 100644
index 00000000..6f7f17ba
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/ipc_priv.h
@@ -0,0 +1,21 @@
+/* Old SysV permission definition for Linux.  Sw_64 version.
+   Copyright (C) 2016-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __OLD_IPC_ID_TYPE   unsigned int
+#define __OLD_IPC_MODE_TYPE unsigned int
+#include <sysdeps/unix/sysv/linux/ipc_priv.h>
diff --git a/sysdeps/unix/sysv/linux/sw_64/jmp_buf-macros.h b/sysdeps/unix/sysv/linux/sw_64/jmp_buf-macros.h
new file mode 100644
index 00000000..b595173e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/jmp_buf-macros.h
@@ -0,0 +1,6 @@
+#define JMP_BUF_SIZE 272
+#define SIGJMP_BUF_SIZE 272
+#define JMP_BUF_ALIGN 8
+#define SIGJMP_BUF_ALIGN 8
+#define MASK_WAS_SAVED_OFFSET 136
+#define SAVED_MASK_OFFSET 144
diff --git a/sysdeps/unix/sysv/linux/sw_64/kernel-features.h b/sysdeps/unix/sysv/linux/sw_64/kernel-features.h
new file mode 100644
index 00000000..90336e66
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/kernel-features.h
@@ -0,0 +1,53 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 2010-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _KERNEL_FEATURES_H
+#define _KERNEL_FEATURES_H 1
+
+#include_next <kernel-features.h>
+
+/* Support for statfs64 was added in 5.1.  */
+#if __LINUX_KERNEL_VERSION < 0x050100
+# undef __ASSUME_STATFS64
+# define __ASSUME_STATFS64 0
+#endif
+
+#define __ASSUME_RECV_SYSCALL	1
+#define __ASSUME_SEND_SYSCALL	1
+
+/* Support for the renameat2 syscall was added in 3.17.  */
+#if __LINUX_KERNEL_VERSION < 0x031100
+# undef __ASSUME_RENAMEAT2
+#endif
+
+/* Support for the execveat syscall was added in 4.2.  */
+#if __LINUX_KERNEL_VERSION < 0x040200
+# undef __ASSUME_EXECVEAT
+#endif
+
+/* Support for copy_file_range, statx was added in kernel 4.13.  */
+#if __LINUX_KERNEL_VERSION < 0x040D00
+# undef __ASSUME_MLOCK2
+# undef __ASSUME_STATX
+#endif
+
+/* Sw_64 requires old sysvipc even being a 64-bit architecture.  */
+#undef __ASSUME_SYSVIPC_DEFAULT_IPC_64
+
+#endif /* _KERNEL_FEATURES_H */
diff --git a/sysdeps/unix/sysv/linux/sw_64/kernel_rt_sigframe.h b/sysdeps/unix/sysv/linux/sw_64/kernel_rt_sigframe.h
new file mode 100644
index 00000000..599786f7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/kernel_rt_sigframe.h
@@ -0,0 +1,25 @@
+/* Copyright (C) 2009-2018 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This structure must have the same shape as the linux kernel
+   equivalent.  */
+struct kernel_rt_sigframe
+{
+  siginfo_t info;
+  ucontext_t uc;
+};
diff --git a/sysdeps/unix/sysv/linux/sw_64/kernel_sigaction.h b/sysdeps/unix/sysv/linux/sw_64/kernel_sigaction.h
new file mode 100644
index 00000000..679179b5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/kernel_sigaction.h
@@ -0,0 +1,11 @@
+#include <sysdeps/unix/sysv/linux/kernel_sigaction.h>
+
+void __syscall_rt_sigreturn (void) attribute_hidden;
+void __syscall_sigreturn (void) attribute_hidden;
+
+#define STUB(act, sigsetsize) \
+  (sigsetsize),						\
+  (act) ? ((unsigned long)((act->sa_flags & SA_SIGINFO)	\
+			    ? &__syscall_rt_sigreturn	\
+			    : &__syscall_sigreturn))	\
+	: 0
diff --git a/sysdeps/unix/sysv/linux/sw_64/kernel_stat.h b/sysdeps/unix/sysv/linux/sw_64/kernel_stat.h
new file mode 100644
index 00000000..a2929209
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/kernel_stat.h
@@ -0,0 +1,91 @@
+/* Definition of `struct stat' used in the kernel.  */
+struct kernel_stat
+  {
+    unsigned int st_dev;
+    unsigned int st_ino;
+    unsigned int st_mode;
+    unsigned int st_nlink;
+    unsigned int st_uid;
+    unsigned int st_gid;
+    unsigned int st_rdev;
+    long int st_size;
+    unsigned long int st_atime_sec;
+    unsigned long int st_mtime_sec;
+    unsigned long int st_ctime_sec;
+    unsigned int st_blksize;
+    int st_blocks;
+    unsigned int st_flags;
+    unsigned int st_gen;
+  };
+
+/* Definition of `struct stat64' used in the kernel.  */
+struct kernel_stat64
+  {
+    unsigned long   st_dev;
+    unsigned long   st_ino;
+    unsigned long   st_rdev;
+    long            st_size;
+    unsigned long   st_blocks;
+
+    unsigned int    st_mode;
+    unsigned int    st_uid;
+    unsigned int    st_gid;
+    unsigned int    st_blksize;
+    unsigned int    st_nlink;
+    unsigned int    __pad0;
+
+    unsigned long   st_atime_sec;
+    unsigned long   st_atimensec;
+    unsigned long   st_mtime_sec;
+    unsigned long   st_mtimensec;
+    unsigned long   st_ctime_sec;
+    unsigned long   st_ctimensec;
+    long            __glibc_reserved[3];
+  };
+
+/* Definition of `struct stat' used by glibc 2.0.  */
+struct glibc2_stat
+  {
+    __dev_t st_dev;
+    __ino_t st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    __off_t st_size;
+    __time_t st_atime_sec;
+    __time_t st_mtime_sec;
+    __time_t st_ctime_sec;
+    unsigned int st_blksize;
+    int st_blocks;
+    unsigned int st_flags;
+    unsigned int st_gen;
+  };
+
+/* Definition of `struct stat' used by glibc 2.1.  */
+struct glibc21_stat
+  {
+    __dev_t st_dev;
+    __ino64_t st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    __off_t st_size;
+    __time_t st_atime_sec;
+    __time_t st_mtime_sec;
+    __time_t st_ctime_sec;
+    __blkcnt64_t st_blocks;
+    __blksize_t st_blksize;
+    unsigned int st_flags;
+    unsigned int st_gen;
+    int __pad3;
+    long __glibc_reserved[4];
+  };
+
+#define STAT_IS_KERNEL_STAT 0
+#define STAT64_IS_KERNEL_STAT64 1
+#define XSTAT_IS_XSTAT64 1
+#define STATFS_IS_STATFS64 0
diff --git a/sysdeps/unix/sysv/linux/sw_64/kernel_sysinfo.h b/sysdeps/unix/sysv/linux/sw_64/kernel_sysinfo.h
new file mode 100644
index 00000000..a3edec22
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/kernel_sysinfo.h
@@ -0,0 +1,6 @@
+/* A copy of the couple of bits we need from <asm/sysinfo.h>.  */
+
+#define GSI_IEEE_FP_CONTROL		45
+
+#define SSI_IEEE_FP_CONTROL		14
+#define SSI_IEEE_RAISE_EXCEPTION	1001
diff --git a/sysdeps/unix/sysv/linux/sw_64/kernel_termios.h b/sysdeps/unix/sysv/linux/sw_64/kernel_termios.h
new file mode 100644
index 00000000..ee7377c6
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/kernel_termios.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 1997-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _KERNEL_TERMIOS_H
+#define _KERNEL_TERMIOS_H 1
+
+/* The following corresponds to the values from the Linux 2.1.20 kernel.  */
+
+/* We need the definition of tcflag_t, cc_t, and speed_t.  */
+#include <termios.h>
+
+#define __KERNEL_NCCS 19
+
+struct __kernel_termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_cc[__KERNEL_NCCS];	/* control characters */
+    cc_t c_line;		/* line discipline */
+    speed_t c_ispeed;		/* input speed */
+    speed_t c_ospeed;		/* output speed */
+  };
+
+#define _HAVE_C_ISPEED 1
+#define _HAVE_C_OSPEED 1
+
+#endif /* kernel_termios.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/ld.abilist b/sysdeps/unix/sysv/linux/sw_64/ld.abilist
new file mode 100644
index 00000000..3e296c54
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/ld.abilist
@@ -0,0 +1,9 @@
+GLIBC_2.0 _r_debug D 0x28
+GLIBC_2.1 __libc_stack_end D 0x8
+GLIBC_2.1 _dl_mcount F
+GLIBC_2.3 __tls_get_addr F
+GLIBC_2.34 __rtld_version_placeholder F
+GLIBC_2.35 __rseq_flags D 0x4
+GLIBC_2.35 __rseq_offset D 0x8
+GLIBC_2.35 __rseq_size D 0x4
+GLIBC_2.4 __stack_chk_guard D 0x8
diff --git a/sysdeps/unix/sysv/linux/sw_64/libBrokenLocale.abilist b/sysdeps/unix/sysv/linux/sw_64/libBrokenLocale.abilist
new file mode 100644
index 00000000..54395f3c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libBrokenLocale.abilist
@@ -0,0 +1 @@
+GLIBC_2.0 __ctype_get_mb_cur_max F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libanl.abilist b/sysdeps/unix/sysv/linux/sw_64/libanl.abilist
new file mode 100644
index 00000000..b748507b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libanl.abilist
@@ -0,0 +1 @@
+GLIBC_2.2.3 __libanl_version_placeholder F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libc.abilist b/sysdeps/unix/sysv/linux/sw_64/libc.abilist
new file mode 100644
index 00000000..be63f4ec
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libc.abilist
@@ -0,0 +1,3108 @@
+GCC_3.0 _Unwind_Find_FDE F
+GCC_3.0 __deregister_frame_info_bases F
+GCC_3.0 __register_frame_info_bases F
+GCC_3.0 __register_frame_info_table_bases F
+GLIBC_2.0 _IO_adjust_column F
+GLIBC_2.0 _IO_default_doallocate F
+GLIBC_2.0 _IO_default_finish F
+GLIBC_2.0 _IO_default_pbackfail F
+GLIBC_2.0 _IO_default_uflow F
+GLIBC_2.0 _IO_default_xsgetn F
+GLIBC_2.0 _IO_default_xsputn F
+GLIBC_2.0 _IO_do_write F
+GLIBC_2.0 _IO_doallocbuf F
+GLIBC_2.0 _IO_fclose F
+GLIBC_2.0 _IO_fdopen F
+GLIBC_2.0 _IO_feof F
+GLIBC_2.0 _IO_ferror F
+GLIBC_2.0 _IO_fflush F
+GLIBC_2.0 _IO_fgetpos F
+GLIBC_2.0 _IO_fgets F
+GLIBC_2.0 _IO_file_attach F
+GLIBC_2.0 _IO_file_close F
+GLIBC_2.0 _IO_file_close_it F
+GLIBC_2.0 _IO_file_doallocate F
+GLIBC_2.0 _IO_file_fopen F
+GLIBC_2.0 _IO_file_init F
+GLIBC_2.0 _IO_file_jumps D 0xa8
+GLIBC_2.0 _IO_file_open F
+GLIBC_2.0 _IO_file_overflow F
+GLIBC_2.0 _IO_file_read F
+GLIBC_2.0 _IO_file_seek F
+GLIBC_2.0 _IO_file_seekoff F
+GLIBC_2.0 _IO_file_setbuf F
+GLIBC_2.0 _IO_file_stat F
+GLIBC_2.0 _IO_file_sync F
+GLIBC_2.0 _IO_file_underflow F
+GLIBC_2.0 _IO_file_write F
+GLIBC_2.0 _IO_file_xsputn F
+GLIBC_2.0 _IO_flockfile F
+GLIBC_2.0 _IO_flush_all F
+GLIBC_2.0 _IO_flush_all_linebuffered F
+GLIBC_2.0 _IO_fopen F
+GLIBC_2.0 _IO_fprintf F
+GLIBC_2.0 _IO_fputs F
+GLIBC_2.0 _IO_fread F
+GLIBC_2.0 _IO_free_backup_area F
+GLIBC_2.0 _IO_fsetpos F
+GLIBC_2.0 _IO_ftell F
+GLIBC_2.0 _IO_ftrylockfile F
+GLIBC_2.0 _IO_funlockfile F
+GLIBC_2.0 _IO_fwrite F
+GLIBC_2.0 _IO_getc F
+GLIBC_2.0 _IO_getline F
+GLIBC_2.0 _IO_gets F
+GLIBC_2.0 _IO_init F
+GLIBC_2.0 _IO_init_marker F
+GLIBC_2.0 _IO_link_in F
+GLIBC_2.0 _IO_list_all D 0x8
+GLIBC_2.0 _IO_marker_delta F
+GLIBC_2.0 _IO_marker_difference F
+GLIBC_2.0 _IO_padn F
+GLIBC_2.0 _IO_peekc_locked F
+GLIBC_2.0 _IO_popen F
+GLIBC_2.0 _IO_printf F
+GLIBC_2.0 _IO_proc_close F
+GLIBC_2.0 _IO_proc_open F
+GLIBC_2.0 _IO_putc F
+GLIBC_2.0 _IO_puts F
+GLIBC_2.0 _IO_remove_marker F
+GLIBC_2.0 _IO_seekmark F
+GLIBC_2.0 _IO_seekoff F
+GLIBC_2.0 _IO_seekpos F
+GLIBC_2.0 _IO_setb F
+GLIBC_2.0 _IO_setbuffer F
+GLIBC_2.0 _IO_setvbuf F
+GLIBC_2.0 _IO_sgetn F
+GLIBC_2.0 _IO_sprintf F
+GLIBC_2.0 _IO_sputbackc F
+GLIBC_2.0 _IO_sscanf F
+GLIBC_2.0 _IO_stderr_ D 0x98
+GLIBC_2.0 _IO_stdin_ D 0x98
+GLIBC_2.0 _IO_stdout_ D 0x98
+GLIBC_2.0 _IO_str_init_readonly F
+GLIBC_2.0 _IO_str_init_static F
+GLIBC_2.0 _IO_str_overflow F
+GLIBC_2.0 _IO_str_pbackfail F
+GLIBC_2.0 _IO_str_seekoff F
+GLIBC_2.0 _IO_str_underflow F
+GLIBC_2.0 _IO_sungetc F
+GLIBC_2.0 _IO_switch_to_get_mode F
+GLIBC_2.0 _IO_un_link F
+GLIBC_2.0 _IO_ungetc F
+GLIBC_2.0 _IO_unsave_markers F
+GLIBC_2.0 _IO_vfprintf F
+GLIBC_2.0 _IO_vfscanf F
+GLIBC_2.0 _IO_vsprintf F
+GLIBC_2.0 __adjtimex F
+GLIBC_2.0 __after_morecore_hook D 0x8
+GLIBC_2.0 __argz_count F
+GLIBC_2.0 __argz_next F
+GLIBC_2.0 __argz_stringify F
+GLIBC_2.0 __assert_fail F
+GLIBC_2.0 __assert_perror_fail F
+GLIBC_2.0 __bsd_getpgrp F
+GLIBC_2.0 __bzero F
+GLIBC_2.0 __check_rhosts_file D 0x4
+GLIBC_2.0 __clone F
+GLIBC_2.0 __close F
+GLIBC_2.0 __cmsg_nxthdr F
+GLIBC_2.0 __connect F
+GLIBC_2.0 __ctype32_b D 0x8
+GLIBC_2.0 __ctype_b D 0x8
+GLIBC_2.0 __ctype_get_mb_cur_max F
+GLIBC_2.0 __ctype_tolower D 0x8
+GLIBC_2.0 __ctype_toupper D 0x8
+GLIBC_2.0 __curbrk D 0x8
+GLIBC_2.0 __daylight D 0x4
+GLIBC_2.0 __dcgettext F
+GLIBC_2.0 __default_morecore F
+GLIBC_2.0 __deregister_frame F
+GLIBC_2.0 __deregister_frame_info F
+GLIBC_2.0 __dgettext F
+GLIBC_2.0 __divl F
+GLIBC_2.0 __divlu F
+GLIBC_2.0 __divw F
+GLIBC_2.0 __divwu F
+GLIBC_2.0 __dn_comp F
+GLIBC_2.0 __dn_skipname F
+GLIBC_2.0 __dup2 F
+GLIBC_2.0 __environ D 0x8
+GLIBC_2.0 __errno_location F
+GLIBC_2.0 __fcntl F
+GLIBC_2.0 __ffs F
+GLIBC_2.0 __finite F
+GLIBC_2.0 __finitef F
+GLIBC_2.0 __finitel F
+GLIBC_2.0 __fork F
+GLIBC_2.0 __fpu_control D 0x4
+GLIBC_2.0 __frame_state_for F
+GLIBC_2.0 __free_hook D 0x8
+GLIBC_2.0 __fxstat F
+GLIBC_2.0 __getdelim F
+GLIBC_2.0 __getpagesize F
+GLIBC_2.0 __getpgid F
+GLIBC_2.0 __getpid F
+GLIBC_2.0 __gettimeofday F
+GLIBC_2.0 __gmtime_r F
+GLIBC_2.0 __h_errno_location F
+GLIBC_2.0 __ieee_get_fp_control F
+GLIBC_2.0 __ieee_set_fp_control F
+GLIBC_2.0 __isinf F
+GLIBC_2.0 __isinff F
+GLIBC_2.0 __isinfl F
+GLIBC_2.0 __isnan F
+GLIBC_2.0 __isnanf F
+GLIBC_2.0 __isnanl F
+GLIBC_2.0 __iswctype F
+GLIBC_2.0 __ivaliduser F
+GLIBC_2.0 __libc_calloc F
+GLIBC_2.0 __libc_free F
+GLIBC_2.0 __libc_init_first F
+GLIBC_2.0 __libc_mallinfo F
+GLIBC_2.0 __libc_malloc F
+GLIBC_2.0 __libc_mallopt F
+GLIBC_2.0 __libc_memalign F
+GLIBC_2.0 __libc_pvalloc F
+GLIBC_2.0 __libc_realloc F
+GLIBC_2.0 __libc_start_main F
+GLIBC_2.0 __libc_valloc F
+GLIBC_2.0 __lseek F
+GLIBC_2.0 __lxstat F
+GLIBC_2.0 __malloc_hook D 0x8
+GLIBC_2.0 __malloc_initialize_hook D 0x8
+GLIBC_2.0 __mbrlen F
+GLIBC_2.0 __mbrtowc F
+GLIBC_2.0 __memalign_hook D 0x8
+GLIBC_2.0 __mempcpy F
+GLIBC_2.0 __monstartup F
+GLIBC_2.0 __morecore D 0x8
+GLIBC_2.0 __nss_configure_lookup F
+GLIBC_2.0 __nss_database_lookup F
+GLIBC_2.0 __nss_group_lookup F
+GLIBC_2.0 __nss_hosts_lookup F
+GLIBC_2.0 __nss_next F
+GLIBC_2.0 __nss_passwd_lookup F
+GLIBC_2.0 __open F
+GLIBC_2.0 __overflow F
+GLIBC_2.0 __pipe F
+GLIBC_2.0 __printf_fp F
+GLIBC_2.0 __profile_frequency F
+GLIBC_2.0 __progname D 0x8
+GLIBC_2.0 __progname_full D 0x8
+GLIBC_2.0 __pthread_getspecific F
+GLIBC_2.0 __pthread_key_create F
+GLIBC_2.0 __pthread_mutex_destroy F
+GLIBC_2.0 __pthread_mutex_init F
+GLIBC_2.0 __pthread_mutex_lock F
+GLIBC_2.0 __pthread_mutex_trylock F
+GLIBC_2.0 __pthread_mutex_unlock F
+GLIBC_2.0 __pthread_mutexattr_destroy F
+GLIBC_2.0 __pthread_mutexattr_init F
+GLIBC_2.0 __pthread_mutexattr_settype F
+GLIBC_2.0 __pthread_once F
+GLIBC_2.0 __pthread_setspecific F
+GLIBC_2.0 __rcmd_errstr D 0x8
+GLIBC_2.0 __read F
+GLIBC_2.0 __realloc_hook D 0x8
+GLIBC_2.0 __register_frame F
+GLIBC_2.0 __register_frame_info F
+GLIBC_2.0 __register_frame_info_table F
+GLIBC_2.0 __register_frame_table F
+GLIBC_2.0 __reml F
+GLIBC_2.0 __remlu F
+GLIBC_2.0 __remw F
+GLIBC_2.0 __remwu F
+GLIBC_2.0 __res_dnok F
+GLIBC_2.0 __res_hnok F
+GLIBC_2.0 __res_mailok F
+GLIBC_2.0 __res_ownok F
+GLIBC_2.0 __res_randomid F
+GLIBC_2.0 __res_send F
+GLIBC_2.0 __sbrk F
+GLIBC_2.0 __sched_get_priority_max F
+GLIBC_2.0 __sched_get_priority_min F
+GLIBC_2.0 __sched_getparam F
+GLIBC_2.0 __sched_getscheduler F
+GLIBC_2.0 __sched_setscheduler F
+GLIBC_2.0 __sched_yield F
+GLIBC_2.0 __secure_getenv F
+GLIBC_2.0 __select F
+GLIBC_2.0 __send F
+GLIBC_2.0 __setpgid F
+GLIBC_2.0 __sigaction F
+GLIBC_2.0 __sigaddset F
+GLIBC_2.0 __sigdelset F
+GLIBC_2.0 __sigismember F
+GLIBC_2.0 __sigpause F
+GLIBC_2.0 __sigsetjmp F
+GLIBC_2.0 __stpcpy F
+GLIBC_2.0 __stpncpy F
+GLIBC_2.0 __strcasecmp F
+GLIBC_2.0 __strdup F
+GLIBC_2.0 __strerror_r F
+GLIBC_2.0 __strtod_internal F
+GLIBC_2.0 __strtof_internal F
+GLIBC_2.0 __strtok_r F
+GLIBC_2.0 __strtol_internal F
+GLIBC_2.0 __strtold_internal F
+GLIBC_2.0 __strtoll_internal F
+GLIBC_2.0 __strtoul_internal F
+GLIBC_2.0 __strtoull_internal F
+GLIBC_2.0 __sysv_signal F
+GLIBC_2.0 __timezone D 0x8
+GLIBC_2.0 __tzname D 0x10
+GLIBC_2.0 __uflow F
+GLIBC_2.0 __underflow F
+GLIBC_2.0 __vfscanf F
+GLIBC_2.0 __vsnprintf F
+GLIBC_2.0 __vsscanf F
+GLIBC_2.0 __wait F
+GLIBC_2.0 __waitpid F
+GLIBC_2.0 __wcstod_internal F
+GLIBC_2.0 __wcstof_internal F
+GLIBC_2.0 __wcstol_internal F
+GLIBC_2.0 __wcstold_internal F
+GLIBC_2.0 __wcstoll_internal F
+GLIBC_2.0 __wcstoul_internal F
+GLIBC_2.0 __wcstoull_internal F
+GLIBC_2.0 __write F
+GLIBC_2.0 __xmknod F
+GLIBC_2.0 __xpg_basename F
+GLIBC_2.0 __xstat F
+GLIBC_2.0 _bus_base F
+GLIBC_2.0 _bus_base_sparse F
+GLIBC_2.0 _environ D 0x8
+GLIBC_2.0 _exit F
+GLIBC_2.0 _hae_shift F
+GLIBC_2.0 _inb F
+GLIBC_2.0 _inl F
+GLIBC_2.0 _inw F
+GLIBC_2.0 _libc_intl_domainname D 0x5
+GLIBC_2.0 _longjmp F
+GLIBC_2.0 _mcleanup F
+GLIBC_2.0 _mcount F
+GLIBC_2.0 _nl_default_dirname D 0x30
+GLIBC_2.0 _nl_domain_bindings D 0x8
+GLIBC_2.0 _nl_msg_cat_cntr D 0x4
+GLIBC_2.0 _null_auth D 0x18
+GLIBC_2.0 _obstack D 0x8
+GLIBC_2.0 _obstack_allocated_p F
+GLIBC_2.0 _obstack_begin F
+GLIBC_2.0 _obstack_begin_1 F
+GLIBC_2.0 _obstack_free F
+GLIBC_2.0 _obstack_memory_used F
+GLIBC_2.0 _obstack_newchunk F
+GLIBC_2.0 _outb F
+GLIBC_2.0 _outl F
+GLIBC_2.0 _outw F
+GLIBC_2.0 _pthread_cleanup_pop F
+GLIBC_2.0 _pthread_cleanup_pop_restore F
+GLIBC_2.0 _pthread_cleanup_push F
+GLIBC_2.0 _pthread_cleanup_push_defer F
+GLIBC_2.0 _res D 0x238
+GLIBC_2.0 _rpc_dtablesize F
+GLIBC_2.0 _seterr_reply F
+GLIBC_2.0 _setjmp F
+GLIBC_2.0 _sys_errlist D 0x3d8
+GLIBC_2.0 _sys_nerr D 0x4
+GLIBC_2.0 _sys_siglist D 0x100
+GLIBC_2.0 _tolower F
+GLIBC_2.0 _toupper F
+GLIBC_2.0 a64l F
+GLIBC_2.0 abort F
+GLIBC_2.0 abs F
+GLIBC_2.0 accept F
+GLIBC_2.0 access F
+GLIBC_2.0 acct F
+GLIBC_2.0 addmntent F
+GLIBC_2.0 adjtime F
+GLIBC_2.0 adjtimex F
+GLIBC_2.0 advance F
+GLIBC_2.0 alarm F
+GLIBC_2.0 alphasort F
+GLIBC_2.0 argz_add F
+GLIBC_2.0 argz_add_sep F
+GLIBC_2.0 argz_append F
+GLIBC_2.0 argz_count F
+GLIBC_2.0 argz_create F
+GLIBC_2.0 argz_create_sep F
+GLIBC_2.0 argz_delete F
+GLIBC_2.0 argz_extract F
+GLIBC_2.0 argz_insert F
+GLIBC_2.0 argz_next F
+GLIBC_2.0 argz_replace F
+GLIBC_2.0 argz_stringify F
+GLIBC_2.0 asctime F
+GLIBC_2.0 asctime_r F
+GLIBC_2.0 asprintf F
+GLIBC_2.0 atexit F
+GLIBC_2.0 atof F
+GLIBC_2.0 atoi F
+GLIBC_2.0 atol F
+GLIBC_2.0 atoll F
+GLIBC_2.0 authnone_create F
+GLIBC_2.0 authunix_create F
+GLIBC_2.0 authunix_create_default F
+GLIBC_2.0 basename F
+GLIBC_2.0 bcmp F
+GLIBC_2.0 bcopy F
+GLIBC_2.0 bdflush F
+GLIBC_2.0 bind F
+GLIBC_2.0 bindresvport F
+GLIBC_2.0 bindtextdomain F
+GLIBC_2.0 brk F
+GLIBC_2.0 bsd_signal F
+GLIBC_2.0 bsearch F
+GLIBC_2.0 btowc F
+GLIBC_2.0 bus_base F
+GLIBC_2.0 bus_base_sparse F
+GLIBC_2.0 bzero F
+GLIBC_2.0 calloc F
+GLIBC_2.0 callrpc F
+GLIBC_2.0 canonicalize_file_name F
+GLIBC_2.0 catclose F
+GLIBC_2.0 catgets F
+GLIBC_2.0 catopen F
+GLIBC_2.0 cfgetispeed F
+GLIBC_2.0 cfgetospeed F
+GLIBC_2.0 cfmakeraw F
+GLIBC_2.0 cfree F
+GLIBC_2.0 cfsetispeed F
+GLIBC_2.0 cfsetospeed F
+GLIBC_2.0 cfsetspeed F
+GLIBC_2.0 chdir F
+GLIBC_2.0 chflags F
+GLIBC_2.0 chmod F
+GLIBC_2.0 chown F
+GLIBC_2.0 chroot F
+GLIBC_2.0 clearenv F
+GLIBC_2.0 clearerr F
+GLIBC_2.0 clearerr_unlocked F
+GLIBC_2.0 clnt_broadcast F
+GLIBC_2.0 clnt_create F
+GLIBC_2.0 clnt_pcreateerror F
+GLIBC_2.0 clnt_perrno F
+GLIBC_2.0 clnt_perror F
+GLIBC_2.0 clnt_spcreateerror F
+GLIBC_2.0 clnt_sperrno F
+GLIBC_2.0 clnt_sperror F
+GLIBC_2.0 clntraw_create F
+GLIBC_2.0 clnttcp_create F
+GLIBC_2.0 clntudp_bufcreate F
+GLIBC_2.0 clntudp_create F
+GLIBC_2.0 clock F
+GLIBC_2.0 clone F
+GLIBC_2.0 close F
+GLIBC_2.0 closedir F
+GLIBC_2.0 closelog F
+GLIBC_2.0 confstr F
+GLIBC_2.0 connect F
+GLIBC_2.0 copysign F
+GLIBC_2.0 copysignf F
+GLIBC_2.0 copysignl F
+GLIBC_2.0 creat F
+GLIBC_2.0 create_module F
+GLIBC_2.0 ctermid F
+GLIBC_2.0 ctime F
+GLIBC_2.0 ctime_r F
+GLIBC_2.0 cuserid F
+GLIBC_2.0 daemon F
+GLIBC_2.0 daylight D 0x4
+GLIBC_2.0 dcgettext F
+GLIBC_2.0 delete_module F
+GLIBC_2.0 dgettext F
+GLIBC_2.0 difftime F
+GLIBC_2.0 dirfd F
+GLIBC_2.0 dirname F
+GLIBC_2.0 div F
+GLIBC_2.0 dladdr F
+GLIBC_2.0 dlclose F
+GLIBC_2.0 dlerror F
+GLIBC_2.0 dlopen F
+GLIBC_2.0 dlsym F
+GLIBC_2.0 dn_expand F
+GLIBC_2.0 dprintf F
+GLIBC_2.0 drand48 F
+GLIBC_2.0 drand48_r F
+GLIBC_2.0 dup F
+GLIBC_2.0 dup2 F
+GLIBC_2.0 dysize F
+GLIBC_2.0 ecvt F
+GLIBC_2.0 ecvt_r F
+GLIBC_2.0 endaliasent F
+GLIBC_2.0 endfsent F
+GLIBC_2.0 endgrent F
+GLIBC_2.0 endhostent F
+GLIBC_2.0 endmntent F
+GLIBC_2.0 endnetent F
+GLIBC_2.0 endnetgrent F
+GLIBC_2.0 endprotoent F
+GLIBC_2.0 endpwent F
+GLIBC_2.0 endrpcent F
+GLIBC_2.0 endservent F
+GLIBC_2.0 endspent F
+GLIBC_2.0 endttyent F
+GLIBC_2.0 endusershell F
+GLIBC_2.0 endutent F
+GLIBC_2.0 environ D 0x8
+GLIBC_2.0 envz_add F
+GLIBC_2.0 envz_entry F
+GLIBC_2.0 envz_get F
+GLIBC_2.0 envz_merge F
+GLIBC_2.0 envz_remove F
+GLIBC_2.0 envz_strip F
+GLIBC_2.0 erand48 F
+GLIBC_2.0 erand48_r F
+GLIBC_2.0 err F
+GLIBC_2.0 error F
+GLIBC_2.0 error_at_line F
+GLIBC_2.0 error_message_count D 0x4
+GLIBC_2.0 error_one_per_line D 0x4
+GLIBC_2.0 error_print_progname D 0x8
+GLIBC_2.0 errx F
+GLIBC_2.0 ether_aton F
+GLIBC_2.0 ether_aton_r F
+GLIBC_2.0 ether_hostton F
+GLIBC_2.0 ether_line F
+GLIBC_2.0 ether_ntoa F
+GLIBC_2.0 ether_ntoa_r F
+GLIBC_2.0 ether_ntohost F
+GLIBC_2.0 euidaccess F
+GLIBC_2.0 execl F
+GLIBC_2.0 execle F
+GLIBC_2.0 execlp F
+GLIBC_2.0 execv F
+GLIBC_2.0 execve F
+GLIBC_2.0 execvp F
+GLIBC_2.0 exit F
+GLIBC_2.0 fchdir F
+GLIBC_2.0 fchflags F
+GLIBC_2.0 fchmod F
+GLIBC_2.0 fchown F
+GLIBC_2.0 fclose F
+GLIBC_2.0 fcloseall F
+GLIBC_2.0 fcntl F
+GLIBC_2.0 fcvt F
+GLIBC_2.0 fcvt_r F
+GLIBC_2.0 fdatasync F
+GLIBC_2.0 fdopen F
+GLIBC_2.0 feof F
+GLIBC_2.0 feof_unlocked F
+GLIBC_2.0 ferror F
+GLIBC_2.0 ferror_unlocked F
+GLIBC_2.0 fexecve F
+GLIBC_2.0 fflush F
+GLIBC_2.0 fflush_unlocked F
+GLIBC_2.0 ffs F
+GLIBC_2.0 fgetc F
+GLIBC_2.0 fgetgrent F
+GLIBC_2.0 fgetgrent_r F
+GLIBC_2.0 fgetpos F
+GLIBC_2.0 fgetpwent F
+GLIBC_2.0 fgetpwent_r F
+GLIBC_2.0 fgets F
+GLIBC_2.0 fgetspent F
+GLIBC_2.0 fgetspent_r F
+GLIBC_2.0 fileno F
+GLIBC_2.0 fileno_unlocked F
+GLIBC_2.0 finite F
+GLIBC_2.0 finitef F
+GLIBC_2.0 finitel F
+GLIBC_2.0 flock F
+GLIBC_2.0 flockfile F
+GLIBC_2.0 fnmatch F
+GLIBC_2.0 fopen F
+GLIBC_2.0 fopencookie F
+GLIBC_2.0 fork F
+GLIBC_2.0 forkpty F
+GLIBC_2.0 fpathconf F
+GLIBC_2.0 fprintf F
+GLIBC_2.0 fputc F
+GLIBC_2.0 fputc_unlocked F
+GLIBC_2.0 fputs F
+GLIBC_2.0 fread F
+GLIBC_2.0 free F
+GLIBC_2.0 freeaddrinfo F
+GLIBC_2.0 freopen F
+GLIBC_2.0 frexp F
+GLIBC_2.0 frexpf F
+GLIBC_2.0 frexpl F
+GLIBC_2.0 fscanf F
+GLIBC_2.0 fseek F
+GLIBC_2.0 fsetpos F
+GLIBC_2.0 fstatfs F
+GLIBC_2.0 fsync F
+GLIBC_2.0 ftell F
+GLIBC_2.0 ftime F
+GLIBC_2.0 ftok F
+GLIBC_2.0 ftruncate F
+GLIBC_2.0 ftrylockfile F
+GLIBC_2.0 fts_children F
+GLIBC_2.0 fts_close F
+GLIBC_2.0 fts_open F
+GLIBC_2.0 fts_read F
+GLIBC_2.0 fts_set F
+GLIBC_2.0 ftw F
+GLIBC_2.0 funlockfile F
+GLIBC_2.0 fwrite F
+GLIBC_2.0 gcvt F
+GLIBC_2.0 get_avphys_pages F
+GLIBC_2.0 get_current_dir_name F
+GLIBC_2.0 get_kernel_syms F
+GLIBC_2.0 get_myaddress F
+GLIBC_2.0 get_nprocs F
+GLIBC_2.0 get_nprocs_conf F
+GLIBC_2.0 get_phys_pages F
+GLIBC_2.0 getaddrinfo F
+GLIBC_2.0 getaliasbyname F
+GLIBC_2.0 getaliasbyname_r F
+GLIBC_2.0 getaliasent F
+GLIBC_2.0 getaliasent_r F
+GLIBC_2.0 getc F
+GLIBC_2.0 getc_unlocked F
+GLIBC_2.0 getchar F
+GLIBC_2.0 getchar_unlocked F
+GLIBC_2.0 getcwd F
+GLIBC_2.0 getdelim F
+GLIBC_2.0 getdirentries F
+GLIBC_2.0 getdomainname F
+GLIBC_2.0 getdtablesize F
+GLIBC_2.0 getegid F
+GLIBC_2.0 getenv F
+GLIBC_2.0 geteuid F
+GLIBC_2.0 getfsent F
+GLIBC_2.0 getfsfile F
+GLIBC_2.0 getfsspec F
+GLIBC_2.0 getgid F
+GLIBC_2.0 getgrent F
+GLIBC_2.0 getgrent_r F
+GLIBC_2.0 getgrgid F
+GLIBC_2.0 getgrgid_r F
+GLIBC_2.0 getgrnam F
+GLIBC_2.0 getgrnam_r F
+GLIBC_2.0 getgroups F
+GLIBC_2.0 gethostbyaddr F
+GLIBC_2.0 gethostbyaddr_r F
+GLIBC_2.0 gethostbyname F
+GLIBC_2.0 gethostbyname2 F
+GLIBC_2.0 gethostbyname2_r F
+GLIBC_2.0 gethostbyname_r F
+GLIBC_2.0 gethostent F
+GLIBC_2.0 gethostent_r F
+GLIBC_2.0 gethostid F
+GLIBC_2.0 gethostname F
+GLIBC_2.0 getitimer F
+GLIBC_2.0 getline F
+GLIBC_2.0 getlogin F
+GLIBC_2.0 getlogin_r F
+GLIBC_2.0 getmntent F
+GLIBC_2.0 getmntent_r F
+GLIBC_2.0 getnetbyaddr F
+GLIBC_2.0 getnetbyaddr_r F
+GLIBC_2.0 getnetbyname F
+GLIBC_2.0 getnetbyname_r F
+GLIBC_2.0 getnetent F
+GLIBC_2.0 getnetent_r F
+GLIBC_2.0 getnetgrent F
+GLIBC_2.0 getnetgrent_r F
+GLIBC_2.0 getopt F
+GLIBC_2.0 getopt_long F
+GLIBC_2.0 getopt_long_only F
+GLIBC_2.0 getpagesize F
+GLIBC_2.0 getpass F
+GLIBC_2.0 getpeername F
+GLIBC_2.0 getpgid F
+GLIBC_2.0 getpgrp F
+GLIBC_2.0 getpid F
+GLIBC_2.0 getppid F
+GLIBC_2.0 getpriority F
+GLIBC_2.0 getprotobyname F
+GLIBC_2.0 getprotobyname_r F
+GLIBC_2.0 getprotobynumber F
+GLIBC_2.0 getprotobynumber_r F
+GLIBC_2.0 getprotoent F
+GLIBC_2.0 getprotoent_r F
+GLIBC_2.0 getpublickey F
+GLIBC_2.0 getpw F
+GLIBC_2.0 getpwent F
+GLIBC_2.0 getpwent_r F
+GLIBC_2.0 getpwnam F
+GLIBC_2.0 getpwnam_r F
+GLIBC_2.0 getpwuid F
+GLIBC_2.0 getpwuid_r F
+GLIBC_2.0 getresgid F
+GLIBC_2.0 getresuid F
+GLIBC_2.0 getrlimit F
+GLIBC_2.0 getrpcbyname F
+GLIBC_2.0 getrpcbyname_r F
+GLIBC_2.0 getrpcbynumber F
+GLIBC_2.0 getrpcbynumber_r F
+GLIBC_2.0 getrpcent F
+GLIBC_2.0 getrpcent_r F
+GLIBC_2.0 getrpcport F
+GLIBC_2.0 getrusage F
+GLIBC_2.0 gets F
+GLIBC_2.0 getsecretkey F
+GLIBC_2.0 getservbyname F
+GLIBC_2.0 getservbyname_r F
+GLIBC_2.0 getservbyport F
+GLIBC_2.0 getservbyport_r F
+GLIBC_2.0 getservent F
+GLIBC_2.0 getservent_r F
+GLIBC_2.0 getsid F
+GLIBC_2.0 getsockname F
+GLIBC_2.0 getsockopt F
+GLIBC_2.0 getspent F
+GLIBC_2.0 getspent_r F
+GLIBC_2.0 getspnam F
+GLIBC_2.0 getspnam_r F
+GLIBC_2.0 getsubopt F
+GLIBC_2.0 gettext F
+GLIBC_2.0 gettimeofday F
+GLIBC_2.0 getttyent F
+GLIBC_2.0 getttynam F
+GLIBC_2.0 getuid F
+GLIBC_2.0 getusershell F
+GLIBC_2.0 getutent F
+GLIBC_2.0 getutent_r F
+GLIBC_2.0 getutid F
+GLIBC_2.0 getutid_r F
+GLIBC_2.0 getutline F
+GLIBC_2.0 getutline_r F
+GLIBC_2.0 getw F
+GLIBC_2.0 getwd F
+GLIBC_2.0 glob F
+GLIBC_2.0 glob_pattern_p F
+GLIBC_2.0 globfree F
+GLIBC_2.0 gmtime F
+GLIBC_2.0 gmtime_r F
+GLIBC_2.0 group_member F
+GLIBC_2.0 gsignal F
+GLIBC_2.0 gtty F
+GLIBC_2.0 h_errlist D 0x28
+GLIBC_2.0 h_nerr D 0x4
+GLIBC_2.0 hae_shift F
+GLIBC_2.0 hasmntopt F
+GLIBC_2.0 hcreate F
+GLIBC_2.0 hcreate_r F
+GLIBC_2.0 hdestroy F
+GLIBC_2.0 hdestroy_r F
+GLIBC_2.0 herror F
+GLIBC_2.0 hsearch F
+GLIBC_2.0 hsearch_r F
+GLIBC_2.0 hstrerror F
+GLIBC_2.0 htonl F
+GLIBC_2.0 htons F
+GLIBC_2.0 inb F
+GLIBC_2.0 index F
+GLIBC_2.0 inet_addr F
+GLIBC_2.0 inet_aton F
+GLIBC_2.0 inet_lnaof F
+GLIBC_2.0 inet_makeaddr F
+GLIBC_2.0 inet_netof F
+GLIBC_2.0 inet_network F
+GLIBC_2.0 inet_nsap_addr F
+GLIBC_2.0 inet_nsap_ntoa F
+GLIBC_2.0 inet_ntoa F
+GLIBC_2.0 inet_ntop F
+GLIBC_2.0 inet_pton F
+GLIBC_2.0 init_module F
+GLIBC_2.0 initgroups F
+GLIBC_2.0 initstate F
+GLIBC_2.0 initstate_r F
+GLIBC_2.0 inl F
+GLIBC_2.0 innetgr F
+GLIBC_2.0 insque F
+GLIBC_2.0 inw F
+GLIBC_2.0 ioctl F
+GLIBC_2.0 ioperm F
+GLIBC_2.0 iopl F
+GLIBC_2.0 iruserok F
+GLIBC_2.0 isalnum F
+GLIBC_2.0 isalpha F
+GLIBC_2.0 isascii F
+GLIBC_2.0 isatty F
+GLIBC_2.0 isblank F
+GLIBC_2.0 iscntrl F
+GLIBC_2.0 isdigit F
+GLIBC_2.0 isfdtype F
+GLIBC_2.0 isgraph F
+GLIBC_2.0 isinf F
+GLIBC_2.0 isinff F
+GLIBC_2.0 isinfl F
+GLIBC_2.0 islower F
+GLIBC_2.0 isnan F
+GLIBC_2.0 isnanf F
+GLIBC_2.0 isnanl F
+GLIBC_2.0 isprint F
+GLIBC_2.0 ispunct F
+GLIBC_2.0 isspace F
+GLIBC_2.0 isupper F
+GLIBC_2.0 iswalnum F
+GLIBC_2.0 iswalpha F
+GLIBC_2.0 iswcntrl F
+GLIBC_2.0 iswctype F
+GLIBC_2.0 iswdigit F
+GLIBC_2.0 iswgraph F
+GLIBC_2.0 iswlower F
+GLIBC_2.0 iswprint F
+GLIBC_2.0 iswpunct F
+GLIBC_2.0 iswspace F
+GLIBC_2.0 iswupper F
+GLIBC_2.0 iswxdigit F
+GLIBC_2.0 isxdigit F
+GLIBC_2.0 jrand48 F
+GLIBC_2.0 jrand48_r F
+GLIBC_2.0 kill F
+GLIBC_2.0 killpg F
+GLIBC_2.0 klogctl F
+GLIBC_2.0 l64a F
+GLIBC_2.0 labs F
+GLIBC_2.0 lchown F
+GLIBC_2.0 lckpwdf F
+GLIBC_2.0 lcong48 F
+GLIBC_2.0 lcong48_r F
+GLIBC_2.0 ldexp F
+GLIBC_2.0 ldexpf F
+GLIBC_2.0 ldexpl F
+GLIBC_2.0 ldiv F
+GLIBC_2.0 lfind F
+GLIBC_2.0 link F
+GLIBC_2.0 listen F
+GLIBC_2.0 llabs F
+GLIBC_2.0 lldiv F
+GLIBC_2.0 llseek F
+GLIBC_2.0 loc1 D 0x8
+GLIBC_2.0 loc2 D 0x8
+GLIBC_2.0 localeconv F
+GLIBC_2.0 localtime F
+GLIBC_2.0 localtime_r F
+GLIBC_2.0 lockf F
+GLIBC_2.0 locs D 0x8
+GLIBC_2.0 login F
+GLIBC_2.0 login_tty F
+GLIBC_2.0 logout F
+GLIBC_2.0 logwtmp F
+GLIBC_2.0 longjmp F
+GLIBC_2.0 lrand48 F
+GLIBC_2.0 lrand48_r F
+GLIBC_2.0 lsearch F
+GLIBC_2.0 lseek F
+GLIBC_2.0 madvise F
+GLIBC_2.0 mallinfo F
+GLIBC_2.0 malloc F
+GLIBC_2.0 malloc_stats F
+GLIBC_2.0 malloc_trim F
+GLIBC_2.0 malloc_usable_size F
+GLIBC_2.0 mallopt F
+GLIBC_2.0 mallwatch D 0x8
+GLIBC_2.0 mblen F
+GLIBC_2.0 mbrlen F
+GLIBC_2.0 mbrtowc F
+GLIBC_2.0 mbsinit F
+GLIBC_2.0 mbsnrtowcs F
+GLIBC_2.0 mbsrtowcs F
+GLIBC_2.0 mbstowcs F
+GLIBC_2.0 mbtowc F
+GLIBC_2.0 mcheck F
+GLIBC_2.0 mcount F
+GLIBC_2.0 memalign F
+GLIBC_2.0 memccpy F
+GLIBC_2.0 memchr F
+GLIBC_2.0 memcmp F
+GLIBC_2.0 memcpy F
+GLIBC_2.0 memfrob F
+GLIBC_2.0 memmem F
+GLIBC_2.0 memmove F
+GLIBC_2.0 memset F
+GLIBC_2.0 mkdir F
+GLIBC_2.0 mkfifo F
+GLIBC_2.0 mkstemp F
+GLIBC_2.0 mktemp F
+GLIBC_2.0 mktime F
+GLIBC_2.0 mlock F
+GLIBC_2.0 mlockall F
+GLIBC_2.0 mmap F
+GLIBC_2.0 modf F
+GLIBC_2.0 modff F
+GLIBC_2.0 modfl F
+GLIBC_2.0 monstartup F
+GLIBC_2.0 mount F
+GLIBC_2.0 mprobe F
+GLIBC_2.0 mprotect F
+GLIBC_2.0 mrand48 F
+GLIBC_2.0 mrand48_r F
+GLIBC_2.0 mremap F
+GLIBC_2.0 msgctl F
+GLIBC_2.0 msgget F
+GLIBC_2.0 msgrcv F
+GLIBC_2.0 msgsnd F
+GLIBC_2.0 msync F
+GLIBC_2.0 mtrace F
+GLIBC_2.0 munlock F
+GLIBC_2.0 munlockall F
+GLIBC_2.0 munmap F
+GLIBC_2.0 muntrace F
+GLIBC_2.0 nanosleep F
+GLIBC_2.0 nfsservctl F
+GLIBC_2.0 nice F
+GLIBC_2.0 nl_langinfo F
+GLIBC_2.0 nrand48 F
+GLIBC_2.0 nrand48_r F
+GLIBC_2.0 ntohl F
+GLIBC_2.0 ntohs F
+GLIBC_2.0 obstack_alloc_failed_handler D 0x8
+GLIBC_2.0 obstack_exit_failure D 0x4
+GLIBC_2.0 obstack_free F
+GLIBC_2.0 obstack_printf F
+GLIBC_2.0 obstack_vprintf F
+GLIBC_2.0 on_exit F
+GLIBC_2.0 open F
+GLIBC_2.0 open_memstream F
+GLIBC_2.0 opendir F
+GLIBC_2.0 openlog F
+GLIBC_2.0 openpty F
+GLIBC_2.0 optarg D 0x8
+GLIBC_2.0 opterr D 0x4
+GLIBC_2.0 optind D 0x4
+GLIBC_2.0 optopt D 0x4
+GLIBC_2.0 outb F
+GLIBC_2.0 outl F
+GLIBC_2.0 outw F
+GLIBC_2.0 parse_printf_format F
+GLIBC_2.0 pathconf F
+GLIBC_2.0 pause F
+GLIBC_2.0 pciconfig_read F
+GLIBC_2.0 pciconfig_write F
+GLIBC_2.0 pclose F
+GLIBC_2.0 perror F
+GLIBC_2.0 personality F
+GLIBC_2.0 pipe F
+GLIBC_2.0 pmap_getmaps F
+GLIBC_2.0 pmap_getport F
+GLIBC_2.0 pmap_rmtcall F
+GLIBC_2.0 pmap_set F
+GLIBC_2.0 pmap_unset F
+GLIBC_2.0 poll F
+GLIBC_2.0 popen F
+GLIBC_2.0 prctl F
+GLIBC_2.0 printf F
+GLIBC_2.0 profil F
+GLIBC_2.0 program_invocation_name D 0x8
+GLIBC_2.0 program_invocation_short_name D 0x8
+GLIBC_2.0 pselect F
+GLIBC_2.0 psignal F
+GLIBC_2.0 pthread_atfork F
+GLIBC_2.0 pthread_attr_destroy F
+GLIBC_2.0 pthread_attr_getdetachstate F
+GLIBC_2.0 pthread_attr_getinheritsched F
+GLIBC_2.0 pthread_attr_getschedparam F
+GLIBC_2.0 pthread_attr_getschedpolicy F
+GLIBC_2.0 pthread_attr_getscope F
+GLIBC_2.0 pthread_attr_init F
+GLIBC_2.0 pthread_attr_setdetachstate F
+GLIBC_2.0 pthread_attr_setinheritsched F
+GLIBC_2.0 pthread_attr_setschedparam F
+GLIBC_2.0 pthread_attr_setschedpolicy F
+GLIBC_2.0 pthread_attr_setscope F
+GLIBC_2.0 pthread_cancel F
+GLIBC_2.0 pthread_cond_broadcast F
+GLIBC_2.0 pthread_cond_destroy F
+GLIBC_2.0 pthread_cond_init F
+GLIBC_2.0 pthread_cond_signal F
+GLIBC_2.0 pthread_cond_timedwait F
+GLIBC_2.0 pthread_cond_wait F
+GLIBC_2.0 pthread_condattr_destroy F
+GLIBC_2.0 pthread_condattr_init F
+GLIBC_2.0 pthread_create F
+GLIBC_2.0 pthread_detach F
+GLIBC_2.0 pthread_equal F
+GLIBC_2.0 pthread_exit F
+GLIBC_2.0 pthread_getschedparam F
+GLIBC_2.0 pthread_getspecific F
+GLIBC_2.0 pthread_join F
+GLIBC_2.0 pthread_key_create F
+GLIBC_2.0 pthread_key_delete F
+GLIBC_2.0 pthread_kill F
+GLIBC_2.0 pthread_kill_other_threads_np F
+GLIBC_2.0 pthread_mutex_destroy F
+GLIBC_2.0 pthread_mutex_init F
+GLIBC_2.0 pthread_mutex_lock F
+GLIBC_2.0 pthread_mutex_trylock F
+GLIBC_2.0 pthread_mutex_unlock F
+GLIBC_2.0 pthread_mutexattr_destroy F
+GLIBC_2.0 pthread_mutexattr_getkind_np F
+GLIBC_2.0 pthread_mutexattr_init F
+GLIBC_2.0 pthread_mutexattr_setkind_np F
+GLIBC_2.0 pthread_once F
+GLIBC_2.0 pthread_self F
+GLIBC_2.0 pthread_setcancelstate F
+GLIBC_2.0 pthread_setcanceltype F
+GLIBC_2.0 pthread_setschedparam F
+GLIBC_2.0 pthread_setspecific F
+GLIBC_2.0 pthread_sigmask F
+GLIBC_2.0 pthread_testcancel F
+GLIBC_2.0 ptrace F
+GLIBC_2.0 putc F
+GLIBC_2.0 putc_unlocked F
+GLIBC_2.0 putchar F
+GLIBC_2.0 putchar_unlocked F
+GLIBC_2.0 putenv F
+GLIBC_2.0 putpwent F
+GLIBC_2.0 puts F
+GLIBC_2.0 putspent F
+GLIBC_2.0 pututline F
+GLIBC_2.0 putw F
+GLIBC_2.0 pvalloc F
+GLIBC_2.0 qecvt F
+GLIBC_2.0 qecvt_r F
+GLIBC_2.0 qfcvt F
+GLIBC_2.0 qfcvt_r F
+GLIBC_2.0 qgcvt F
+GLIBC_2.0 qsort F
+GLIBC_2.0 query_module F
+GLIBC_2.0 quotactl F
+GLIBC_2.0 raise F
+GLIBC_2.0 rand F
+GLIBC_2.0 rand_r F
+GLIBC_2.0 random F
+GLIBC_2.0 random_r F
+GLIBC_2.0 rcmd F
+GLIBC_2.0 re_comp F
+GLIBC_2.0 re_compile_fastmap F
+GLIBC_2.0 re_compile_pattern F
+GLIBC_2.0 re_exec F
+GLIBC_2.0 re_match F
+GLIBC_2.0 re_match_2 F
+GLIBC_2.0 re_max_failures D 0x4
+GLIBC_2.0 re_search F
+GLIBC_2.0 re_search_2 F
+GLIBC_2.0 re_set_registers F
+GLIBC_2.0 re_set_syntax F
+GLIBC_2.0 re_syntax_options D 0x8
+GLIBC_2.0 read F
+GLIBC_2.0 readdir F
+GLIBC_2.0 readdir_r F
+GLIBC_2.0 readlink F
+GLIBC_2.0 readv F
+GLIBC_2.0 realloc F
+GLIBC_2.0 realpath F
+GLIBC_2.0 reboot F
+GLIBC_2.0 recv F
+GLIBC_2.0 recvfrom F
+GLIBC_2.0 recvmsg F
+GLIBC_2.0 regcomp F
+GLIBC_2.0 regerror F
+GLIBC_2.0 regexec F
+GLIBC_2.0 regfree F
+GLIBC_2.0 register_printf_function F
+GLIBC_2.0 registerrpc F
+GLIBC_2.0 remove F
+GLIBC_2.0 remque F
+GLIBC_2.0 rename F
+GLIBC_2.0 res_init F
+GLIBC_2.0 res_mkquery F
+GLIBC_2.0 res_query F
+GLIBC_2.0 res_querydomain F
+GLIBC_2.0 res_search F
+GLIBC_2.0 revoke F
+GLIBC_2.0 rewind F
+GLIBC_2.0 rewinddir F
+GLIBC_2.0 rexec F
+GLIBC_2.0 rexecoptions D 0x4
+GLIBC_2.0 rindex F
+GLIBC_2.0 rmdir F
+GLIBC_2.0 rpc_createerr D 0x20
+GLIBC_2.0 rpmatch F
+GLIBC_2.0 rresvport F
+GLIBC_2.0 ruserok F
+GLIBC_2.0 ruserpass F
+GLIBC_2.0 sbrk F
+GLIBC_2.0 scalbn F
+GLIBC_2.0 scalbnf F
+GLIBC_2.0 scalbnl F
+GLIBC_2.0 scandir F
+GLIBC_2.0 scanf F
+GLIBC_2.0 sched_get_priority_max F
+GLIBC_2.0 sched_get_priority_min F
+GLIBC_2.0 sched_getparam F
+GLIBC_2.0 sched_getscheduler F
+GLIBC_2.0 sched_rr_get_interval F
+GLIBC_2.0 sched_setparam F
+GLIBC_2.0 sched_setscheduler F
+GLIBC_2.0 sched_yield F
+GLIBC_2.0 seed48 F
+GLIBC_2.0 seed48_r F
+GLIBC_2.0 seekdir F
+GLIBC_2.0 select F
+GLIBC_2.0 sem_destroy F
+GLIBC_2.0 sem_getvalue F
+GLIBC_2.0 sem_init F
+GLIBC_2.0 sem_post F
+GLIBC_2.0 sem_trywait F
+GLIBC_2.0 sem_wait F
+GLIBC_2.0 semctl F
+GLIBC_2.0 semget F
+GLIBC_2.0 semop F
+GLIBC_2.0 send F
+GLIBC_2.0 sendmsg F
+GLIBC_2.0 sendto F
+GLIBC_2.0 setaliasent F
+GLIBC_2.0 setbuf F
+GLIBC_2.0 setbuffer F
+GLIBC_2.0 setcontext F
+GLIBC_2.0 setdomainname F
+GLIBC_2.0 setegid F
+GLIBC_2.0 setenv F
+GLIBC_2.0 seteuid F
+GLIBC_2.0 setfsent F
+GLIBC_2.0 setfsgid F
+GLIBC_2.0 setfsuid F
+GLIBC_2.0 setgid F
+GLIBC_2.0 setgrent F
+GLIBC_2.0 setgroups F
+GLIBC_2.0 sethae F
+GLIBC_2.0 sethostent F
+GLIBC_2.0 sethostid F
+GLIBC_2.0 sethostname F
+GLIBC_2.0 setitimer F
+GLIBC_2.0 setjmp F
+GLIBC_2.0 setlinebuf F
+GLIBC_2.0 setlocale F
+GLIBC_2.0 setlogin F
+GLIBC_2.0 setlogmask F
+GLIBC_2.0 setmntent F
+GLIBC_2.0 setnetent F
+GLIBC_2.0 setnetgrent F
+GLIBC_2.0 setpgid F
+GLIBC_2.0 setpgrp F
+GLIBC_2.0 setpriority F
+GLIBC_2.0 setprotoent F
+GLIBC_2.0 setpwent F
+GLIBC_2.0 setregid F
+GLIBC_2.0 setresgid F
+GLIBC_2.0 setresuid F
+GLIBC_2.0 setreuid F
+GLIBC_2.0 setrlimit F
+GLIBC_2.0 setrpcent F
+GLIBC_2.0 setservent F
+GLIBC_2.0 setsid F
+GLIBC_2.0 setsockopt F
+GLIBC_2.0 setspent F
+GLIBC_2.0 setstate F
+GLIBC_2.0 setstate_r F
+GLIBC_2.0 settimeofday F
+GLIBC_2.0 setttyent F
+GLIBC_2.0 setuid F
+GLIBC_2.0 setusershell F
+GLIBC_2.0 setutent F
+GLIBC_2.0 setvbuf F
+GLIBC_2.0 sgetspent F
+GLIBC_2.0 sgetspent_r F
+GLIBC_2.0 shmat F
+GLIBC_2.0 shmctl F
+GLIBC_2.0 shmdt F
+GLIBC_2.0 shmget F
+GLIBC_2.0 shutdown F
+GLIBC_2.0 sigaction F
+GLIBC_2.0 sigaddset F
+GLIBC_2.0 sigaltstack F
+GLIBC_2.0 sigandset F
+GLIBC_2.0 sigblock F
+GLIBC_2.0 sigdelset F
+GLIBC_2.0 sigemptyset F
+GLIBC_2.0 sigfillset F
+GLIBC_2.0 siggetmask F
+GLIBC_2.0 siginterrupt F
+GLIBC_2.0 sigisemptyset F
+GLIBC_2.0 sigismember F
+GLIBC_2.0 siglongjmp F
+GLIBC_2.0 signal F
+GLIBC_2.0 sigorset F
+GLIBC_2.0 sigpause F
+GLIBC_2.0 sigpending F
+GLIBC_2.0 sigprocmask F
+GLIBC_2.0 sigreturn F
+GLIBC_2.0 sigsetmask F
+GLIBC_2.0 sigstack F
+GLIBC_2.0 sigsuspend F
+GLIBC_2.0 sigvec F
+GLIBC_2.0 sigwait F
+GLIBC_2.0 sleep F
+GLIBC_2.0 snprintf F
+GLIBC_2.0 socket F
+GLIBC_2.0 socketpair F
+GLIBC_2.0 sprintf F
+GLIBC_2.0 srand F
+GLIBC_2.0 srand48 F
+GLIBC_2.0 srand48_r F
+GLIBC_2.0 srandom F
+GLIBC_2.0 srandom_r F
+GLIBC_2.0 sscanf F
+GLIBC_2.0 ssignal F
+GLIBC_2.0 sstk F
+GLIBC_2.0 statfs F
+GLIBC_2.0 stderr D 0x8
+GLIBC_2.0 stdin D 0x8
+GLIBC_2.0 stdout D 0x8
+GLIBC_2.0 step F
+GLIBC_2.0 stime F
+GLIBC_2.0 stpcpy F
+GLIBC_2.0 stpncpy F
+GLIBC_2.0 strcasecmp F
+GLIBC_2.0 strcat F
+GLIBC_2.0 strchr F
+GLIBC_2.0 strcmp F
+GLIBC_2.0 strcoll F
+GLIBC_2.0 strcpy F
+GLIBC_2.0 strcspn F
+GLIBC_2.0 strdup F
+GLIBC_2.0 strerror F
+GLIBC_2.0 strerror_r F
+GLIBC_2.0 strfmon F
+GLIBC_2.0 strfry F
+GLIBC_2.0 strftime F
+GLIBC_2.0 strlen F
+GLIBC_2.0 strncasecmp F
+GLIBC_2.0 strncat F
+GLIBC_2.0 strncmp F
+GLIBC_2.0 strncpy F
+GLIBC_2.0 strndup F
+GLIBC_2.0 strnlen F
+GLIBC_2.0 strpbrk F
+GLIBC_2.0 strptime F
+GLIBC_2.0 strrchr F
+GLIBC_2.0 strsep F
+GLIBC_2.0 strsignal F
+GLIBC_2.0 strspn F
+GLIBC_2.0 strstr F
+GLIBC_2.0 strtod F
+GLIBC_2.0 strtof F
+GLIBC_2.0 strtok F
+GLIBC_2.0 strtok_r F
+GLIBC_2.0 strtol F
+GLIBC_2.0 strtold F
+GLIBC_2.0 strtoll F
+GLIBC_2.0 strtoq F
+GLIBC_2.0 strtoul F
+GLIBC_2.0 strtoull F
+GLIBC_2.0 strtouq F
+GLIBC_2.0 strxfrm F
+GLIBC_2.0 stty F
+GLIBC_2.0 svc_exit F
+GLIBC_2.0 svc_fdset D 0x80
+GLIBC_2.0 svc_getreq F
+GLIBC_2.0 svc_getreqset F
+GLIBC_2.0 svc_register F
+GLIBC_2.0 svc_run F
+GLIBC_2.0 svc_sendreply F
+GLIBC_2.0 svc_unregister F
+GLIBC_2.0 svcauthdes_stats D 0x18
+GLIBC_2.0 svcerr_auth F
+GLIBC_2.0 svcerr_decode F
+GLIBC_2.0 svcerr_noproc F
+GLIBC_2.0 svcerr_noprog F
+GLIBC_2.0 svcerr_progvers F
+GLIBC_2.0 svcerr_systemerr F
+GLIBC_2.0 svcerr_weakauth F
+GLIBC_2.0 svcfd_create F
+GLIBC_2.0 svcraw_create F
+GLIBC_2.0 svctcp_create F
+GLIBC_2.0 svcudp_bufcreate F
+GLIBC_2.0 svcudp_create F
+GLIBC_2.0 svcudp_enablecache F
+GLIBC_2.0 swab F
+GLIBC_2.0 swapoff F
+GLIBC_2.0 swapon F
+GLIBC_2.0 symlink F
+GLIBC_2.0 sync F
+GLIBC_2.0 sys_errlist D 0x3d8
+GLIBC_2.0 sys_nerr D 0x4
+GLIBC_2.0 sys_sigabbrev D 0x100
+GLIBC_2.0 sys_siglist D 0x100
+GLIBC_2.0 syscall F
+GLIBC_2.0 sysconf F
+GLIBC_2.0 sysctl F
+GLIBC_2.0 sysinfo F
+GLIBC_2.0 syslog F
+GLIBC_2.0 system F
+GLIBC_2.0 tcdrain F
+GLIBC_2.0 tcflow F
+GLIBC_2.0 tcflush F
+GLIBC_2.0 tcgetattr F
+GLIBC_2.0 tcgetpgrp F
+GLIBC_2.0 tcsendbreak F
+GLIBC_2.0 tcsetattr F
+GLIBC_2.0 tcsetpgrp F
+GLIBC_2.0 tdelete F
+GLIBC_2.0 telldir F
+GLIBC_2.0 tempnam F
+GLIBC_2.0 textdomain F
+GLIBC_2.0 tfind F
+GLIBC_2.0 time F
+GLIBC_2.0 timegm F
+GLIBC_2.0 timelocal F
+GLIBC_2.0 times F
+GLIBC_2.0 timezone D 0x8
+GLIBC_2.0 tmpfile F
+GLIBC_2.0 tmpnam F
+GLIBC_2.0 tmpnam_r F
+GLIBC_2.0 toascii F
+GLIBC_2.0 tolower F
+GLIBC_2.0 toupper F
+GLIBC_2.0 towctrans F
+GLIBC_2.0 towlower F
+GLIBC_2.0 towupper F
+GLIBC_2.0 tr_break F
+GLIBC_2.0 truncate F
+GLIBC_2.0 tsearch F
+GLIBC_2.0 ttyname F
+GLIBC_2.0 ttyname_r F
+GLIBC_2.0 ttyslot F
+GLIBC_2.0 twalk F
+GLIBC_2.0 tzname D 0x10
+GLIBC_2.0 tzset F
+GLIBC_2.0 ualarm F
+GLIBC_2.0 ulckpwdf F
+GLIBC_2.0 ulimit F
+GLIBC_2.0 umask F
+GLIBC_2.0 umount F
+GLIBC_2.0 uname F
+GLIBC_2.0 ungetc F
+GLIBC_2.0 unlink F
+GLIBC_2.0 unsetenv F
+GLIBC_2.0 updwtmp F
+GLIBC_2.0 uselib F
+GLIBC_2.0 usleep F
+GLIBC_2.0 ustat F
+GLIBC_2.0 utime F
+GLIBC_2.0 utimes F
+GLIBC_2.0 utmpname F
+GLIBC_2.0 valloc F
+GLIBC_2.0 vasprintf F
+GLIBC_2.0 vdprintf F
+GLIBC_2.0 verr F
+GLIBC_2.0 verrx F
+GLIBC_2.0 vfork F
+GLIBC_2.0 vfprintf F
+GLIBC_2.0 vfscanf F
+GLIBC_2.0 vhangup F
+GLIBC_2.0 vlimit F
+GLIBC_2.0 vprintf F
+GLIBC_2.0 vscanf F
+GLIBC_2.0 vsnprintf F
+GLIBC_2.0 vsprintf F
+GLIBC_2.0 vsscanf F
+GLIBC_2.0 vsyslog F
+GLIBC_2.0 vtimes F
+GLIBC_2.0 vwarn F
+GLIBC_2.0 vwarnx F
+GLIBC_2.0 wait F
+GLIBC_2.0 wait3 F
+GLIBC_2.0 wait4 F
+GLIBC_2.0 waitpid F
+GLIBC_2.0 warn F
+GLIBC_2.0 warnx F
+GLIBC_2.0 wcpcpy F
+GLIBC_2.0 wcpncpy F
+GLIBC_2.0 wcrtomb F
+GLIBC_2.0 wcscat F
+GLIBC_2.0 wcschr F
+GLIBC_2.0 wcscmp F
+GLIBC_2.0 wcscoll F
+GLIBC_2.0 wcscpy F
+GLIBC_2.0 wcscspn F
+GLIBC_2.0 wcsdup F
+GLIBC_2.0 wcslen F
+GLIBC_2.0 wcsncat F
+GLIBC_2.0 wcsncmp F
+GLIBC_2.0 wcsncpy F
+GLIBC_2.0 wcsnrtombs F
+GLIBC_2.0 wcspbrk F
+GLIBC_2.0 wcsrchr F
+GLIBC_2.0 wcsrtombs F
+GLIBC_2.0 wcsspn F
+GLIBC_2.0 wcsstr F
+GLIBC_2.0 wcstod F
+GLIBC_2.0 wcstof F
+GLIBC_2.0 wcstok F
+GLIBC_2.0 wcstol F
+GLIBC_2.0 wcstold F
+GLIBC_2.0 wcstombs F
+GLIBC_2.0 wcstoq F
+GLIBC_2.0 wcstoul F
+GLIBC_2.0 wcstouq F
+GLIBC_2.0 wcswidth F
+GLIBC_2.0 wcsxfrm F
+GLIBC_2.0 wctob F
+GLIBC_2.0 wctomb F
+GLIBC_2.0 wctrans F
+GLIBC_2.0 wctype F
+GLIBC_2.0 wcwidth F
+GLIBC_2.0 wmemchr F
+GLIBC_2.0 wmemcmp F
+GLIBC_2.0 wmemcpy F
+GLIBC_2.0 wmemmove F
+GLIBC_2.0 wmemset F
+GLIBC_2.0 write F
+GLIBC_2.0 writev F
+GLIBC_2.0 xdr_accepted_reply F
+GLIBC_2.0 xdr_array F
+GLIBC_2.0 xdr_authunix_parms F
+GLIBC_2.0 xdr_bool F
+GLIBC_2.0 xdr_bytes F
+GLIBC_2.0 xdr_callhdr F
+GLIBC_2.0 xdr_callmsg F
+GLIBC_2.0 xdr_char F
+GLIBC_2.0 xdr_cryptkeyarg F
+GLIBC_2.0 xdr_cryptkeyarg2 F
+GLIBC_2.0 xdr_cryptkeyres F
+GLIBC_2.0 xdr_des_block F
+GLIBC_2.0 xdr_double F
+GLIBC_2.0 xdr_enum F
+GLIBC_2.0 xdr_float F
+GLIBC_2.0 xdr_free F
+GLIBC_2.0 xdr_int F
+GLIBC_2.0 xdr_key_netstarg F
+GLIBC_2.0 xdr_key_netstres F
+GLIBC_2.0 xdr_keybuf F
+GLIBC_2.0 xdr_keystatus F
+GLIBC_2.0 xdr_long F
+GLIBC_2.0 xdr_netobj F
+GLIBC_2.0 xdr_opaque F
+GLIBC_2.0 xdr_opaque_auth F
+GLIBC_2.0 xdr_pmap F
+GLIBC_2.0 xdr_pmaplist F
+GLIBC_2.0 xdr_pointer F
+GLIBC_2.0 xdr_reference F
+GLIBC_2.0 xdr_rejected_reply F
+GLIBC_2.0 xdr_replymsg F
+GLIBC_2.0 xdr_rmtcall_args F
+GLIBC_2.0 xdr_rmtcallres F
+GLIBC_2.0 xdr_short F
+GLIBC_2.0 xdr_string F
+GLIBC_2.0 xdr_u_char F
+GLIBC_2.0 xdr_u_int F
+GLIBC_2.0 xdr_u_long F
+GLIBC_2.0 xdr_u_short F
+GLIBC_2.0 xdr_union F
+GLIBC_2.0 xdr_vector F
+GLIBC_2.0 xdr_void F
+GLIBC_2.0 xdr_wrapstring F
+GLIBC_2.0 xdrmem_create F
+GLIBC_2.0 xdrrec_create F
+GLIBC_2.0 xdrrec_endofrecord F
+GLIBC_2.0 xdrrec_eof F
+GLIBC_2.0 xdrrec_skiprecord F
+GLIBC_2.0 xdrstdio_create F
+GLIBC_2.0 xencrypt F
+GLIBC_2.0 xprt_register F
+GLIBC_2.0 xprt_unregister F
+GLIBC_2.1 _IO_2_1_stderr_ D 0xe0
+GLIBC_2.1 _IO_2_1_stdin_ D 0xe0
+GLIBC_2.1 _IO_2_1_stdout_ D 0xe0
+GLIBC_2.1 _IO_do_write F
+GLIBC_2.1 _IO_fclose F
+GLIBC_2.1 _IO_fdopen F
+GLIBC_2.1 _IO_fgetpos64 F
+GLIBC_2.1 _IO_file_attach F
+GLIBC_2.1 _IO_file_close_it F
+GLIBC_2.1 _IO_file_finish F
+GLIBC_2.1 _IO_file_fopen F
+GLIBC_2.1 _IO_file_init F
+GLIBC_2.1 _IO_file_overflow F
+GLIBC_2.1 _IO_file_seekoff F
+GLIBC_2.1 _IO_file_setbuf F
+GLIBC_2.1 _IO_file_sync F
+GLIBC_2.1 _IO_file_underflow F
+GLIBC_2.1 _IO_file_write F
+GLIBC_2.1 _IO_file_xsputn F
+GLIBC_2.1 _IO_fopen F
+GLIBC_2.1 _IO_fsetpos64 F
+GLIBC_2.1 _IO_getline_info F
+GLIBC_2.1 _IO_popen F
+GLIBC_2.1 _IO_proc_close F
+GLIBC_2.1 _IO_proc_open F
+GLIBC_2.1 __adjtimex F
+GLIBC_2.1 __asprintf F
+GLIBC_2.1 __backtrace F
+GLIBC_2.1 __backtrace_symbols F
+GLIBC_2.1 __backtrace_symbols_fd F
+GLIBC_2.1 __duplocale F
+GLIBC_2.1 __freelocale F
+GLIBC_2.1 __fxstat64 F
+GLIBC_2.1 __gettimeofday F
+GLIBC_2.1 __isalnum_l F
+GLIBC_2.1 __isalpha_l F
+GLIBC_2.1 __isascii_l F
+GLIBC_2.1 __isblank_l F
+GLIBC_2.1 __iscntrl_l F
+GLIBC_2.1 __isdigit_l F
+GLIBC_2.1 __isgraph_l F
+GLIBC_2.1 __islower_l F
+GLIBC_2.1 __isprint_l F
+GLIBC_2.1 __ispunct_l F
+GLIBC_2.1 __isspace_l F
+GLIBC_2.1 __isupper_l F
+GLIBC_2.1 __iswalnum_l F
+GLIBC_2.1 __iswalpha_l F
+GLIBC_2.1 __iswblank_l F
+GLIBC_2.1 __iswcntrl_l F
+GLIBC_2.1 __iswctype_l F
+GLIBC_2.1 __iswdigit_l F
+GLIBC_2.1 __iswgraph_l F
+GLIBC_2.1 __iswlower_l F
+GLIBC_2.1 __iswprint_l F
+GLIBC_2.1 __iswpunct_l F
+GLIBC_2.1 __iswspace_l F
+GLIBC_2.1 __iswupper_l F
+GLIBC_2.1 __iswxdigit_l F
+GLIBC_2.1 __isxdigit_l F
+GLIBC_2.1 __key_decryptsession_pk_LOCAL D 0x8
+GLIBC_2.1 __key_encryptsession_pk_LOCAL D 0x8
+GLIBC_2.1 __key_gendes_LOCAL D 0x8
+GLIBC_2.1 __libc_allocate_rtsig F
+GLIBC_2.1 __libc_current_sigrtmax F
+GLIBC_2.1 __libc_current_sigrtmin F
+GLIBC_2.1 __libc_freeres F
+GLIBC_2.1 __libc_sa_len F
+GLIBC_2.1 __lxstat64 F
+GLIBC_2.1 __newlocale F
+GLIBC_2.1 __poll F
+GLIBC_2.1 __pread64 F
+GLIBC_2.1 __pwrite64 F
+GLIBC_2.1 __rawmemchr F
+GLIBC_2.1 __select F
+GLIBC_2.1 __signbit F
+GLIBC_2.1 __signbitf F
+GLIBC_2.1 __strcasecmp_l F
+GLIBC_2.1 __strcasestr F
+GLIBC_2.1 __strcoll_l F
+GLIBC_2.1 __strfmon_l F
+GLIBC_2.1 __strncasecmp_l F
+GLIBC_2.1 __strtod_l F
+GLIBC_2.1 __strtof_l F
+GLIBC_2.1 __strtol_l F
+GLIBC_2.1 __strtold_l F
+GLIBC_2.1 __strtoll_l F
+GLIBC_2.1 __strtoul_l F
+GLIBC_2.1 __strtoull_l F
+GLIBC_2.1 __strxfrm_l F
+GLIBC_2.1 __toascii_l F
+GLIBC_2.1 __tolower_l F
+GLIBC_2.1 __toupper_l F
+GLIBC_2.1 __towctrans F
+GLIBC_2.1 __towctrans_l F
+GLIBC_2.1 __towlower_l F
+GLIBC_2.1 __towupper_l F
+GLIBC_2.1 __wcscasecmp_l F
+GLIBC_2.1 __wcscoll_l F
+GLIBC_2.1 __wcsncasecmp_l F
+GLIBC_2.1 __wcstod_l F
+GLIBC_2.1 __wcstof_l F
+GLIBC_2.1 __wcstol_l F
+GLIBC_2.1 __wcstold_l F
+GLIBC_2.1 __wcstoll_l F
+GLIBC_2.1 __wcstoul_l F
+GLIBC_2.1 __wcstoull_l F
+GLIBC_2.1 __wcsxfrm_l F
+GLIBC_2.1 __wctype_l F
+GLIBC_2.1 __xstat64 F
+GLIBC_2.1 _authenticate F
+GLIBC_2.1 _dl_mcount_wrapper F
+GLIBC_2.1 _dl_mcount_wrapper_check F
+GLIBC_2.1 _sys_errlist D 0x3e8
+GLIBC_2.1 _sys_nerr D 0x4
+GLIBC_2.1 _sys_siglist D 0x200
+GLIBC_2.1 addseverity F
+GLIBC_2.1 adjtime F
+GLIBC_2.1 adjtimex F
+GLIBC_2.1 aio_cancel F
+GLIBC_2.1 aio_cancel64 F
+GLIBC_2.1 aio_error F
+GLIBC_2.1 aio_error64 F
+GLIBC_2.1 aio_fsync F
+GLIBC_2.1 aio_fsync64 F
+GLIBC_2.1 aio_init F
+GLIBC_2.1 aio_read F
+GLIBC_2.1 aio_read64 F
+GLIBC_2.1 aio_return F
+GLIBC_2.1 aio_return64 F
+GLIBC_2.1 aio_suspend F
+GLIBC_2.1 aio_suspend64 F
+GLIBC_2.1 aio_write F
+GLIBC_2.1 aio_write64 F
+GLIBC_2.1 alphasort64 F
+GLIBC_2.1 argp_err_exit_status D 0x4
+GLIBC_2.1 argp_error F
+GLIBC_2.1 argp_failure F
+GLIBC_2.1 argp_help F
+GLIBC_2.1 argp_parse F
+GLIBC_2.1 argp_program_bug_address D 0x8
+GLIBC_2.1 argp_program_version D 0x8
+GLIBC_2.1 argp_program_version_hook D 0x8
+GLIBC_2.1 argp_state_help F
+GLIBC_2.1 argp_usage F
+GLIBC_2.1 authdes_create F
+GLIBC_2.1 authdes_getucred F
+GLIBC_2.1 authdes_pk_create F
+GLIBC_2.1 backtrace F
+GLIBC_2.1 backtrace_symbols F
+GLIBC_2.1 backtrace_symbols_fd F
+GLIBC_2.1 capget F
+GLIBC_2.1 capset F
+GLIBC_2.1 cbc_crypt F
+GLIBC_2.1 clntunix_create F
+GLIBC_2.1 creat64 F
+GLIBC_2.1 des_setparity F
+GLIBC_2.1 dlopen F
+GLIBC_2.1 dlvsym F
+GLIBC_2.1 ecb_crypt F
+GLIBC_2.1 endutxent F
+GLIBC_2.1 fattach F
+GLIBC_2.1 fclose F
+GLIBC_2.1 fdetach F
+GLIBC_2.1 fdopen F
+GLIBC_2.1 ffsl F
+GLIBC_2.1 ffsll F
+GLIBC_2.1 fgetc_unlocked F
+GLIBC_2.1 fgetpos64 F
+GLIBC_2.1 fgets_unlocked F
+GLIBC_2.1 fmtmsg F
+GLIBC_2.1 fopen F
+GLIBC_2.1 fopen64 F
+GLIBC_2.1 fputs_unlocked F
+GLIBC_2.1 fread_unlocked F
+GLIBC_2.1 freopen64 F
+GLIBC_2.1 fseeko F
+GLIBC_2.1 fseeko64 F
+GLIBC_2.1 fsetpos64 F
+GLIBC_2.1 fstatfs64 F
+GLIBC_2.1 fstatvfs F
+GLIBC_2.1 fstatvfs64 F
+GLIBC_2.1 ftello F
+GLIBC_2.1 ftello64 F
+GLIBC_2.1 ftruncate64 F
+GLIBC_2.1 ftw64 F
+GLIBC_2.1 fwrite_unlocked F
+GLIBC_2.1 gai_strerror F
+GLIBC_2.1 getcontext F
+GLIBC_2.1 getdate F
+GLIBC_2.1 getdate_err D 0x4
+GLIBC_2.1 getdate_r F
+GLIBC_2.1 getitimer F
+GLIBC_2.1 getmsg F
+GLIBC_2.1 getnameinfo F
+GLIBC_2.1 getnetname F
+GLIBC_2.1 getpmsg F
+GLIBC_2.1 getpt F
+GLIBC_2.1 getrlimit64 F
+GLIBC_2.1 getrusage F
+GLIBC_2.1 gettimeofday F
+GLIBC_2.1 getutxent F
+GLIBC_2.1 getutxid F
+GLIBC_2.1 getutxline F
+GLIBC_2.1 glob F
+GLIBC_2.1 glob64 F
+GLIBC_2.1 globfree F
+GLIBC_2.1 globfree64 F
+GLIBC_2.1 gnu_get_libc_release F
+GLIBC_2.1 gnu_get_libc_version F
+GLIBC_2.1 grantpt F
+GLIBC_2.1 host2netname F
+GLIBC_2.1 iconv F
+GLIBC_2.1 iconv_close F
+GLIBC_2.1 iconv_open F
+GLIBC_2.1 ieee_get_fp_control F
+GLIBC_2.1 ieee_set_fp_control F
+GLIBC_2.1 if_freenameindex F
+GLIBC_2.1 if_indextoname F
+GLIBC_2.1 if_nameindex F
+GLIBC_2.1 if_nametoindex F
+GLIBC_2.1 in6addr_any D 0x10
+GLIBC_2.1 in6addr_loopback D 0x10
+GLIBC_2.1 isastream F
+GLIBC_2.1 iswblank F
+GLIBC_2.1 key_decryptsession F
+GLIBC_2.1 key_decryptsession_pk F
+GLIBC_2.1 key_encryptsession F
+GLIBC_2.1 key_encryptsession_pk F
+GLIBC_2.1 key_gendes F
+GLIBC_2.1 key_get_conv F
+GLIBC_2.1 key_secretkey_is_set F
+GLIBC_2.1 key_setnet F
+GLIBC_2.1 key_setsecret F
+GLIBC_2.1 lio_listio F
+GLIBC_2.1 lio_listio64 F
+GLIBC_2.1 lockf64 F
+GLIBC_2.1 lseek64 F
+GLIBC_2.1 makecontext F
+GLIBC_2.1 mempcpy F
+GLIBC_2.1 mmap64 F
+GLIBC_2.1 netname2host F
+GLIBC_2.1 netname2user F
+GLIBC_2.1 nftw F
+GLIBC_2.1 nftw64 F
+GLIBC_2.1 ntp_adjtime F
+GLIBC_2.1 ntp_gettime F
+GLIBC_2.1 open64 F
+GLIBC_2.1 passwd2des F
+GLIBC_2.1 pclose F
+GLIBC_2.1 popen F
+GLIBC_2.1 pread F
+GLIBC_2.1 pread64 F
+GLIBC_2.1 printf_size F
+GLIBC_2.1 printf_size_info F
+GLIBC_2.1 pthread_attr_getguardsize F
+GLIBC_2.1 pthread_attr_getstackaddr F
+GLIBC_2.1 pthread_attr_getstacksize F
+GLIBC_2.1 pthread_attr_init F
+GLIBC_2.1 pthread_attr_setguardsize F
+GLIBC_2.1 pthread_attr_setstackaddr F
+GLIBC_2.1 pthread_attr_setstacksize F
+GLIBC_2.1 pthread_create F
+GLIBC_2.1 pthread_getconcurrency F
+GLIBC_2.1 pthread_mutexattr_gettype F
+GLIBC_2.1 pthread_mutexattr_settype F
+GLIBC_2.1 pthread_rwlock_destroy F
+GLIBC_2.1 pthread_rwlock_init F
+GLIBC_2.1 pthread_rwlock_rdlock F
+GLIBC_2.1 pthread_rwlock_tryrdlock F
+GLIBC_2.1 pthread_rwlock_trywrlock F
+GLIBC_2.1 pthread_rwlock_unlock F
+GLIBC_2.1 pthread_rwlock_wrlock F
+GLIBC_2.1 pthread_rwlockattr_destroy F
+GLIBC_2.1 pthread_rwlockattr_getkind_np F
+GLIBC_2.1 pthread_rwlockattr_getpshared F
+GLIBC_2.1 pthread_rwlockattr_init F
+GLIBC_2.1 pthread_rwlockattr_setkind_np F
+GLIBC_2.1 pthread_rwlockattr_setpshared F
+GLIBC_2.1 pthread_setconcurrency F
+GLIBC_2.1 ptsname F
+GLIBC_2.1 ptsname_r F
+GLIBC_2.1 putgrent F
+GLIBC_2.1 putmsg F
+GLIBC_2.1 putpmsg F
+GLIBC_2.1 pututxline F
+GLIBC_2.1 pwrite F
+GLIBC_2.1 pwrite64 F
+GLIBC_2.1 rawmemchr F
+GLIBC_2.1 readdir64 F
+GLIBC_2.1 readdir64_r F
+GLIBC_2.1 rtime F
+GLIBC_2.1 scandir64 F
+GLIBC_2.1 select F
+GLIBC_2.1 sem_destroy F
+GLIBC_2.1 sem_getvalue F
+GLIBC_2.1 sem_init F
+GLIBC_2.1 sem_post F
+GLIBC_2.1 sem_trywait F
+GLIBC_2.1 sem_wait F
+GLIBC_2.1 sendfile F
+GLIBC_2.1 setitimer F
+GLIBC_2.1 setrlimit64 F
+GLIBC_2.1 settimeofday F
+GLIBC_2.1 setutxent F
+GLIBC_2.1 sighold F
+GLIBC_2.1 sigignore F
+GLIBC_2.1 sigqueue F
+GLIBC_2.1 sigrelse F
+GLIBC_2.1 sigset F
+GLIBC_2.1 sigtimedwait F
+GLIBC_2.1 sigwaitinfo F
+GLIBC_2.1 statfs64 F
+GLIBC_2.1 statvfs F
+GLIBC_2.1 statvfs64 F
+GLIBC_2.1 strcasestr F
+GLIBC_2.1 strtoimax F
+GLIBC_2.1 strtoumax F
+GLIBC_2.1 strverscmp F
+GLIBC_2.1 svcunix_create F
+GLIBC_2.1 svcunixfd_create F
+GLIBC_2.1 swapcontext F
+GLIBC_2.1 sys_errlist D 0x3e8
+GLIBC_2.1 sys_nerr D 0x4
+GLIBC_2.1 sys_sigabbrev D 0x200
+GLIBC_2.1 sys_siglist D 0x200
+GLIBC_2.1 sysv_signal F
+GLIBC_2.1 tcgetsid F
+GLIBC_2.1 tdestroy F
+GLIBC_2.1 tmpfile F
+GLIBC_2.1 tmpfile64 F
+GLIBC_2.1 truncate64 F
+GLIBC_2.1 umount2 F
+GLIBC_2.1 unlockpt F
+GLIBC_2.1 updwtmpx F
+GLIBC_2.1 user2netname F
+GLIBC_2.1 utimes F
+GLIBC_2.1 utmpxname F
+GLIBC_2.1 versionsort F
+GLIBC_2.1 versionsort64 F
+GLIBC_2.1 wait4 F
+GLIBC_2.1 waitid F
+GLIBC_2.1 wcscasecmp F
+GLIBC_2.1 wcsncasecmp F
+GLIBC_2.1 wcsnlen F
+GLIBC_2.1 wcstoimax F
+GLIBC_2.1 wcstoll F
+GLIBC_2.1 wcstoull F
+GLIBC_2.1 wcstoumax F
+GLIBC_2.1 wcswcs F
+GLIBC_2.1 wordexp F
+GLIBC_2.1 wordfree F
+GLIBC_2.1 xdecrypt F
+GLIBC_2.1 xdr_authdes_cred F
+GLIBC_2.1 xdr_authdes_verf F
+GLIBC_2.1 xdr_getcredres F
+GLIBC_2.1 xdr_int16_t F
+GLIBC_2.1 xdr_int32_t F
+GLIBC_2.1 xdr_int8_t F
+GLIBC_2.1 xdr_netnamestr F
+GLIBC_2.1 xdr_sizeof F
+GLIBC_2.1 xdr_uint16_t F
+GLIBC_2.1 xdr_uint32_t F
+GLIBC_2.1 xdr_uint8_t F
+GLIBC_2.1 xdr_unixcred F
+GLIBC_2.1.1 _Exit F
+GLIBC_2.1.1 __mempcpy_small F
+GLIBC_2.1.1 __stpcpy_small F
+GLIBC_2.1.1 __strcpy_small F
+GLIBC_2.1.1 __strcspn_c1 F
+GLIBC_2.1.1 __strcspn_c2 F
+GLIBC_2.1.1 __strcspn_c3 F
+GLIBC_2.1.1 __strpbrk_c2 F
+GLIBC_2.1.1 __strpbrk_c3 F
+GLIBC_2.1.1 __strsep_1c F
+GLIBC_2.1.1 __strsep_2c F
+GLIBC_2.1.1 __strsep_3c F
+GLIBC_2.1.1 __strsep_g F
+GLIBC_2.1.1 __strspn_c1 F
+GLIBC_2.1.1 __strspn_c2 F
+GLIBC_2.1.1 __strspn_c3 F
+GLIBC_2.1.1 __strtok_r_1c F
+GLIBC_2.1.1 __strverscmp F
+GLIBC_2.1.1 getutmp F
+GLIBC_2.1.1 getutmpx F
+GLIBC_2.1.1 imaxabs F
+GLIBC_2.1.1 imaxdiv F
+GLIBC_2.1.1 sem_close F
+GLIBC_2.1.1 sem_open F
+GLIBC_2.1.1 sem_unlink F
+GLIBC_2.1.1 strchrnul F
+GLIBC_2.1.1 xdr_hyper F
+GLIBC_2.1.1 xdr_int64_t F
+GLIBC_2.1.1 xdr_longlong_t F
+GLIBC_2.1.1 xdr_u_hyper F
+GLIBC_2.1.1 xdr_u_longlong_t F
+GLIBC_2.1.1 xdr_uint64_t F
+GLIBC_2.1.2 __vfork F
+GLIBC_2.1.2 getaliasbyname_r F
+GLIBC_2.1.2 getaliasent_r F
+GLIBC_2.1.2 getgrent_r F
+GLIBC_2.1.2 getgrgid_r F
+GLIBC_2.1.2 getgrnam_r F
+GLIBC_2.1.2 gethostbyaddr_r F
+GLIBC_2.1.2 gethostbyname2_r F
+GLIBC_2.1.2 gethostbyname_r F
+GLIBC_2.1.2 gethostent_r F
+GLIBC_2.1.2 getnetbyaddr_r F
+GLIBC_2.1.2 getnetbyname_r F
+GLIBC_2.1.2 getnetent_r F
+GLIBC_2.1.2 getprotobyname_r F
+GLIBC_2.1.2 getprotobynumber_r F
+GLIBC_2.1.2 getprotoent_r F
+GLIBC_2.1.2 getpwent_r F
+GLIBC_2.1.2 getpwnam_r F
+GLIBC_2.1.2 getpwuid_r F
+GLIBC_2.1.2 getrpcbyname_r F
+GLIBC_2.1.2 getrpcbynumber_r F
+GLIBC_2.1.2 getrpcent_r F
+GLIBC_2.1.2 getservbyname_r F
+GLIBC_2.1.2 getservbyport_r F
+GLIBC_2.1.2 getservent_r F
+GLIBC_2.1.2 getspent_r F
+GLIBC_2.1.2 getspnam_r F
+GLIBC_2.1.3 __cxa_atexit F
+GLIBC_2.1.3 __cxa_finalize F
+GLIBC_2.1.3 __sigsuspend F
+GLIBC_2.1.4 pciconfig_iobase F
+GLIBC_2.10 __cxa_at_quick_exit F
+GLIBC_2.10 __posix_getopt F
+GLIBC_2.10 accept4 F
+GLIBC_2.10 endsgent F
+GLIBC_2.10 fallocate F
+GLIBC_2.10 fallocate64 F
+GLIBC_2.10 fgetsgent F
+GLIBC_2.10 fgetsgent_r F
+GLIBC_2.10 getsgent F
+GLIBC_2.10 getsgent_r F
+GLIBC_2.10 getsgnam F
+GLIBC_2.10 getsgnam_r F
+GLIBC_2.10 malloc_info F
+GLIBC_2.10 preadv F
+GLIBC_2.10 preadv64 F
+GLIBC_2.10 psiginfo F
+GLIBC_2.10 putsgent F
+GLIBC_2.10 pwritev F
+GLIBC_2.10 pwritev64 F
+GLIBC_2.10 quick_exit F
+GLIBC_2.10 register_printf_modifier F
+GLIBC_2.10 register_printf_specifier F
+GLIBC_2.10 register_printf_type F
+GLIBC_2.10 setsgent F
+GLIBC_2.10 sgetsgent F
+GLIBC_2.10 sgetsgent_r F
+GLIBC_2.11 __longjmp_chk F
+GLIBC_2.11 execvpe F
+GLIBC_2.11 mkostemps F
+GLIBC_2.11 mkostemps64 F
+GLIBC_2.11 mkstemps F
+GLIBC_2.11 mkstemps64 F
+GLIBC_2.11 pthread_sigqueue F
+GLIBC_2.12 _sys_errlist D 0x438
+GLIBC_2.12 _sys_nerr D 0x4
+GLIBC_2.12 ntp_gettimex F
+GLIBC_2.12 pthread_getname_np F
+GLIBC_2.12 pthread_mutex_consistent F
+GLIBC_2.12 pthread_mutexattr_getrobust F
+GLIBC_2.12 pthread_mutexattr_setrobust F
+GLIBC_2.12 pthread_setname_np F
+GLIBC_2.12 recvmmsg F
+GLIBC_2.12 sys_errlist D 0x438
+GLIBC_2.12 sys_nerr D 0x4
+GLIBC_2.13 fanotify_init F
+GLIBC_2.13 fanotify_mark F
+GLIBC_2.13 prlimit F
+GLIBC_2.13 prlimit64 F
+GLIBC_2.14 clock_adjtime F
+GLIBC_2.14 name_to_handle_at F
+GLIBC_2.14 open_by_handle_at F
+GLIBC_2.14 sendmmsg F
+GLIBC_2.14 setns F
+GLIBC_2.14 syncfs F
+GLIBC_2.15 __fdelt_chk F
+GLIBC_2.15 __fdelt_warn F
+GLIBC_2.15 posix_spawn F
+GLIBC_2.15 posix_spawnp F
+GLIBC_2.15 process_vm_readv F
+GLIBC_2.15 process_vm_writev F
+GLIBC_2.15 scandirat F
+GLIBC_2.15 scandirat64 F
+GLIBC_2.16 __getauxval F
+GLIBC_2.16 __poll_chk F
+GLIBC_2.16 __ppoll_chk F
+GLIBC_2.16 aligned_alloc F
+GLIBC_2.16 c16rtomb F
+GLIBC_2.16 c32rtomb F
+GLIBC_2.16 getauxval F
+GLIBC_2.16 mbrtoc16 F
+GLIBC_2.16 mbrtoc32 F
+GLIBC_2.16 timespec_get F
+GLIBC_2.17 clock_getcpuclockid F
+GLIBC_2.17 clock_getres F
+GLIBC_2.17 clock_gettime F
+GLIBC_2.17 clock_nanosleep F
+GLIBC_2.17 clock_settime F
+GLIBC_2.17 secure_getenv F
+GLIBC_2.18 __cxa_thread_atexit_impl F
+GLIBC_2.18 pthread_getattr_default_np F
+GLIBC_2.18 pthread_setattr_default_np F
+GLIBC_2.2 _IO_adjust_wcolumn F
+GLIBC_2.2 _IO_fgetpos F
+GLIBC_2.2 _IO_fgetpos64 F
+GLIBC_2.2 _IO_free_wbackup_area F
+GLIBC_2.2 _IO_fsetpos F
+GLIBC_2.2 _IO_fsetpos64 F
+GLIBC_2.2 _IO_init_wmarker F
+GLIBC_2.2 _IO_iter_begin F
+GLIBC_2.2 _IO_iter_end F
+GLIBC_2.2 _IO_iter_file F
+GLIBC_2.2 _IO_iter_next F
+GLIBC_2.2 _IO_least_wmarker F
+GLIBC_2.2 _IO_list_lock F
+GLIBC_2.2 _IO_list_resetlock F
+GLIBC_2.2 _IO_list_unlock F
+GLIBC_2.2 _IO_seekwmark F
+GLIBC_2.2 _IO_sputbackwc F
+GLIBC_2.2 _IO_sungetwc F
+GLIBC_2.2 _IO_switch_to_main_wget_area F
+GLIBC_2.2 _IO_switch_to_wbackup_area F
+GLIBC_2.2 _IO_switch_to_wget_mode F
+GLIBC_2.2 _IO_unsave_wmarkers F
+GLIBC_2.2 _IO_wdefault_doallocate F
+GLIBC_2.2 _IO_wdefault_finish F
+GLIBC_2.2 _IO_wdefault_pbackfail F
+GLIBC_2.2 _IO_wdefault_uflow F
+GLIBC_2.2 _IO_wdefault_xsgetn F
+GLIBC_2.2 _IO_wdefault_xsputn F
+GLIBC_2.2 _IO_wdo_write F
+GLIBC_2.2 _IO_wdoallocbuf F
+GLIBC_2.2 _IO_wfile_jumps D 0xa8
+GLIBC_2.2 _IO_wfile_overflow F
+GLIBC_2.2 _IO_wfile_seekoff F
+GLIBC_2.2 _IO_wfile_sync F
+GLIBC_2.2 _IO_wfile_underflow F
+GLIBC_2.2 _IO_wfile_xsputn F
+GLIBC_2.2 _IO_wmarker_delta F
+GLIBC_2.2 _IO_wsetb F
+GLIBC_2.2 __assert F
+GLIBC_2.2 __ctype32_tolower D 0x8
+GLIBC_2.2 __ctype32_toupper D 0x8
+GLIBC_2.2 __cyg_profile_func_enter F
+GLIBC_2.2 __cyg_profile_func_exit F
+GLIBC_2.2 __dn_expand F
+GLIBC_2.2 __endmntent F
+GLIBC_2.2 __fbufsize F
+GLIBC_2.2 __flbf F
+GLIBC_2.2 __fpending F
+GLIBC_2.2 __fpurge F
+GLIBC_2.2 __freadable F
+GLIBC_2.2 __freading F
+GLIBC_2.2 __fsetlocking F
+GLIBC_2.2 __fwritable F
+GLIBC_2.2 __fwriting F
+GLIBC_2.2 __getmntent_r F
+GLIBC_2.2 __nl_langinfo_l F
+GLIBC_2.2 __open64 F
+GLIBC_2.2 __pread64 F
+GLIBC_2.2 __pthread_rwlock_destroy F
+GLIBC_2.2 __pthread_rwlock_init F
+GLIBC_2.2 __pthread_rwlock_rdlock F
+GLIBC_2.2 __pthread_rwlock_tryrdlock F
+GLIBC_2.2 __pthread_rwlock_trywrlock F
+GLIBC_2.2 __pthread_rwlock_unlock F
+GLIBC_2.2 __pthread_rwlock_wrlock F
+GLIBC_2.2 __pwrite64 F
+GLIBC_2.2 __res_init F
+GLIBC_2.2 __res_mkquery F
+GLIBC_2.2 __res_nclose F
+GLIBC_2.2 __res_ninit F
+GLIBC_2.2 __res_nmkquery F
+GLIBC_2.2 __res_nquery F
+GLIBC_2.2 __res_nquerydomain F
+GLIBC_2.2 __res_nsearch F
+GLIBC_2.2 __res_nsend F
+GLIBC_2.2 __res_query F
+GLIBC_2.2 __res_querydomain F
+GLIBC_2.2 __res_search F
+GLIBC_2.2 __res_state F
+GLIBC_2.2 __setmntent F
+GLIBC_2.2 __statfs F
+GLIBC_2.2 __strndup F
+GLIBC_2.2 __sysconf F
+GLIBC_2.2 __sysctl F
+GLIBC_2.2 __wctrans_l F
+GLIBC_2.2 __woverflow F
+GLIBC_2.2 __wuflow F
+GLIBC_2.2 __wunderflow F
+GLIBC_2.2 __xpg_sigpause F
+GLIBC_2.2 _flushlbf F
+GLIBC_2.2 _res_hconf D 0x48
+GLIBC_2.2 bind_textdomain_codeset F
+GLIBC_2.2 clock_getcpuclockid F
+GLIBC_2.2 clock_getres F
+GLIBC_2.2 clock_gettime F
+GLIBC_2.2 clock_nanosleep F
+GLIBC_2.2 clock_settime F
+GLIBC_2.2 dcngettext F
+GLIBC_2.2 dngettext F
+GLIBC_2.2 fgetpos F
+GLIBC_2.2 fgetpos64 F
+GLIBC_2.2 fgetwc F
+GLIBC_2.2 fgetwc_unlocked F
+GLIBC_2.2 fgetws F
+GLIBC_2.2 fgetws_unlocked F
+GLIBC_2.2 fmemopen F
+GLIBC_2.2 fopencookie F
+GLIBC_2.2 fputwc F
+GLIBC_2.2 fputwc_unlocked F
+GLIBC_2.2 fputws F
+GLIBC_2.2 fputws_unlocked F
+GLIBC_2.2 fsetpos F
+GLIBC_2.2 fsetpos64 F
+GLIBC_2.2 fwide F
+GLIBC_2.2 fwprintf F
+GLIBC_2.2 fwscanf F
+GLIBC_2.2 getdirentries64 F
+GLIBC_2.2 getloadavg F
+GLIBC_2.2 getwc F
+GLIBC_2.2 getwc_unlocked F
+GLIBC_2.2 getwchar F
+GLIBC_2.2 getwchar_unlocked F
+GLIBC_2.2 iruserok_af F
+GLIBC_2.2 localeconv F
+GLIBC_2.2 lseek64 F
+GLIBC_2.2 mcheck_check_all F
+GLIBC_2.2 mcheck_pedantic F
+GLIBC_2.2 memrchr F
+GLIBC_2.2 mincore F
+GLIBC_2.2 mkdtemp F
+GLIBC_2.2 mkstemp64 F
+GLIBC_2.2 moncontrol F
+GLIBC_2.2 msgctl F
+GLIBC_2.2 ngettext F
+GLIBC_2.2 open64 F
+GLIBC_2.2 posix_fadvise F
+GLIBC_2.2 posix_fadvise64 F
+GLIBC_2.2 posix_fallocate F
+GLIBC_2.2 posix_fallocate64 F
+GLIBC_2.2 posix_madvise F
+GLIBC_2.2 posix_memalign F
+GLIBC_2.2 posix_spawn F
+GLIBC_2.2 posix_spawn_file_actions_addclose F
+GLIBC_2.2 posix_spawn_file_actions_adddup2 F
+GLIBC_2.2 posix_spawn_file_actions_addopen F
+GLIBC_2.2 posix_spawn_file_actions_destroy F
+GLIBC_2.2 posix_spawn_file_actions_init F
+GLIBC_2.2 posix_spawnattr_destroy F
+GLIBC_2.2 posix_spawnattr_getflags F
+GLIBC_2.2 posix_spawnattr_getpgroup F
+GLIBC_2.2 posix_spawnattr_getschedparam F
+GLIBC_2.2 posix_spawnattr_getschedpolicy F
+GLIBC_2.2 posix_spawnattr_getsigdefault F
+GLIBC_2.2 posix_spawnattr_getsigmask F
+GLIBC_2.2 posix_spawnattr_init F
+GLIBC_2.2 posix_spawnattr_setflags F
+GLIBC_2.2 posix_spawnattr_setpgroup F
+GLIBC_2.2 posix_spawnattr_setschedparam F
+GLIBC_2.2 posix_spawnattr_setschedpolicy F
+GLIBC_2.2 posix_spawnattr_setsigdefault F
+GLIBC_2.2 posix_spawnattr_setsigmask F
+GLIBC_2.2 posix_spawnp F
+GLIBC_2.2 pread F
+GLIBC_2.2 pread64 F
+GLIBC_2.2 pthread_attr_getstack F
+GLIBC_2.2 pthread_attr_setstack F
+GLIBC_2.2 pthread_barrier_destroy F
+GLIBC_2.2 pthread_barrier_init F
+GLIBC_2.2 pthread_barrier_wait F
+GLIBC_2.2 pthread_barrierattr_destroy F
+GLIBC_2.2 pthread_barrierattr_init F
+GLIBC_2.2 pthread_barrierattr_setpshared F
+GLIBC_2.2 pthread_condattr_getpshared F
+GLIBC_2.2 pthread_condattr_setpshared F
+GLIBC_2.2 pthread_getcpuclockid F
+GLIBC_2.2 pthread_mutex_timedlock F
+GLIBC_2.2 pthread_mutexattr_getpshared F
+GLIBC_2.2 pthread_mutexattr_setpshared F
+GLIBC_2.2 pthread_rwlock_timedrdlock F
+GLIBC_2.2 pthread_rwlock_timedwrlock F
+GLIBC_2.2 pthread_spin_destroy F
+GLIBC_2.2 pthread_spin_init F
+GLIBC_2.2 pthread_spin_lock F
+GLIBC_2.2 pthread_spin_trylock F
+GLIBC_2.2 pthread_spin_unlock F
+GLIBC_2.2 pthread_yield F
+GLIBC_2.2 putwc F
+GLIBC_2.2 putwc_unlocked F
+GLIBC_2.2 putwchar F
+GLIBC_2.2 putwchar_unlocked F
+GLIBC_2.2 pwrite F
+GLIBC_2.2 pwrite64 F
+GLIBC_2.2 rcmd_af F
+GLIBC_2.2 rexec_af F
+GLIBC_2.2 rresvport_af F
+GLIBC_2.2 ruserok_af F
+GLIBC_2.2 sem_timedwait F
+GLIBC_2.2 semctl F
+GLIBC_2.2 shm_open F
+GLIBC_2.2 shm_unlink F
+GLIBC_2.2 shmctl F
+GLIBC_2.2 svc_getreq_common F
+GLIBC_2.2 svc_getreq_poll F
+GLIBC_2.2 svc_max_pollfd D 0x4
+GLIBC_2.2 svc_pollfd D 0x8
+GLIBC_2.2 swprintf F
+GLIBC_2.2 swscanf F
+GLIBC_2.2 timer_create F
+GLIBC_2.2 timer_delete F
+GLIBC_2.2 timer_getoverrun F
+GLIBC_2.2 timer_gettime F
+GLIBC_2.2 timer_settime F
+GLIBC_2.2 ungetwc F
+GLIBC_2.2 vfwprintf F
+GLIBC_2.2 vfwscanf F
+GLIBC_2.2 vswprintf F
+GLIBC_2.2 vswscanf F
+GLIBC_2.2 vwprintf F
+GLIBC_2.2 vwscanf F
+GLIBC_2.2 wcschrnul F
+GLIBC_2.2 wcsftime F
+GLIBC_2.2 wmempcpy F
+GLIBC_2.2 wprintf F
+GLIBC_2.2 wscanf F
+GLIBC_2.2.1 pivot_root F
+GLIBC_2.2.1 posix_openpt F
+GLIBC_2.2.2 __nss_hostname_digits_dots F
+GLIBC_2.2.2 wordexp F
+GLIBC_2.2.3 __rpc_thread_createerr F
+GLIBC_2.2.3 __rpc_thread_svc_fdset F
+GLIBC_2.2.3 __rpc_thread_svc_max_pollfd F
+GLIBC_2.2.3 __rpc_thread_svc_pollfd F
+GLIBC_2.2.3 fnmatch F
+GLIBC_2.2.3 gai_cancel F
+GLIBC_2.2.3 gai_error F
+GLIBC_2.2.3 gai_suspend F
+GLIBC_2.2.3 getaddrinfo_a F
+GLIBC_2.2.3 pthread_getattr_np F
+GLIBC_2.2.3 sprofil F
+GLIBC_2.2.4 dl_iterate_phdr F
+GLIBC_2.2.4 getgrouplist F
+GLIBC_2.2.4 sockatmark F
+GLIBC_2.2.6 __nanosleep F
+GLIBC_2.22 fmemopen F
+GLIBC_2.23 fts64_children F
+GLIBC_2.23 fts64_close F
+GLIBC_2.23 fts64_open F
+GLIBC_2.23 fts64_read F
+GLIBC_2.23 fts64_set F
+GLIBC_2.24 quick_exit F
+GLIBC_2.25 __explicit_bzero_chk F
+GLIBC_2.25 explicit_bzero F
+GLIBC_2.25 getentropy F
+GLIBC_2.25 getrandom F
+GLIBC_2.25 strfromd F
+GLIBC_2.25 strfromf F
+GLIBC_2.25 strfroml F
+GLIBC_2.26 preadv2 F
+GLIBC_2.26 preadv64v2 F
+GLIBC_2.26 pwritev2 F
+GLIBC_2.26 pwritev64v2 F
+GLIBC_2.26 reallocarray F
+GLIBC_2.27 copy_file_range F
+GLIBC_2.27 getrlimit F
+GLIBC_2.27 getrlimit64 F
+GLIBC_2.27 glob F
+GLIBC_2.27 glob64 F
+GLIBC_2.27 memfd_create F
+GLIBC_2.27 mlock2 F
+GLIBC_2.27 pkey_alloc F
+GLIBC_2.27 pkey_free F
+GLIBC_2.27 pkey_get F
+GLIBC_2.27 pkey_mprotect F
+GLIBC_2.27 pkey_set F
+GLIBC_2.27 setrlimit F
+GLIBC_2.27 setrlimit64 F
+GLIBC_2.27 strfromf128 F
+GLIBC_2.27 strfromf32 F
+GLIBC_2.27 strfromf32x F
+GLIBC_2.27 strfromf64 F
+GLIBC_2.27 strfromf64x F
+GLIBC_2.27 strtof128 F
+GLIBC_2.27 strtof128_l F
+GLIBC_2.27 strtof32 F
+GLIBC_2.27 strtof32_l F
+GLIBC_2.27 strtof32x F
+GLIBC_2.27 strtof32x_l F
+GLIBC_2.27 strtof64 F
+GLIBC_2.27 strtof64_l F
+GLIBC_2.27 strtof64x F
+GLIBC_2.27 strtof64x_l F
+GLIBC_2.27 wcstof128 F
+GLIBC_2.27 wcstof128_l F
+GLIBC_2.27 wcstof32 F
+GLIBC_2.27 wcstof32_l F
+GLIBC_2.27 wcstof32x F
+GLIBC_2.27 wcstof32x_l F
+GLIBC_2.27 wcstof64 F
+GLIBC_2.27 wcstof64_l F
+GLIBC_2.27 wcstof64x F
+GLIBC_2.27 wcstof64x_l F
+GLIBC_2.28 call_once F
+GLIBC_2.28 cnd_broadcast F
+GLIBC_2.28 cnd_destroy F
+GLIBC_2.28 cnd_init F
+GLIBC_2.28 cnd_signal F
+GLIBC_2.28 cnd_timedwait F
+GLIBC_2.28 cnd_wait F
+GLIBC_2.28 fcntl64 F
+GLIBC_2.28 mtx_destroy F
+GLIBC_2.28 mtx_init F
+GLIBC_2.28 mtx_lock F
+GLIBC_2.28 mtx_timedlock F
+GLIBC_2.28 mtx_trylock F
+GLIBC_2.28 mtx_unlock F
+GLIBC_2.28 renameat2 F
+GLIBC_2.28 statx F
+GLIBC_2.28 thrd_create F
+GLIBC_2.28 thrd_current F
+GLIBC_2.28 thrd_detach F
+GLIBC_2.28 thrd_equal F
+GLIBC_2.28 thrd_exit F
+GLIBC_2.28 thrd_join F
+GLIBC_2.28 thrd_sleep F
+GLIBC_2.28 thrd_yield F
+GLIBC_2.28 tss_create F
+GLIBC_2.28 tss_delete F
+GLIBC_2.28 tss_get F
+GLIBC_2.28 tss_set F
+GLIBC_2.29 getcpu F
+GLIBC_2.29 posix_spawn_file_actions_addchdir_np F
+GLIBC_2.29 posix_spawn_file_actions_addfchdir_np F
+GLIBC_2.3 __ctype_b_loc F
+GLIBC_2.3 __ctype_tolower_loc F
+GLIBC_2.3 __ctype_toupper_loc F
+GLIBC_2.3 __isctype F
+GLIBC_2.3 __strftime_l F
+GLIBC_2.3 __uselocale F
+GLIBC_2.3 __wcsftime_l F
+GLIBC_2.3 _sys_errlist D 0x3f0
+GLIBC_2.3 _sys_nerr D 0x4
+GLIBC_2.3 aio_cancel F
+GLIBC_2.3 aio_cancel64 F
+GLIBC_2.3 duplocale F
+GLIBC_2.3 fgetxattr F
+GLIBC_2.3 flistxattr F
+GLIBC_2.3 freeifaddrs F
+GLIBC_2.3 freelocale F
+GLIBC_2.3 fremovexattr F
+GLIBC_2.3 fsetxattr F
+GLIBC_2.3 futimes F
+GLIBC_2.3 getifaddrs F
+GLIBC_2.3 getxattr F
+GLIBC_2.3 isalnum_l F
+GLIBC_2.3 isalpha_l F
+GLIBC_2.3 isblank_l F
+GLIBC_2.3 iscntrl_l F
+GLIBC_2.3 isctype F
+GLIBC_2.3 isdigit_l F
+GLIBC_2.3 isgraph_l F
+GLIBC_2.3 islower_l F
+GLIBC_2.3 isprint_l F
+GLIBC_2.3 ispunct_l F
+GLIBC_2.3 isspace_l F
+GLIBC_2.3 isupper_l F
+GLIBC_2.3 iswalnum_l F
+GLIBC_2.3 iswalpha_l F
+GLIBC_2.3 iswblank_l F
+GLIBC_2.3 iswcntrl_l F
+GLIBC_2.3 iswctype_l F
+GLIBC_2.3 iswdigit_l F
+GLIBC_2.3 iswgraph_l F
+GLIBC_2.3 iswlower_l F
+GLIBC_2.3 iswprint_l F
+GLIBC_2.3 iswpunct_l F
+GLIBC_2.3 iswspace_l F
+GLIBC_2.3 iswupper_l F
+GLIBC_2.3 iswxdigit_l F
+GLIBC_2.3 isxdigit_l F
+GLIBC_2.3 lgetxattr F
+GLIBC_2.3 listxattr F
+GLIBC_2.3 llistxattr F
+GLIBC_2.3 lremovexattr F
+GLIBC_2.3 lsetxattr F
+GLIBC_2.3 lutimes F
+GLIBC_2.3 newlocale F
+GLIBC_2.3 nl_langinfo_l F
+GLIBC_2.3 readahead F
+GLIBC_2.3 realpath F
+GLIBC_2.3 removexattr F
+GLIBC_2.3 sendfile64 F
+GLIBC_2.3 setxattr F
+GLIBC_2.3 strcasecmp_l F
+GLIBC_2.3 strcoll_l F
+GLIBC_2.3 strfmon_l F
+GLIBC_2.3 strftime_l F
+GLIBC_2.3 strncasecmp_l F
+GLIBC_2.3 strtod_l F
+GLIBC_2.3 strtof_l F
+GLIBC_2.3 strtol_l F
+GLIBC_2.3 strtold_l F
+GLIBC_2.3 strtoul_l F
+GLIBC_2.3 strxfrm_l F
+GLIBC_2.3 sys_errlist D 0x3f0
+GLIBC_2.3 sys_nerr D 0x4
+GLIBC_2.3 tolower_l F
+GLIBC_2.3 toupper_l F
+GLIBC_2.3 towctrans_l F
+GLIBC_2.3 towlower_l F
+GLIBC_2.3 towupper_l F
+GLIBC_2.3 uselocale F
+GLIBC_2.3 wcscasecmp_l F
+GLIBC_2.3 wcscoll_l F
+GLIBC_2.3 wcsftime_l F
+GLIBC_2.3 wcsncasecmp_l F
+GLIBC_2.3 wcstod_l F
+GLIBC_2.3 wcstof_l F
+GLIBC_2.3 wcstol_l F
+GLIBC_2.3 wcstold_l F
+GLIBC_2.3 wcstoll_l F
+GLIBC_2.3 wcstoul_l F
+GLIBC_2.3 wcstoull_l F
+GLIBC_2.3 wcsxfrm_l F
+GLIBC_2.3 wctrans_l F
+GLIBC_2.3 wctype_l F
+GLIBC_2.3.2 __register_atfork F
+GLIBC_2.3.2 epoll_create F
+GLIBC_2.3.2 epoll_ctl F
+GLIBC_2.3.2 epoll_wait F
+GLIBC_2.3.2 lchmod F
+GLIBC_2.3.2 pthread_cond_broadcast F
+GLIBC_2.3.2 pthread_cond_destroy F
+GLIBC_2.3.2 pthread_cond_init F
+GLIBC_2.3.2 pthread_cond_signal F
+GLIBC_2.3.2 pthread_cond_timedwait F
+GLIBC_2.3.2 pthread_cond_wait F
+GLIBC_2.3.2 strptime_l F
+GLIBC_2.3.3 __pthread_cleanup_routine F
+GLIBC_2.3.3 __pthread_register_cancel F
+GLIBC_2.3.3 __pthread_register_cancel_defer F
+GLIBC_2.3.3 __pthread_unregister_cancel F
+GLIBC_2.3.3 __pthread_unregister_cancel_restore F
+GLIBC_2.3.3 __pthread_unwind_next F
+GLIBC_2.3.3 _sys_siglist D 0x208
+GLIBC_2.3.3 dladdr1 F
+GLIBC_2.3.3 dlinfo F
+GLIBC_2.3.3 gnu_dev_major F
+GLIBC_2.3.3 gnu_dev_makedev F
+GLIBC_2.3.3 gnu_dev_minor F
+GLIBC_2.3.3 inet6_option_alloc F
+GLIBC_2.3.3 inet6_option_append F
+GLIBC_2.3.3 inet6_option_find F
+GLIBC_2.3.3 inet6_option_init F
+GLIBC_2.3.3 inet6_option_next F
+GLIBC_2.3.3 inet6_option_space F
+GLIBC_2.3.3 nftw F
+GLIBC_2.3.3 nftw64 F
+GLIBC_2.3.3 pthread_attr_getaffinity_np F
+GLIBC_2.3.3 pthread_attr_setaffinity_np F
+GLIBC_2.3.3 pthread_attr_setstack F
+GLIBC_2.3.3 pthread_attr_setstacksize F
+GLIBC_2.3.3 pthread_barrierattr_getpshared F
+GLIBC_2.3.3 pthread_condattr_getclock F
+GLIBC_2.3.3 pthread_condattr_setclock F
+GLIBC_2.3.3 pthread_getaffinity_np F
+GLIBC_2.3.3 pthread_setaffinity_np F
+GLIBC_2.3.3 pthread_timedjoin_np F
+GLIBC_2.3.3 pthread_tryjoin_np F
+GLIBC_2.3.3 remap_file_pages F
+GLIBC_2.3.3 sched_getaffinity F
+GLIBC_2.3.3 sched_setaffinity F
+GLIBC_2.3.3 semtimedop F
+GLIBC_2.3.3 strtoll_l F
+GLIBC_2.3.3 strtoull_l F
+GLIBC_2.3.3 sys_sigabbrev D 0x208
+GLIBC_2.3.3 sys_siglist D 0x208
+GLIBC_2.3.3 timer_create F
+GLIBC_2.3.3 timer_delete F
+GLIBC_2.3.3 timer_getoverrun F
+GLIBC_2.3.3 timer_gettime F
+GLIBC_2.3.3 timer_settime F
+GLIBC_2.3.4 _OtsAddX F
+GLIBC_2.3.4 _OtsConvertFloatTX F
+GLIBC_2.3.4 _OtsConvertFloatXT F
+GLIBC_2.3.4 _OtsCvtQUX F
+GLIBC_2.3.4 _OtsCvtQX F
+GLIBC_2.3.4 _OtsCvtXQ F
+GLIBC_2.3.4 _OtsDivX F
+GLIBC_2.3.4 _OtsEqlX F
+GLIBC_2.3.4 _OtsGeqX F
+GLIBC_2.3.4 _OtsGtrX F
+GLIBC_2.3.4 _OtsLeqX F
+GLIBC_2.3.4 _OtsLssX F
+GLIBC_2.3.4 _OtsMulX F
+GLIBC_2.3.4 _OtsNeqX F
+GLIBC_2.3.4 _OtsNintXQ F
+GLIBC_2.3.4 _OtsSubX F
+GLIBC_2.3.4 __chk_fail F
+GLIBC_2.3.4 __fprintf_chk F
+GLIBC_2.3.4 __gets_chk F
+GLIBC_2.3.4 __memcpy_chk F
+GLIBC_2.3.4 __memmove_chk F
+GLIBC_2.3.4 __mempcpy_chk F
+GLIBC_2.3.4 __memset_chk F
+GLIBC_2.3.4 __printf_chk F
+GLIBC_2.3.4 __snprintf_chk F
+GLIBC_2.3.4 __sprintf_chk F
+GLIBC_2.3.4 __stpcpy_chk F
+GLIBC_2.3.4 __strcat_chk F
+GLIBC_2.3.4 __strcpy_chk F
+GLIBC_2.3.4 __strncat_chk F
+GLIBC_2.3.4 __strncpy_chk F
+GLIBC_2.3.4 __vfprintf_chk F
+GLIBC_2.3.4 __vprintf_chk F
+GLIBC_2.3.4 __vsnprintf_chk F
+GLIBC_2.3.4 __vsprintf_chk F
+GLIBC_2.3.4 __xpg_strerror_r F
+GLIBC_2.3.4 dlmopen F
+GLIBC_2.3.4 getipv4sourcefilter F
+GLIBC_2.3.4 getsourcefilter F
+GLIBC_2.3.4 mq_close F
+GLIBC_2.3.4 mq_getattr F
+GLIBC_2.3.4 mq_notify F
+GLIBC_2.3.4 mq_open F
+GLIBC_2.3.4 mq_receive F
+GLIBC_2.3.4 mq_send F
+GLIBC_2.3.4 mq_setattr F
+GLIBC_2.3.4 mq_timedreceive F
+GLIBC_2.3.4 mq_timedsend F
+GLIBC_2.3.4 mq_unlink F
+GLIBC_2.3.4 pthread_attr_getaffinity_np F
+GLIBC_2.3.4 pthread_attr_setaffinity_np F
+GLIBC_2.3.4 pthread_getaffinity_np F
+GLIBC_2.3.4 pthread_setaffinity_np F
+GLIBC_2.3.4 pthread_setschedprio F
+GLIBC_2.3.4 regexec F
+GLIBC_2.3.4 sched_getaffinity F
+GLIBC_2.3.4 sched_setaffinity F
+GLIBC_2.3.4 setipv4sourcefilter F
+GLIBC_2.3.4 setsourcefilter F
+GLIBC_2.3.4 xdr_quad_t F
+GLIBC_2.3.4 xdr_u_quad_t F
+GLIBC_2.30 __nldbl_argp_error F
+GLIBC_2.30 __nldbl_argp_failure F
+GLIBC_2.30 __nldbl_err F
+GLIBC_2.30 __nldbl_error F
+GLIBC_2.30 __nldbl_error_at_line F
+GLIBC_2.30 __nldbl_errx F
+GLIBC_2.30 __nldbl_verr F
+GLIBC_2.30 __nldbl_verrx F
+GLIBC_2.30 __nldbl_vwarn F
+GLIBC_2.30 __nldbl_vwarnx F
+GLIBC_2.30 __nldbl_warn F
+GLIBC_2.30 __nldbl_warnx F
+GLIBC_2.30 getdents64 F
+GLIBC_2.30 gettid F
+GLIBC_2.30 pthread_cond_clockwait F
+GLIBC_2.30 pthread_mutex_clocklock F
+GLIBC_2.30 pthread_rwlock_clockrdlock F
+GLIBC_2.30 pthread_rwlock_clockwrlock F
+GLIBC_2.30 sem_clockwait F
+GLIBC_2.30 tgkill F
+GLIBC_2.30 twalk_r F
+GLIBC_2.31 pthread_clockjoin_np F
+GLIBC_2.32 __libc_single_threaded D 0x1
+GLIBC_2.32 pthread_attr_getsigmask_np F
+GLIBC_2.32 pthread_attr_setaffinity_np F
+GLIBC_2.32 pthread_attr_setsigmask_np F
+GLIBC_2.32 pthread_getaffinity_np F
+GLIBC_2.32 pthread_getattr_np F
+GLIBC_2.32 pthread_sigmask F
+GLIBC_2.32 sigabbrev_np F
+GLIBC_2.32 sigdescr_np F
+GLIBC_2.32 strerrordesc_np F
+GLIBC_2.32 strerrorname_np F
+GLIBC_2.33 fstat F
+GLIBC_2.33 fstat64 F
+GLIBC_2.33 fstatat F
+GLIBC_2.33 fstatat64 F
+GLIBC_2.33 lstat F
+GLIBC_2.33 lstat64 F
+GLIBC_2.33 mallinfo2 F
+GLIBC_2.33 mknod F
+GLIBC_2.33 mknodat F
+GLIBC_2.33 stat F
+GLIBC_2.33 stat64 F
+GLIBC_2.34 _Fork F
+GLIBC_2.34 __libc_start_main F
+GLIBC_2.34 __mq_open_2 F
+GLIBC_2.34 __pthread_cleanup_routine F
+GLIBC_2.34 __pthread_key_create F
+GLIBC_2.34 __pthread_register_cancel F
+GLIBC_2.34 __pthread_register_cancel_defer F
+GLIBC_2.34 __pthread_unregister_cancel F
+GLIBC_2.34 __pthread_unregister_cancel_restore F
+GLIBC_2.34 __pthread_unwind_next F
+GLIBC_2.34 _pthread_cleanup_pop F
+GLIBC_2.34 _pthread_cleanup_push F
+GLIBC_2.34 aio_cancel F
+GLIBC_2.34 aio_cancel64 F
+GLIBC_2.34 aio_error F
+GLIBC_2.34 aio_error64 F
+GLIBC_2.34 aio_fsync F
+GLIBC_2.34 aio_fsync64 F
+GLIBC_2.34 aio_init F
+GLIBC_2.34 aio_read F
+GLIBC_2.34 aio_read64 F
+GLIBC_2.34 aio_return F
+GLIBC_2.34 aio_return64 F
+GLIBC_2.34 aio_suspend F
+GLIBC_2.34 aio_suspend64 F
+GLIBC_2.34 aio_write F
+GLIBC_2.34 aio_write64 F
+GLIBC_2.34 call_once F
+GLIBC_2.34 close_range F
+GLIBC_2.34 closefrom F
+GLIBC_2.34 cnd_broadcast F
+GLIBC_2.34 cnd_destroy F
+GLIBC_2.34 cnd_init F
+GLIBC_2.34 cnd_signal F
+GLIBC_2.34 cnd_timedwait F
+GLIBC_2.34 cnd_wait F
+GLIBC_2.34 dladdr F
+GLIBC_2.34 dladdr1 F
+GLIBC_2.34 dlclose F
+GLIBC_2.34 dlerror F
+GLIBC_2.34 dlinfo F
+GLIBC_2.34 dlmopen F
+GLIBC_2.34 dlopen F
+GLIBC_2.34 dlsym F
+GLIBC_2.34 dlvsym F
+GLIBC_2.34 dn_comp F
+GLIBC_2.34 dn_expand F
+GLIBC_2.34 dn_skipname F
+GLIBC_2.34 execveat F
+GLIBC_2.34 forkpty F
+GLIBC_2.34 gai_cancel F
+GLIBC_2.34 gai_error F
+GLIBC_2.34 gai_suspend F
+GLIBC_2.34 getaddrinfo_a F
+GLIBC_2.34 lio_listio F
+GLIBC_2.34 lio_listio64 F
+GLIBC_2.34 login F
+GLIBC_2.34 login_tty F
+GLIBC_2.34 logout F
+GLIBC_2.34 logwtmp F
+GLIBC_2.34 mq_close F
+GLIBC_2.34 mq_getattr F
+GLIBC_2.34 mq_notify F
+GLIBC_2.34 mq_open F
+GLIBC_2.34 mq_receive F
+GLIBC_2.34 mq_send F
+GLIBC_2.34 mq_setattr F
+GLIBC_2.34 mq_timedreceive F
+GLIBC_2.34 mq_timedsend F
+GLIBC_2.34 mq_unlink F
+GLIBC_2.34 mtx_destroy F
+GLIBC_2.34 mtx_init F
+GLIBC_2.34 mtx_lock F
+GLIBC_2.34 mtx_timedlock F
+GLIBC_2.34 mtx_trylock F
+GLIBC_2.34 mtx_unlock F
+GLIBC_2.34 ns_name_compress F
+GLIBC_2.34 ns_name_ntop F
+GLIBC_2.34 ns_name_pack F
+GLIBC_2.34 ns_name_pton F
+GLIBC_2.34 ns_name_skip F
+GLIBC_2.34 ns_name_uncompress F
+GLIBC_2.34 ns_name_unpack F
+GLIBC_2.34 openpty F
+GLIBC_2.34 posix_spawn_file_actions_addclosefrom_np F
+GLIBC_2.34 pthread_attr_getaffinity_np F
+GLIBC_2.34 pthread_attr_getguardsize F
+GLIBC_2.34 pthread_attr_getstack F
+GLIBC_2.34 pthread_attr_getstackaddr F
+GLIBC_2.34 pthread_attr_getstacksize F
+GLIBC_2.34 pthread_attr_setguardsize F
+GLIBC_2.34 pthread_attr_setstack F
+GLIBC_2.34 pthread_attr_setstackaddr F
+GLIBC_2.34 pthread_attr_setstacksize F
+GLIBC_2.34 pthread_barrier_destroy F
+GLIBC_2.34 pthread_barrier_init F
+GLIBC_2.34 pthread_barrier_wait F
+GLIBC_2.34 pthread_barrierattr_destroy F
+GLIBC_2.34 pthread_barrierattr_getpshared F
+GLIBC_2.34 pthread_barrierattr_init F
+GLIBC_2.34 pthread_barrierattr_setpshared F
+GLIBC_2.34 pthread_cancel F
+GLIBC_2.34 pthread_clockjoin_np F
+GLIBC_2.34 pthread_cond_clockwait F
+GLIBC_2.34 pthread_condattr_getclock F
+GLIBC_2.34 pthread_condattr_getpshared F
+GLIBC_2.34 pthread_condattr_setclock F
+GLIBC_2.34 pthread_condattr_setpshared F
+GLIBC_2.34 pthread_create F
+GLIBC_2.34 pthread_detach F
+GLIBC_2.34 pthread_getattr_default_np F
+GLIBC_2.34 pthread_getconcurrency F
+GLIBC_2.34 pthread_getcpuclockid F
+GLIBC_2.34 pthread_getname_np F
+GLIBC_2.34 pthread_getspecific F
+GLIBC_2.34 pthread_join F
+GLIBC_2.34 pthread_key_create F
+GLIBC_2.34 pthread_key_delete F
+GLIBC_2.34 pthread_kill F
+GLIBC_2.34 pthread_mutex_clocklock F
+GLIBC_2.34 pthread_mutex_consistent F
+GLIBC_2.34 pthread_mutex_getprioceiling F
+GLIBC_2.34 pthread_mutex_setprioceiling F
+GLIBC_2.34 pthread_mutex_timedlock F
+GLIBC_2.34 pthread_mutex_trylock F
+GLIBC_2.34 pthread_mutexattr_destroy F
+GLIBC_2.34 pthread_mutexattr_getprioceiling F
+GLIBC_2.34 pthread_mutexattr_getprotocol F
+GLIBC_2.34 pthread_mutexattr_getpshared F
+GLIBC_2.34 pthread_mutexattr_getrobust F
+GLIBC_2.34 pthread_mutexattr_gettype F
+GLIBC_2.34 pthread_mutexattr_init F
+GLIBC_2.34 pthread_mutexattr_setprioceiling F
+GLIBC_2.34 pthread_mutexattr_setprotocol F
+GLIBC_2.34 pthread_mutexattr_setpshared F
+GLIBC_2.34 pthread_mutexattr_setrobust F
+GLIBC_2.34 pthread_mutexattr_settype F
+GLIBC_2.34 pthread_once F
+GLIBC_2.34 pthread_rwlock_clockrdlock F
+GLIBC_2.34 pthread_rwlock_clockwrlock F
+GLIBC_2.34 pthread_rwlock_destroy F
+GLIBC_2.34 pthread_rwlock_init F
+GLIBC_2.34 pthread_rwlock_rdlock F
+GLIBC_2.34 pthread_rwlock_timedrdlock F
+GLIBC_2.34 pthread_rwlock_timedwrlock F
+GLIBC_2.34 pthread_rwlock_tryrdlock F
+GLIBC_2.34 pthread_rwlock_trywrlock F
+GLIBC_2.34 pthread_rwlock_unlock F
+GLIBC_2.34 pthread_rwlock_wrlock F
+GLIBC_2.34 pthread_rwlockattr_destroy F
+GLIBC_2.34 pthread_rwlockattr_getkind_np F
+GLIBC_2.34 pthread_rwlockattr_getpshared F
+GLIBC_2.34 pthread_rwlockattr_init F
+GLIBC_2.34 pthread_rwlockattr_setkind_np F
+GLIBC_2.34 pthread_rwlockattr_setpshared F
+GLIBC_2.34 pthread_setaffinity_np F
+GLIBC_2.34 pthread_setattr_default_np F
+GLIBC_2.34 pthread_setconcurrency F
+GLIBC_2.34 pthread_setname_np F
+GLIBC_2.34 pthread_setschedprio F
+GLIBC_2.34 pthread_setspecific F
+GLIBC_2.34 pthread_sigqueue F
+GLIBC_2.34 pthread_spin_destroy F
+GLIBC_2.34 pthread_spin_init F
+GLIBC_2.34 pthread_spin_lock F
+GLIBC_2.34 pthread_spin_trylock F
+GLIBC_2.34 pthread_spin_unlock F
+GLIBC_2.34 pthread_testcancel F
+GLIBC_2.34 pthread_timedjoin_np F
+GLIBC_2.34 pthread_tryjoin_np F
+GLIBC_2.34 res_dnok F
+GLIBC_2.34 res_hnok F
+GLIBC_2.34 res_mailok F
+GLIBC_2.34 res_mkquery F
+GLIBC_2.34 res_nmkquery F
+GLIBC_2.34 res_nquery F
+GLIBC_2.34 res_nquerydomain F
+GLIBC_2.34 res_nsearch F
+GLIBC_2.34 res_nsend F
+GLIBC_2.34 res_ownok F
+GLIBC_2.34 res_query F
+GLIBC_2.34 res_querydomain F
+GLIBC_2.34 res_search F
+GLIBC_2.34 res_send F
+GLIBC_2.34 sem_clockwait F
+GLIBC_2.34 sem_close F
+GLIBC_2.34 sem_destroy F
+GLIBC_2.34 sem_getvalue F
+GLIBC_2.34 sem_init F
+GLIBC_2.34 sem_open F
+GLIBC_2.34 sem_post F
+GLIBC_2.34 sem_timedwait F
+GLIBC_2.34 sem_trywait F
+GLIBC_2.34 sem_unlink F
+GLIBC_2.34 sem_wait F
+GLIBC_2.34 shm_open F
+GLIBC_2.34 shm_unlink F
+GLIBC_2.34 thrd_create F
+GLIBC_2.34 thrd_detach F
+GLIBC_2.34 thrd_exit F
+GLIBC_2.34 thrd_join F
+GLIBC_2.34 timer_create F
+GLIBC_2.34 timer_delete F
+GLIBC_2.34 timer_getoverrun F
+GLIBC_2.34 timer_gettime F
+GLIBC_2.34 timer_settime F
+GLIBC_2.34 timespec_getres F
+GLIBC_2.34 tss_create F
+GLIBC_2.34 tss_delete F
+GLIBC_2.34 tss_get F
+GLIBC_2.34 tss_set F
+GLIBC_2.35 __memcmpeq F
+GLIBC_2.35 _dl_find_object F
+GLIBC_2.35 epoll_pwait2 F
+GLIBC_2.35 posix_spawn_file_actions_addtcsetpgrp_np F
+GLIBC_2.36 arc4random F
+GLIBC_2.36 arc4random_buf F
+GLIBC_2.36 arc4random_uniform F
+GLIBC_2.36 c8rtomb F
+GLIBC_2.36 fsconfig F
+GLIBC_2.36 fsmount F
+GLIBC_2.36 fsopen F
+GLIBC_2.36 fspick F
+GLIBC_2.36 mbrtoc8 F
+GLIBC_2.36 mount_setattr F
+GLIBC_2.36 move_mount F
+GLIBC_2.36 open_tree F
+GLIBC_2.36 pidfd_getfd F
+GLIBC_2.36 pidfd_open F
+GLIBC_2.36 pidfd_send_signal F
+GLIBC_2.36 process_madvise F
+GLIBC_2.36 process_mrelease F
+GLIBC_2.38 __isoc23_fscanf F
+GLIBC_2.38 __isoc23_fwscanf F
+GLIBC_2.38 __isoc23_scanf F
+GLIBC_2.38 __isoc23_sscanf F
+GLIBC_2.38 __isoc23_strtoimax F
+GLIBC_2.38 __isoc23_strtol F
+GLIBC_2.38 __isoc23_strtol_l F
+GLIBC_2.38 __isoc23_strtoll F
+GLIBC_2.38 __isoc23_strtoll_l F
+GLIBC_2.38 __isoc23_strtoul F
+GLIBC_2.38 __isoc23_strtoul_l F
+GLIBC_2.38 __isoc23_strtoull F
+GLIBC_2.38 __isoc23_strtoull_l F
+GLIBC_2.38 __isoc23_strtoumax F
+GLIBC_2.38 __isoc23_swscanf F
+GLIBC_2.38 __isoc23_vfscanf F
+GLIBC_2.38 __isoc23_vfwscanf F
+GLIBC_2.38 __isoc23_vscanf F
+GLIBC_2.38 __isoc23_vsscanf F
+GLIBC_2.38 __isoc23_vswscanf F
+GLIBC_2.38 __isoc23_vwscanf F
+GLIBC_2.38 __isoc23_wcstoimax F
+GLIBC_2.38 __isoc23_wcstol F
+GLIBC_2.38 __isoc23_wcstol_l F
+GLIBC_2.38 __isoc23_wcstoll F
+GLIBC_2.38 __isoc23_wcstoll_l F
+GLIBC_2.38 __isoc23_wcstoul F
+GLIBC_2.38 __isoc23_wcstoul_l F
+GLIBC_2.38 __isoc23_wcstoull F
+GLIBC_2.38 __isoc23_wcstoull_l F
+GLIBC_2.38 __isoc23_wcstoumax F
+GLIBC_2.38 __isoc23_wscanf F
+GLIBC_2.38 __nldbl___isoc23_fscanf F
+GLIBC_2.38 __nldbl___isoc23_fwscanf F
+GLIBC_2.38 __nldbl___isoc23_scanf F
+GLIBC_2.38 __nldbl___isoc23_sscanf F
+GLIBC_2.38 __nldbl___isoc23_swscanf F
+GLIBC_2.38 __nldbl___isoc23_vfscanf F
+GLIBC_2.38 __nldbl___isoc23_vfwscanf F
+GLIBC_2.38 __nldbl___isoc23_vscanf F
+GLIBC_2.38 __nldbl___isoc23_vsscanf F
+GLIBC_2.38 __nldbl___isoc23_vswscanf F
+GLIBC_2.38 __nldbl___isoc23_vwscanf F
+GLIBC_2.38 __nldbl___isoc23_wscanf F
+GLIBC_2.38 __strlcat_chk F
+GLIBC_2.38 __strlcpy_chk F
+GLIBC_2.38 __wcslcat_chk F
+GLIBC_2.38 __wcslcpy_chk F
+GLIBC_2.38 strlcat F
+GLIBC_2.38 strlcpy F
+GLIBC_2.38 wcslcat F
+GLIBC_2.38 wcslcpy F
+GLIBC_2.4 _IO_fprintf F
+GLIBC_2.4 _IO_printf F
+GLIBC_2.4 _IO_sprintf F
+GLIBC_2.4 _IO_sscanf F
+GLIBC_2.4 _IO_vfprintf F
+GLIBC_2.4 _IO_vfscanf F
+GLIBC_2.4 _IO_vsprintf F
+GLIBC_2.4 __asprintf F
+GLIBC_2.4 __confstr_chk F
+GLIBC_2.4 __fgets_chk F
+GLIBC_2.4 __fgets_unlocked_chk F
+GLIBC_2.4 __fgetws_chk F
+GLIBC_2.4 __fgetws_unlocked_chk F
+GLIBC_2.4 __finitel F
+GLIBC_2.4 __fprintf_chk F
+GLIBC_2.4 __fwprintf_chk F
+GLIBC_2.4 __fxstatat F
+GLIBC_2.4 __fxstatat64 F
+GLIBC_2.4 __getcwd_chk F
+GLIBC_2.4 __getdomainname_chk F
+GLIBC_2.4 __getgroups_chk F
+GLIBC_2.4 __gethostname_chk F
+GLIBC_2.4 __getlogin_r_chk F
+GLIBC_2.4 __getwd_chk F
+GLIBC_2.4 __isinfl F
+GLIBC_2.4 __isnanl F
+GLIBC_2.4 __mbsnrtowcs_chk F
+GLIBC_2.4 __mbsrtowcs_chk F
+GLIBC_2.4 __mbstowcs_chk F
+GLIBC_2.4 __nldbl__IO_fprintf F
+GLIBC_2.4 __nldbl__IO_printf F
+GLIBC_2.4 __nldbl__IO_sprintf F
+GLIBC_2.4 __nldbl__IO_sscanf F
+GLIBC_2.4 __nldbl__IO_vfprintf F
+GLIBC_2.4 __nldbl__IO_vfscanf F
+GLIBC_2.4 __nldbl__IO_vsprintf F
+GLIBC_2.4 __nldbl___asprintf F
+GLIBC_2.4 __nldbl___fprintf_chk F
+GLIBC_2.4 __nldbl___fwprintf_chk F
+GLIBC_2.4 __nldbl___printf_chk F
+GLIBC_2.4 __nldbl___printf_fp F
+GLIBC_2.4 __nldbl___snprintf_chk F
+GLIBC_2.4 __nldbl___sprintf_chk F
+GLIBC_2.4 __nldbl___strfmon_l F
+GLIBC_2.4 __nldbl___swprintf_chk F
+GLIBC_2.4 __nldbl___syslog_chk F
+GLIBC_2.4 __nldbl___vfprintf_chk F
+GLIBC_2.4 __nldbl___vfscanf F
+GLIBC_2.4 __nldbl___vfwprintf_chk F
+GLIBC_2.4 __nldbl___vprintf_chk F
+GLIBC_2.4 __nldbl___vsnprintf F
+GLIBC_2.4 __nldbl___vsnprintf_chk F
+GLIBC_2.4 __nldbl___vsprintf_chk F
+GLIBC_2.4 __nldbl___vsscanf F
+GLIBC_2.4 __nldbl___vstrfmon F
+GLIBC_2.4 __nldbl___vstrfmon_l F
+GLIBC_2.4 __nldbl___vswprintf_chk F
+GLIBC_2.4 __nldbl___vsyslog_chk F
+GLIBC_2.4 __nldbl___vwprintf_chk F
+GLIBC_2.4 __nldbl___wprintf_chk F
+GLIBC_2.4 __nldbl_asprintf F
+GLIBC_2.4 __nldbl_dprintf F
+GLIBC_2.4 __nldbl_fprintf F
+GLIBC_2.4 __nldbl_fscanf F
+GLIBC_2.4 __nldbl_fwprintf F
+GLIBC_2.4 __nldbl_fwscanf F
+GLIBC_2.4 __nldbl_obstack_printf F
+GLIBC_2.4 __nldbl_obstack_vprintf F
+GLIBC_2.4 __nldbl_printf F
+GLIBC_2.4 __nldbl_printf_size F
+GLIBC_2.4 __nldbl_scanf F
+GLIBC_2.4 __nldbl_snprintf F
+GLIBC_2.4 __nldbl_sprintf F
+GLIBC_2.4 __nldbl_sscanf F
+GLIBC_2.4 __nldbl_strfmon F
+GLIBC_2.4 __nldbl_strfmon_l F
+GLIBC_2.4 __nldbl_swprintf F
+GLIBC_2.4 __nldbl_swscanf F
+GLIBC_2.4 __nldbl_syslog F
+GLIBC_2.4 __nldbl_vasprintf F
+GLIBC_2.4 __nldbl_vdprintf F
+GLIBC_2.4 __nldbl_vfprintf F
+GLIBC_2.4 __nldbl_vfscanf F
+GLIBC_2.4 __nldbl_vfwprintf F
+GLIBC_2.4 __nldbl_vfwscanf F
+GLIBC_2.4 __nldbl_vprintf F
+GLIBC_2.4 __nldbl_vscanf F
+GLIBC_2.4 __nldbl_vsnprintf F
+GLIBC_2.4 __nldbl_vsprintf F
+GLIBC_2.4 __nldbl_vsscanf F
+GLIBC_2.4 __nldbl_vswprintf F
+GLIBC_2.4 __nldbl_vswscanf F
+GLIBC_2.4 __nldbl_vsyslog F
+GLIBC_2.4 __nldbl_vwprintf F
+GLIBC_2.4 __nldbl_vwscanf F
+GLIBC_2.4 __nldbl_wprintf F
+GLIBC_2.4 __nldbl_wscanf F
+GLIBC_2.4 __pread64_chk F
+GLIBC_2.4 __pread_chk F
+GLIBC_2.4 __printf_chk F
+GLIBC_2.4 __printf_fp F
+GLIBC_2.4 __ptsname_r_chk F
+GLIBC_2.4 __read_chk F
+GLIBC_2.4 __readlink_chk F
+GLIBC_2.4 __realpath_chk F
+GLIBC_2.4 __recv_chk F
+GLIBC_2.4 __recvfrom_chk F
+GLIBC_2.4 __signbitl F
+GLIBC_2.4 __snprintf_chk F
+GLIBC_2.4 __sprintf_chk F
+GLIBC_2.4 __stack_chk_fail F
+GLIBC_2.4 __stpncpy_chk F
+GLIBC_2.4 __strfmon_l F
+GLIBC_2.4 __strtold_internal F
+GLIBC_2.4 __strtold_l F
+GLIBC_2.4 __swprintf_chk F
+GLIBC_2.4 __syslog_chk F
+GLIBC_2.4 __ttyname_r_chk F
+GLIBC_2.4 __vfprintf_chk F
+GLIBC_2.4 __vfscanf F
+GLIBC_2.4 __vfwprintf_chk F
+GLIBC_2.4 __vprintf_chk F
+GLIBC_2.4 __vsnprintf F
+GLIBC_2.4 __vsnprintf_chk F
+GLIBC_2.4 __vsprintf_chk F
+GLIBC_2.4 __vsscanf F
+GLIBC_2.4 __vswprintf_chk F
+GLIBC_2.4 __vsyslog_chk F
+GLIBC_2.4 __vwprintf_chk F
+GLIBC_2.4 __wcpcpy_chk F
+GLIBC_2.4 __wcpncpy_chk F
+GLIBC_2.4 __wcrtomb_chk F
+GLIBC_2.4 __wcscat_chk F
+GLIBC_2.4 __wcscpy_chk F
+GLIBC_2.4 __wcsncat_chk F
+GLIBC_2.4 __wcsncpy_chk F
+GLIBC_2.4 __wcsnrtombs_chk F
+GLIBC_2.4 __wcsrtombs_chk F
+GLIBC_2.4 __wcstold_internal F
+GLIBC_2.4 __wcstold_l F
+GLIBC_2.4 __wcstombs_chk F
+GLIBC_2.4 __wctomb_chk F
+GLIBC_2.4 __wmemcpy_chk F
+GLIBC_2.4 __wmemmove_chk F
+GLIBC_2.4 __wmempcpy_chk F
+GLIBC_2.4 __wmemset_chk F
+GLIBC_2.4 __wprintf_chk F
+GLIBC_2.4 __xmknodat F
+GLIBC_2.4 _sys_errlist D 0x420
+GLIBC_2.4 _sys_nerr D 0x4
+GLIBC_2.4 asprintf F
+GLIBC_2.4 copysignl F
+GLIBC_2.4 dprintf F
+GLIBC_2.4 eaccess F
+GLIBC_2.4 faccessat F
+GLIBC_2.4 fchmodat F
+GLIBC_2.4 fchownat F
+GLIBC_2.4 fdopendir F
+GLIBC_2.4 finitel F
+GLIBC_2.4 fprintf F
+GLIBC_2.4 frexpl F
+GLIBC_2.4 fscanf F
+GLIBC_2.4 futimesat F
+GLIBC_2.4 fwprintf F
+GLIBC_2.4 fwscanf F
+GLIBC_2.4 inotify_add_watch F
+GLIBC_2.4 inotify_init F
+GLIBC_2.4 inotify_rm_watch F
+GLIBC_2.4 isinfl F
+GLIBC_2.4 isnanl F
+GLIBC_2.4 ldexpl F
+GLIBC_2.4 linkat F
+GLIBC_2.4 lio_listio F
+GLIBC_2.4 lio_listio64 F
+GLIBC_2.4 mkdirat F
+GLIBC_2.4 mkfifoat F
+GLIBC_2.4 modfl F
+GLIBC_2.4 obstack_printf F
+GLIBC_2.4 obstack_vprintf F
+GLIBC_2.4 open_wmemstream F
+GLIBC_2.4 openat F
+GLIBC_2.4 openat64 F
+GLIBC_2.4 ppoll F
+GLIBC_2.4 printf F
+GLIBC_2.4 printf_size F
+GLIBC_2.4 pthread_mutex_consistent_np F
+GLIBC_2.4 pthread_mutex_getprioceiling F
+GLIBC_2.4 pthread_mutex_setprioceiling F
+GLIBC_2.4 pthread_mutexattr_getprioceiling F
+GLIBC_2.4 pthread_mutexattr_getprotocol F
+GLIBC_2.4 pthread_mutexattr_getrobust_np F
+GLIBC_2.4 pthread_mutexattr_setprioceiling F
+GLIBC_2.4 pthread_mutexattr_setprotocol F
+GLIBC_2.4 pthread_mutexattr_setrobust_np F
+GLIBC_2.4 qecvt F
+GLIBC_2.4 qecvt_r F
+GLIBC_2.4 qfcvt F
+GLIBC_2.4 qfcvt_r F
+GLIBC_2.4 qgcvt F
+GLIBC_2.4 readlinkat F
+GLIBC_2.4 renameat F
+GLIBC_2.4 scalbnl F
+GLIBC_2.4 scanf F
+GLIBC_2.4 snprintf F
+GLIBC_2.4 sprintf F
+GLIBC_2.4 sscanf F
+GLIBC_2.4 strfmon F
+GLIBC_2.4 strfmon_l F
+GLIBC_2.4 strtold F
+GLIBC_2.4 strtold_l F
+GLIBC_2.4 swprintf F
+GLIBC_2.4 swscanf F
+GLIBC_2.4 symlinkat F
+GLIBC_2.4 sys_errlist D 0x420
+GLIBC_2.4 sys_nerr D 0x4
+GLIBC_2.4 syslog F
+GLIBC_2.4 unlinkat F
+GLIBC_2.4 unshare F
+GLIBC_2.4 vasprintf F
+GLIBC_2.4 vdprintf F
+GLIBC_2.4 vfprintf F
+GLIBC_2.4 vfscanf F
+GLIBC_2.4 vfwprintf F
+GLIBC_2.4 vfwscanf F
+GLIBC_2.4 vprintf F
+GLIBC_2.4 vscanf F
+GLIBC_2.4 vsnprintf F
+GLIBC_2.4 vsprintf F
+GLIBC_2.4 vsscanf F
+GLIBC_2.4 vswprintf F
+GLIBC_2.4 vswscanf F
+GLIBC_2.4 vsyslog F
+GLIBC_2.4 vwprintf F
+GLIBC_2.4 vwscanf F
+GLIBC_2.4 wcstold F
+GLIBC_2.4 wcstold_l F
+GLIBC_2.4 wprintf F
+GLIBC_2.4 wscanf F
+GLIBC_2.5 __readlinkat_chk F
+GLIBC_2.5 inet6_opt_append F
+GLIBC_2.5 inet6_opt_find F
+GLIBC_2.5 inet6_opt_finish F
+GLIBC_2.5 inet6_opt_get_val F
+GLIBC_2.5 inet6_opt_init F
+GLIBC_2.5 inet6_opt_next F
+GLIBC_2.5 inet6_opt_set_val F
+GLIBC_2.5 inet6_rth_add F
+GLIBC_2.5 inet6_rth_getaddr F
+GLIBC_2.5 inet6_rth_init F
+GLIBC_2.5 inet6_rth_reverse F
+GLIBC_2.5 inet6_rth_segments F
+GLIBC_2.5 inet6_rth_space F
+GLIBC_2.5 splice F
+GLIBC_2.5 tee F
+GLIBC_2.5 vmsplice F
+GLIBC_2.6 __sched_cpucount F
+GLIBC_2.6 epoll_pwait F
+GLIBC_2.6 futimens F
+GLIBC_2.6 sched_getcpu F
+GLIBC_2.6 strerror_l F
+GLIBC_2.6 sync_file_range F
+GLIBC_2.6 utimensat F
+GLIBC_2.7 __fread_chk F
+GLIBC_2.7 __fread_unlocked_chk F
+GLIBC_2.7 __isoc99_fscanf F
+GLIBC_2.7 __isoc99_fwscanf F
+GLIBC_2.7 __isoc99_scanf F
+GLIBC_2.7 __isoc99_sscanf F
+GLIBC_2.7 __isoc99_swscanf F
+GLIBC_2.7 __isoc99_vfscanf F
+GLIBC_2.7 __isoc99_vfwscanf F
+GLIBC_2.7 __isoc99_vscanf F
+GLIBC_2.7 __isoc99_vsscanf F
+GLIBC_2.7 __isoc99_vswscanf F
+GLIBC_2.7 __isoc99_vwscanf F
+GLIBC_2.7 __isoc99_wscanf F
+GLIBC_2.7 __mq_open_2 F
+GLIBC_2.7 __nldbl___isoc99_fscanf F
+GLIBC_2.7 __nldbl___isoc99_fwscanf F
+GLIBC_2.7 __nldbl___isoc99_scanf F
+GLIBC_2.7 __nldbl___isoc99_sscanf F
+GLIBC_2.7 __nldbl___isoc99_swscanf F
+GLIBC_2.7 __nldbl___isoc99_vfscanf F
+GLIBC_2.7 __nldbl___isoc99_vfwscanf F
+GLIBC_2.7 __nldbl___isoc99_vscanf F
+GLIBC_2.7 __nldbl___isoc99_vsscanf F
+GLIBC_2.7 __nldbl___isoc99_vswscanf F
+GLIBC_2.7 __nldbl___isoc99_vwscanf F
+GLIBC_2.7 __nldbl___isoc99_wscanf F
+GLIBC_2.7 __open64_2 F
+GLIBC_2.7 __open_2 F
+GLIBC_2.7 __openat64_2 F
+GLIBC_2.7 __openat_2 F
+GLIBC_2.7 __sched_cpualloc F
+GLIBC_2.7 __sched_cpufree F
+GLIBC_2.7 eventfd F
+GLIBC_2.7 eventfd_read F
+GLIBC_2.7 eventfd_write F
+GLIBC_2.7 mkostemp F
+GLIBC_2.7 mkostemp64 F
+GLIBC_2.7 signalfd F
+GLIBC_2.8 __asprintf_chk F
+GLIBC_2.8 __dprintf_chk F
+GLIBC_2.8 __nldbl___asprintf_chk F
+GLIBC_2.8 __nldbl___dprintf_chk F
+GLIBC_2.8 __nldbl___obstack_printf_chk F
+GLIBC_2.8 __nldbl___obstack_vprintf_chk F
+GLIBC_2.8 __nldbl___vasprintf_chk F
+GLIBC_2.8 __nldbl___vdprintf_chk F
+GLIBC_2.8 __obstack_printf_chk F
+GLIBC_2.8 __obstack_vprintf_chk F
+GLIBC_2.8 __vasprintf_chk F
+GLIBC_2.8 __vdprintf_chk F
+GLIBC_2.8 qsort_r F
+GLIBC_2.8 timerfd_create F
+GLIBC_2.8 timerfd_gettime F
+GLIBC_2.8 timerfd_settime F
+GLIBC_2.9 dup3 F
+GLIBC_2.9 epoll_create1 F
+GLIBC_2.9 inotify_init1 F
+GLIBC_2.9 ns_name_compress F
+GLIBC_2.9 ns_name_ntop F
+GLIBC_2.9 ns_name_pack F
+GLIBC_2.9 ns_name_pton F
+GLIBC_2.9 ns_name_skip F
+GLIBC_2.9 ns_name_uncompress F
+GLIBC_2.9 ns_name_unpack F
+GLIBC_2.9 pipe2 F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libc_malloc_debug.abilist b/sysdeps/unix/sysv/linux/sw_64/libc_malloc_debug.abilist
new file mode 100644
index 00000000..15b3293b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libc_malloc_debug.abilist
@@ -0,0 +1,28 @@
+GLIBC_2.0 __free_hook D 0x8
+GLIBC_2.0 __malloc_hook D 0x8
+GLIBC_2.0 __memalign_hook D 0x8
+GLIBC_2.0 __realloc_hook D 0x8
+GLIBC_2.0 calloc F
+GLIBC_2.0 free F
+GLIBC_2.0 mallinfo F
+GLIBC_2.0 malloc F
+GLIBC_2.0 malloc_get_state F
+GLIBC_2.0 malloc_set_state F
+GLIBC_2.0 malloc_stats F
+GLIBC_2.0 malloc_trim F
+GLIBC_2.0 malloc_usable_size F
+GLIBC_2.0 mallopt F
+GLIBC_2.0 mcheck F
+GLIBC_2.0 memalign F
+GLIBC_2.0 mprobe F
+GLIBC_2.0 mtrace F
+GLIBC_2.0 muntrace F
+GLIBC_2.0 pvalloc F
+GLIBC_2.0 realloc F
+GLIBC_2.0 valloc F
+GLIBC_2.10 malloc_info F
+GLIBC_2.16 aligned_alloc F
+GLIBC_2.2 mcheck_check_all F
+GLIBC_2.2 mcheck_pedantic F
+GLIBC_2.2 posix_memalign F
+GLIBC_2.33 mallinfo2 F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libcrypt.abilist b/sysdeps/unix/sysv/linux/sw_64/libcrypt.abilist
new file mode 100644
index 00000000..cd6ba952
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libcrypt.abilist
@@ -0,0 +1,7 @@
+GLIBC_2.0 crypt F
+GLIBC_2.0 crypt_r F
+GLIBC_2.0 encrypt F
+GLIBC_2.0 encrypt_r F
+GLIBC_2.0 fcrypt F
+GLIBC_2.0 setkey F
+GLIBC_2.0 setkey_r F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libdl.abilist b/sysdeps/unix/sysv/linux/sw_64/libdl.abilist
new file mode 100644
index 00000000..a4559344
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libdl.abilist
@@ -0,0 +1,4 @@
+GLIBC_2.0 __libdl_version_placeholder F
+GLIBC_2.1 __libdl_version_placeholder F
+GLIBC_2.3.3 __libdl_version_placeholder F
+GLIBC_2.3.4 __libdl_version_placeholder F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libm.abilist b/sysdeps/unix/sysv/linux/sw_64/libm.abilist
new file mode 100644
index 00000000..066dd1a6
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libm.abilist
@@ -0,0 +1,1309 @@
+GLIBC_2.0 _LIB_VERSION D 0x4
+GLIBC_2.0 __atan2 F
+GLIBC_2.0 acos F
+GLIBC_2.0 acosf F
+GLIBC_2.0 acosh F
+GLIBC_2.0 acoshf F
+GLIBC_2.0 acoshl F
+GLIBC_2.0 acosl F
+GLIBC_2.0 asin F
+GLIBC_2.0 asinf F
+GLIBC_2.0 asinh F
+GLIBC_2.0 asinhf F
+GLIBC_2.0 asinhl F
+GLIBC_2.0 asinl F
+GLIBC_2.0 atan F
+GLIBC_2.0 atan2 F
+GLIBC_2.0 atan2f F
+GLIBC_2.0 atan2l F
+GLIBC_2.0 atanf F
+GLIBC_2.0 atanh F
+GLIBC_2.0 atanhf F
+GLIBC_2.0 atanhl F
+GLIBC_2.0 atanl F
+GLIBC_2.0 cbrt F
+GLIBC_2.0 cbrtf F
+GLIBC_2.0 cbrtl F
+GLIBC_2.0 ceil F
+GLIBC_2.0 ceilf F
+GLIBC_2.0 ceill F
+GLIBC_2.0 copysign F
+GLIBC_2.0 copysignf F
+GLIBC_2.0 copysignl F
+GLIBC_2.0 cos F
+GLIBC_2.0 cosf F
+GLIBC_2.0 cosh F
+GLIBC_2.0 coshf F
+GLIBC_2.0 coshl F
+GLIBC_2.0 cosl F
+GLIBC_2.0 drem F
+GLIBC_2.0 dremf F
+GLIBC_2.0 dreml F
+GLIBC_2.0 erf F
+GLIBC_2.0 erfc F
+GLIBC_2.0 erfcf F
+GLIBC_2.0 erfcl F
+GLIBC_2.0 erff F
+GLIBC_2.0 erfl F
+GLIBC_2.0 exp F
+GLIBC_2.0 expf F
+GLIBC_2.0 expl F
+GLIBC_2.0 expm1 F
+GLIBC_2.0 expm1f F
+GLIBC_2.0 expm1l F
+GLIBC_2.0 fabs F
+GLIBC_2.0 fabsf F
+GLIBC_2.0 fabsl F
+GLIBC_2.0 finite F
+GLIBC_2.0 finitef F
+GLIBC_2.0 finitel F
+GLIBC_2.0 floor F
+GLIBC_2.0 floorf F
+GLIBC_2.0 floorl F
+GLIBC_2.0 fmod F
+GLIBC_2.0 fmodf F
+GLIBC_2.0 fmodl F
+GLIBC_2.0 frexp F
+GLIBC_2.0 frexpf F
+GLIBC_2.0 frexpl F
+GLIBC_2.0 gamma F
+GLIBC_2.0 gammaf F
+GLIBC_2.0 gammal F
+GLIBC_2.0 hypot F
+GLIBC_2.0 hypotf F
+GLIBC_2.0 hypotl F
+GLIBC_2.0 ilogb F
+GLIBC_2.0 ilogbf F
+GLIBC_2.0 ilogbl F
+GLIBC_2.0 j0 F
+GLIBC_2.0 j0f F
+GLIBC_2.0 j0l F
+GLIBC_2.0 j1 F
+GLIBC_2.0 j1f F
+GLIBC_2.0 j1l F
+GLIBC_2.0 jn F
+GLIBC_2.0 jnf F
+GLIBC_2.0 jnl F
+GLIBC_2.0 ldexp F
+GLIBC_2.0 ldexpf F
+GLIBC_2.0 ldexpl F
+GLIBC_2.0 lgamma F
+GLIBC_2.0 lgamma_r F
+GLIBC_2.0 lgammaf F
+GLIBC_2.0 lgammaf_r F
+GLIBC_2.0 lgammal F
+GLIBC_2.0 lgammal_r F
+GLIBC_2.0 log F
+GLIBC_2.0 log10 F
+GLIBC_2.0 log10f F
+GLIBC_2.0 log10l F
+GLIBC_2.0 log1p F
+GLIBC_2.0 log1pf F
+GLIBC_2.0 log1pl F
+GLIBC_2.0 logb F
+GLIBC_2.0 logbf F
+GLIBC_2.0 logbl F
+GLIBC_2.0 logf F
+GLIBC_2.0 logl F
+GLIBC_2.0 matherr F
+GLIBC_2.0 modf F
+GLIBC_2.0 modff F
+GLIBC_2.0 modfl F
+GLIBC_2.0 nextafter F
+GLIBC_2.0 nextafterf F
+GLIBC_2.0 nextafterl F
+GLIBC_2.0 pow F
+GLIBC_2.0 powf F
+GLIBC_2.0 powl F
+GLIBC_2.0 remainder F
+GLIBC_2.0 remainderf F
+GLIBC_2.0 remainderl F
+GLIBC_2.0 rint F
+GLIBC_2.0 rintf F
+GLIBC_2.0 rintl F
+GLIBC_2.0 scalb F
+GLIBC_2.0 scalbf F
+GLIBC_2.0 scalbl F
+GLIBC_2.0 scalbn F
+GLIBC_2.0 scalbnf F
+GLIBC_2.0 scalbnl F
+GLIBC_2.0 signgam D 0x4
+GLIBC_2.0 significand F
+GLIBC_2.0 significandf F
+GLIBC_2.0 significandl F
+GLIBC_2.0 sin F
+GLIBC_2.0 sinf F
+GLIBC_2.0 sinh F
+GLIBC_2.0 sinhf F
+GLIBC_2.0 sinhl F
+GLIBC_2.0 sinl F
+GLIBC_2.0 sqrt F
+GLIBC_2.0 sqrtf F
+GLIBC_2.0 sqrtl F
+GLIBC_2.0 tan F
+GLIBC_2.0 tanf F
+GLIBC_2.0 tanh F
+GLIBC_2.0 tanhf F
+GLIBC_2.0 tanhl F
+GLIBC_2.0 tanl F
+GLIBC_2.0 y0 F
+GLIBC_2.0 y0f F
+GLIBC_2.0 y0l F
+GLIBC_2.0 y1 F
+GLIBC_2.0 y1f F
+GLIBC_2.0 y1l F
+GLIBC_2.0 yn F
+GLIBC_2.0 ynf F
+GLIBC_2.0 ynl F
+GLIBC_2.1 __clog10 F
+GLIBC_2.1 __clog10f F
+GLIBC_2.1 __clog10l F
+GLIBC_2.1 __finite F
+GLIBC_2.1 __finitef F
+GLIBC_2.1 __finitel F
+GLIBC_2.1 __fpclassify F
+GLIBC_2.1 __fpclassifyf F
+GLIBC_2.1 __signbit F
+GLIBC_2.1 __signbitf F
+GLIBC_2.1 cabs F
+GLIBC_2.1 cabsf F
+GLIBC_2.1 cabsl F
+GLIBC_2.1 cacos F
+GLIBC_2.1 cacosf F
+GLIBC_2.1 cacosh F
+GLIBC_2.1 cacoshf F
+GLIBC_2.1 cacoshl F
+GLIBC_2.1 cacosl F
+GLIBC_2.1 carg F
+GLIBC_2.1 cargf F
+GLIBC_2.1 cargl F
+GLIBC_2.1 casin F
+GLIBC_2.1 casinf F
+GLIBC_2.1 casinh F
+GLIBC_2.1 casinhf F
+GLIBC_2.1 casinhl F
+GLIBC_2.1 casinl F
+GLIBC_2.1 catan F
+GLIBC_2.1 catanf F
+GLIBC_2.1 catanh F
+GLIBC_2.1 catanhf F
+GLIBC_2.1 catanhl F
+GLIBC_2.1 catanl F
+GLIBC_2.1 ccos F
+GLIBC_2.1 ccosf F
+GLIBC_2.1 ccosh F
+GLIBC_2.1 ccoshf F
+GLIBC_2.1 ccoshl F
+GLIBC_2.1 ccosl F
+GLIBC_2.1 cexp F
+GLIBC_2.1 cexpf F
+GLIBC_2.1 cexpl F
+GLIBC_2.1 cimag F
+GLIBC_2.1 cimagf F
+GLIBC_2.1 cimagl F
+GLIBC_2.1 clog F
+GLIBC_2.1 clog10 F
+GLIBC_2.1 clog10f F
+GLIBC_2.1 clog10l F
+GLIBC_2.1 clogf F
+GLIBC_2.1 clogl F
+GLIBC_2.1 conj F
+GLIBC_2.1 conjf F
+GLIBC_2.1 conjl F
+GLIBC_2.1 cpow F
+GLIBC_2.1 cpowf F
+GLIBC_2.1 cpowl F
+GLIBC_2.1 cproj F
+GLIBC_2.1 cprojf F
+GLIBC_2.1 cprojl F
+GLIBC_2.1 creal F
+GLIBC_2.1 crealf F
+GLIBC_2.1 creall F
+GLIBC_2.1 csin F
+GLIBC_2.1 csinf F
+GLIBC_2.1 csinh F
+GLIBC_2.1 csinhf F
+GLIBC_2.1 csinhl F
+GLIBC_2.1 csinl F
+GLIBC_2.1 csqrt F
+GLIBC_2.1 csqrtf F
+GLIBC_2.1 csqrtl F
+GLIBC_2.1 ctan F
+GLIBC_2.1 ctanf F
+GLIBC_2.1 ctanh F
+GLIBC_2.1 ctanhf F
+GLIBC_2.1 ctanhl F
+GLIBC_2.1 ctanl F
+GLIBC_2.1 exp10 F
+GLIBC_2.1 exp10f F
+GLIBC_2.1 exp10l F
+GLIBC_2.1 exp2 F
+GLIBC_2.1 exp2f F
+GLIBC_2.1 fdim F
+GLIBC_2.1 fdimf F
+GLIBC_2.1 fdiml F
+GLIBC_2.1 feclearexcept F
+GLIBC_2.1 fegetenv F
+GLIBC_2.1 fegetexceptflag F
+GLIBC_2.1 fegetround F
+GLIBC_2.1 feholdexcept F
+GLIBC_2.1 feraiseexcept F
+GLIBC_2.1 fesetenv F
+GLIBC_2.1 fesetexceptflag F
+GLIBC_2.1 fesetround F
+GLIBC_2.1 fetestexcept F
+GLIBC_2.1 feupdateenv F
+GLIBC_2.1 fma F
+GLIBC_2.1 fmaf F
+GLIBC_2.1 fmal F
+GLIBC_2.1 fmax F
+GLIBC_2.1 fmaxf F
+GLIBC_2.1 fmaxl F
+GLIBC_2.1 fmin F
+GLIBC_2.1 fminf F
+GLIBC_2.1 fminl F
+GLIBC_2.1 llrint F
+GLIBC_2.1 llrintf F
+GLIBC_2.1 llrintl F
+GLIBC_2.1 llround F
+GLIBC_2.1 llroundf F
+GLIBC_2.1 llroundl F
+GLIBC_2.1 log2 F
+GLIBC_2.1 log2f F
+GLIBC_2.1 log2l F
+GLIBC_2.1 lrint F
+GLIBC_2.1 lrintf F
+GLIBC_2.1 lrintl F
+GLIBC_2.1 lround F
+GLIBC_2.1 lroundf F
+GLIBC_2.1 lroundl F
+GLIBC_2.1 nan F
+GLIBC_2.1 nanf F
+GLIBC_2.1 nanl F
+GLIBC_2.1 nearbyint F
+GLIBC_2.1 nearbyintf F
+GLIBC_2.1 nearbyintl F
+GLIBC_2.1 nexttoward F
+GLIBC_2.1 nexttowardf F
+GLIBC_2.1 nexttowardl F
+GLIBC_2.1 pow10 F
+GLIBC_2.1 pow10f F
+GLIBC_2.1 pow10l F
+GLIBC_2.1 remquo F
+GLIBC_2.1 remquof F
+GLIBC_2.1 remquol F
+GLIBC_2.1 round F
+GLIBC_2.1 roundf F
+GLIBC_2.1 roundl F
+GLIBC_2.1 scalbln F
+GLIBC_2.1 scalblnf F
+GLIBC_2.1 scalblnl F
+GLIBC_2.1 sincos F
+GLIBC_2.1 sincosf F
+GLIBC_2.1 sincosl F
+GLIBC_2.1 tgamma F
+GLIBC_2.1 tgammaf F
+GLIBC_2.1 tgammal F
+GLIBC_2.1 trunc F
+GLIBC_2.1 truncf F
+GLIBC_2.1 truncl F
+GLIBC_2.15 __acos_finite F
+GLIBC_2.15 __acosf_finite F
+GLIBC_2.15 __acosh_finite F
+GLIBC_2.15 __acoshf_finite F
+GLIBC_2.15 __acoshl_finite F
+GLIBC_2.15 __acosl_finite F
+GLIBC_2.15 __asin_finite F
+GLIBC_2.15 __asinf_finite F
+GLIBC_2.15 __asinl_finite F
+GLIBC_2.15 __atan2_finite F
+GLIBC_2.15 __atan2f_finite F
+GLIBC_2.15 __atan2l_finite F
+GLIBC_2.15 __atanh_finite F
+GLIBC_2.15 __atanhf_finite F
+GLIBC_2.15 __atanhl_finite F
+GLIBC_2.15 __cosh_finite F
+GLIBC_2.15 __coshf_finite F
+GLIBC_2.15 __coshl_finite F
+GLIBC_2.15 __exp10_finite F
+GLIBC_2.15 __exp10f_finite F
+GLIBC_2.15 __exp10l_finite F
+GLIBC_2.15 __exp2_finite F
+GLIBC_2.15 __exp2f_finite F
+GLIBC_2.15 __exp2l_finite F
+GLIBC_2.15 __exp_finite F
+GLIBC_2.15 __expf_finite F
+GLIBC_2.15 __expl_finite F
+GLIBC_2.15 __fmod_finite F
+GLIBC_2.15 __fmodf_finite F
+GLIBC_2.15 __fmodl_finite F
+GLIBC_2.15 __gamma_r_finite F
+GLIBC_2.15 __gammaf_r_finite F
+GLIBC_2.15 __gammal_r_finite F
+GLIBC_2.15 __hypot_finite F
+GLIBC_2.15 __hypotf_finite F
+GLIBC_2.15 __hypotl_finite F
+GLIBC_2.15 __j0_finite F
+GLIBC_2.15 __j0f_finite F
+GLIBC_2.15 __j0l_finite F
+GLIBC_2.15 __j1_finite F
+GLIBC_2.15 __j1f_finite F
+GLIBC_2.15 __j1l_finite F
+GLIBC_2.15 __jn_finite F
+GLIBC_2.15 __jnf_finite F
+GLIBC_2.15 __jnl_finite F
+GLIBC_2.15 __lgamma_r_finite F
+GLIBC_2.15 __lgammaf_r_finite F
+GLIBC_2.15 __lgammal_r_finite F
+GLIBC_2.15 __log10_finite F
+GLIBC_2.15 __log10f_finite F
+GLIBC_2.15 __log10l_finite F
+GLIBC_2.15 __log2_finite F
+GLIBC_2.15 __log2f_finite F
+GLIBC_2.15 __log2l_finite F
+GLIBC_2.15 __log_finite F
+GLIBC_2.15 __logf_finite F
+GLIBC_2.15 __logl_finite F
+GLIBC_2.15 __pow_finite F
+GLIBC_2.15 __powf_finite F
+GLIBC_2.15 __powl_finite F
+GLIBC_2.15 __remainder_finite F
+GLIBC_2.15 __remainderf_finite F
+GLIBC_2.15 __remainderl_finite F
+GLIBC_2.15 __scalb_finite F
+GLIBC_2.15 __scalbf_finite F
+GLIBC_2.15 __scalbl_finite F
+GLIBC_2.15 __sinh_finite F
+GLIBC_2.15 __sinhf_finite F
+GLIBC_2.15 __sinhl_finite F
+GLIBC_2.15 __sqrt_finite F
+GLIBC_2.15 __sqrtf_finite F
+GLIBC_2.15 __y0_finite F
+GLIBC_2.15 __y0f_finite F
+GLIBC_2.15 __y0l_finite F
+GLIBC_2.15 __y1_finite F
+GLIBC_2.15 __y1f_finite F
+GLIBC_2.15 __y1l_finite F
+GLIBC_2.15 __yn_finite F
+GLIBC_2.15 __ynf_finite F
+GLIBC_2.15 __ynl_finite F
+GLIBC_2.18 __issignaling F
+GLIBC_2.18 __issignalingf F
+GLIBC_2.18 __issignalingl F
+GLIBC_2.18 __sqrt_finite F
+GLIBC_2.18 __sqrtf_finite F
+GLIBC_2.18 __sqrtl_finite F
+GLIBC_2.2 feclearexcept F
+GLIBC_2.2 fedisableexcept F
+GLIBC_2.2 feenableexcept F
+GLIBC_2.2 fegetenv F
+GLIBC_2.2 fegetexcept F
+GLIBC_2.2 fegetexceptflag F
+GLIBC_2.2 feraiseexcept F
+GLIBC_2.2 fesetenv F
+GLIBC_2.2 fesetexceptflag F
+GLIBC_2.2 feupdateenv F
+GLIBC_2.23 __signgam D 0x4
+GLIBC_2.23 lgamma F
+GLIBC_2.23 lgammaf F
+GLIBC_2.23 lgammal F
+GLIBC_2.24 nextdown F
+GLIBC_2.24 nextdownf F
+GLIBC_2.24 nextdownl F
+GLIBC_2.24 nextup F
+GLIBC_2.24 nextupf F
+GLIBC_2.24 nextupl F
+GLIBC_2.25 __iseqsig F
+GLIBC_2.25 __iseqsigf F
+GLIBC_2.25 __iseqsigl F
+GLIBC_2.25 canonicalize F
+GLIBC_2.25 canonicalizef F
+GLIBC_2.25 canonicalizel F
+GLIBC_2.25 fegetmode F
+GLIBC_2.25 fesetexcept F
+GLIBC_2.25 fesetmode F
+GLIBC_2.25 fetestexceptflag F
+GLIBC_2.25 fmaxmag F
+GLIBC_2.25 fmaxmagf F
+GLIBC_2.25 fmaxmagl F
+GLIBC_2.25 fminmag F
+GLIBC_2.25 fminmagf F
+GLIBC_2.25 fminmagl F
+GLIBC_2.25 fromfp F
+GLIBC_2.25 fromfpf F
+GLIBC_2.25 fromfpl F
+GLIBC_2.25 fromfpx F
+GLIBC_2.25 fromfpxf F
+GLIBC_2.25 fromfpxl F
+GLIBC_2.25 getpayload F
+GLIBC_2.25 getpayloadf F
+GLIBC_2.25 getpayloadl F
+GLIBC_2.25 llogb F
+GLIBC_2.25 llogbf F
+GLIBC_2.25 llogbl F
+GLIBC_2.25 roundeven F
+GLIBC_2.25 roundevenf F
+GLIBC_2.25 roundevenl F
+GLIBC_2.25 setpayload F
+GLIBC_2.25 setpayloadf F
+GLIBC_2.25 setpayloadl F
+GLIBC_2.25 setpayloadsig F
+GLIBC_2.25 setpayloadsigf F
+GLIBC_2.25 setpayloadsigl F
+GLIBC_2.25 totalorder F
+GLIBC_2.25 totalorderf F
+GLIBC_2.25 totalorderl F
+GLIBC_2.25 totalordermag F
+GLIBC_2.25 totalordermagf F
+GLIBC_2.25 totalordermagl F
+GLIBC_2.25 ufromfp F
+GLIBC_2.25 ufromfpf F
+GLIBC_2.25 ufromfpl F
+GLIBC_2.25 ufromfpx F
+GLIBC_2.25 ufromfpxf F
+GLIBC_2.25 ufromfpxl F
+GLIBC_2.27 acosf128 F
+GLIBC_2.27 acosf32 F
+GLIBC_2.27 acosf32x F
+GLIBC_2.27 acosf64 F
+GLIBC_2.27 acosf64x F
+GLIBC_2.27 acoshf128 F
+GLIBC_2.27 acoshf32 F
+GLIBC_2.27 acoshf32x F
+GLIBC_2.27 acoshf64 F
+GLIBC_2.27 acoshf64x F
+GLIBC_2.27 asinf128 F
+GLIBC_2.27 asinf32 F
+GLIBC_2.27 asinf32x F
+GLIBC_2.27 asinf64 F
+GLIBC_2.27 asinf64x F
+GLIBC_2.27 asinhf128 F
+GLIBC_2.27 asinhf32 F
+GLIBC_2.27 asinhf32x F
+GLIBC_2.27 asinhf64 F
+GLIBC_2.27 asinhf64x F
+GLIBC_2.27 atan2f128 F
+GLIBC_2.27 atan2f32 F
+GLIBC_2.27 atan2f32x F
+GLIBC_2.27 atan2f64 F
+GLIBC_2.27 atan2f64x F
+GLIBC_2.27 atanf128 F
+GLIBC_2.27 atanf32 F
+GLIBC_2.27 atanf32x F
+GLIBC_2.27 atanf64 F
+GLIBC_2.27 atanf64x F
+GLIBC_2.27 atanhf128 F
+GLIBC_2.27 atanhf32 F
+GLIBC_2.27 atanhf32x F
+GLIBC_2.27 atanhf64 F
+GLIBC_2.27 atanhf64x F
+GLIBC_2.27 cabsf128 F
+GLIBC_2.27 cabsf32 F
+GLIBC_2.27 cabsf32x F
+GLIBC_2.27 cabsf64 F
+GLIBC_2.27 cabsf64x F
+GLIBC_2.27 cacosf128 F
+GLIBC_2.27 cacosf32 F
+GLIBC_2.27 cacosf32x F
+GLIBC_2.27 cacosf64 F
+GLIBC_2.27 cacosf64x F
+GLIBC_2.27 cacoshf128 F
+GLIBC_2.27 cacoshf32 F
+GLIBC_2.27 cacoshf32x F
+GLIBC_2.27 cacoshf64 F
+GLIBC_2.27 cacoshf64x F
+GLIBC_2.27 canonicalizef128 F
+GLIBC_2.27 canonicalizef32 F
+GLIBC_2.27 canonicalizef32x F
+GLIBC_2.27 canonicalizef64 F
+GLIBC_2.27 canonicalizef64x F
+GLIBC_2.27 cargf128 F
+GLIBC_2.27 cargf32 F
+GLIBC_2.27 cargf32x F
+GLIBC_2.27 cargf64 F
+GLIBC_2.27 cargf64x F
+GLIBC_2.27 casinf128 F
+GLIBC_2.27 casinf32 F
+GLIBC_2.27 casinf32x F
+GLIBC_2.27 casinf64 F
+GLIBC_2.27 casinf64x F
+GLIBC_2.27 casinhf128 F
+GLIBC_2.27 casinhf32 F
+GLIBC_2.27 casinhf32x F
+GLIBC_2.27 casinhf64 F
+GLIBC_2.27 casinhf64x F
+GLIBC_2.27 catanf128 F
+GLIBC_2.27 catanf32 F
+GLIBC_2.27 catanf32x F
+GLIBC_2.27 catanf64 F
+GLIBC_2.27 catanf64x F
+GLIBC_2.27 catanhf128 F
+GLIBC_2.27 catanhf32 F
+GLIBC_2.27 catanhf32x F
+GLIBC_2.27 catanhf64 F
+GLIBC_2.27 catanhf64x F
+GLIBC_2.27 cbrtf128 F
+GLIBC_2.27 cbrtf32 F
+GLIBC_2.27 cbrtf32x F
+GLIBC_2.27 cbrtf64 F
+GLIBC_2.27 cbrtf64x F
+GLIBC_2.27 ccosf128 F
+GLIBC_2.27 ccosf32 F
+GLIBC_2.27 ccosf32x F
+GLIBC_2.27 ccosf64 F
+GLIBC_2.27 ccosf64x F
+GLIBC_2.27 ccoshf128 F
+GLIBC_2.27 ccoshf32 F
+GLIBC_2.27 ccoshf32x F
+GLIBC_2.27 ccoshf64 F
+GLIBC_2.27 ccoshf64x F
+GLIBC_2.27 ceilf128 F
+GLIBC_2.27 ceilf32 F
+GLIBC_2.27 ceilf32x F
+GLIBC_2.27 ceilf64 F
+GLIBC_2.27 ceilf64x F
+GLIBC_2.27 cexpf128 F
+GLIBC_2.27 cexpf32 F
+GLIBC_2.27 cexpf32x F
+GLIBC_2.27 cexpf64 F
+GLIBC_2.27 cexpf64x F
+GLIBC_2.27 cimagf128 F
+GLIBC_2.27 cimagf32 F
+GLIBC_2.27 cimagf32x F
+GLIBC_2.27 cimagf64 F
+GLIBC_2.27 cimagf64x F
+GLIBC_2.27 clog10f128 F
+GLIBC_2.27 clog10f32 F
+GLIBC_2.27 clog10f32x F
+GLIBC_2.27 clog10f64 F
+GLIBC_2.27 clog10f64x F
+GLIBC_2.27 clogf128 F
+GLIBC_2.27 clogf32 F
+GLIBC_2.27 clogf32x F
+GLIBC_2.27 clogf64 F
+GLIBC_2.27 clogf64x F
+GLIBC_2.27 conjf128 F
+GLIBC_2.27 conjf32 F
+GLIBC_2.27 conjf32x F
+GLIBC_2.27 conjf64 F
+GLIBC_2.27 conjf64x F
+GLIBC_2.27 copysignf128 F
+GLIBC_2.27 copysignf32 F
+GLIBC_2.27 copysignf32x F
+GLIBC_2.27 copysignf64 F
+GLIBC_2.27 copysignf64x F
+GLIBC_2.27 cosf128 F
+GLIBC_2.27 cosf32 F
+GLIBC_2.27 cosf32x F
+GLIBC_2.27 cosf64 F
+GLIBC_2.27 cosf64x F
+GLIBC_2.27 coshf128 F
+GLIBC_2.27 coshf32 F
+GLIBC_2.27 coshf32x F
+GLIBC_2.27 coshf64 F
+GLIBC_2.27 coshf64x F
+GLIBC_2.27 cpowf128 F
+GLIBC_2.27 cpowf32 F
+GLIBC_2.27 cpowf32x F
+GLIBC_2.27 cpowf64 F
+GLIBC_2.27 cpowf64x F
+GLIBC_2.27 cprojf128 F
+GLIBC_2.27 cprojf32 F
+GLIBC_2.27 cprojf32x F
+GLIBC_2.27 cprojf64 F
+GLIBC_2.27 cprojf64x F
+GLIBC_2.27 crealf128 F
+GLIBC_2.27 crealf32 F
+GLIBC_2.27 crealf32x F
+GLIBC_2.27 crealf64 F
+GLIBC_2.27 crealf64x F
+GLIBC_2.27 csinf128 F
+GLIBC_2.27 csinf32 F
+GLIBC_2.27 csinf32x F
+GLIBC_2.27 csinf64 F
+GLIBC_2.27 csinf64x F
+GLIBC_2.27 csinhf128 F
+GLIBC_2.27 csinhf32 F
+GLIBC_2.27 csinhf32x F
+GLIBC_2.27 csinhf64 F
+GLIBC_2.27 csinhf64x F
+GLIBC_2.27 csqrtf128 F
+GLIBC_2.27 csqrtf32 F
+GLIBC_2.27 csqrtf32x F
+GLIBC_2.27 csqrtf64 F
+GLIBC_2.27 csqrtf64x F
+GLIBC_2.27 ctanf128 F
+GLIBC_2.27 ctanf32 F
+GLIBC_2.27 ctanf32x F
+GLIBC_2.27 ctanf64 F
+GLIBC_2.27 ctanf64x F
+GLIBC_2.27 ctanhf128 F
+GLIBC_2.27 ctanhf32 F
+GLIBC_2.27 ctanhf32x F
+GLIBC_2.27 ctanhf64 F
+GLIBC_2.27 ctanhf64x F
+GLIBC_2.27 erfcf128 F
+GLIBC_2.27 erfcf32 F
+GLIBC_2.27 erfcf32x F
+GLIBC_2.27 erfcf64 F
+GLIBC_2.27 erfcf64x F
+GLIBC_2.27 erff128 F
+GLIBC_2.27 erff32 F
+GLIBC_2.27 erff32x F
+GLIBC_2.27 erff64 F
+GLIBC_2.27 erff64x F
+GLIBC_2.27 exp10f128 F
+GLIBC_2.27 exp10f32 F
+GLIBC_2.27 exp10f32x F
+GLIBC_2.27 exp10f64 F
+GLIBC_2.27 exp10f64x F
+GLIBC_2.27 exp2f F
+GLIBC_2.27 exp2f128 F
+GLIBC_2.27 exp2f32 F
+GLIBC_2.27 exp2f32x F
+GLIBC_2.27 exp2f64 F
+GLIBC_2.27 exp2f64x F
+GLIBC_2.27 expf F
+GLIBC_2.27 expf128 F
+GLIBC_2.27 expf32 F
+GLIBC_2.27 expf32x F
+GLIBC_2.27 expf64 F
+GLIBC_2.27 expf64x F
+GLIBC_2.27 expm1f128 F
+GLIBC_2.27 expm1f32 F
+GLIBC_2.27 expm1f32x F
+GLIBC_2.27 expm1f64 F
+GLIBC_2.27 expm1f64x F
+GLIBC_2.27 fabsf128 F
+GLIBC_2.27 fabsf32 F
+GLIBC_2.27 fabsf32x F
+GLIBC_2.27 fabsf64 F
+GLIBC_2.27 fabsf64x F
+GLIBC_2.27 fdimf128 F
+GLIBC_2.27 fdimf32 F
+GLIBC_2.27 fdimf32x F
+GLIBC_2.27 fdimf64 F
+GLIBC_2.27 fdimf64x F
+GLIBC_2.27 floorf128 F
+GLIBC_2.27 floorf32 F
+GLIBC_2.27 floorf32x F
+GLIBC_2.27 floorf64 F
+GLIBC_2.27 floorf64x F
+GLIBC_2.27 fmaf128 F
+GLIBC_2.27 fmaf32 F
+GLIBC_2.27 fmaf32x F
+GLIBC_2.27 fmaf64 F
+GLIBC_2.27 fmaf64x F
+GLIBC_2.27 fmaxf128 F
+GLIBC_2.27 fmaxf32 F
+GLIBC_2.27 fmaxf32x F
+GLIBC_2.27 fmaxf64 F
+GLIBC_2.27 fmaxf64x F
+GLIBC_2.27 fmaxmagf128 F
+GLIBC_2.27 fmaxmagf32 F
+GLIBC_2.27 fmaxmagf32x F
+GLIBC_2.27 fmaxmagf64 F
+GLIBC_2.27 fmaxmagf64x F
+GLIBC_2.27 fminf128 F
+GLIBC_2.27 fminf32 F
+GLIBC_2.27 fminf32x F
+GLIBC_2.27 fminf64 F
+GLIBC_2.27 fminf64x F
+GLIBC_2.27 fminmagf128 F
+GLIBC_2.27 fminmagf32 F
+GLIBC_2.27 fminmagf32x F
+GLIBC_2.27 fminmagf64 F
+GLIBC_2.27 fminmagf64x F
+GLIBC_2.27 fmodf128 F
+GLIBC_2.27 fmodf32 F
+GLIBC_2.27 fmodf32x F
+GLIBC_2.27 fmodf64 F
+GLIBC_2.27 fmodf64x F
+GLIBC_2.27 frexpf128 F
+GLIBC_2.27 frexpf32 F
+GLIBC_2.27 frexpf32x F
+GLIBC_2.27 frexpf64 F
+GLIBC_2.27 frexpf64x F
+GLIBC_2.27 fromfpf128 F
+GLIBC_2.27 fromfpf32 F
+GLIBC_2.27 fromfpf32x F
+GLIBC_2.27 fromfpf64 F
+GLIBC_2.27 fromfpf64x F
+GLIBC_2.27 fromfpxf128 F
+GLIBC_2.27 fromfpxf32 F
+GLIBC_2.27 fromfpxf32x F
+GLIBC_2.27 fromfpxf64 F
+GLIBC_2.27 fromfpxf64x F
+GLIBC_2.27 getpayloadf128 F
+GLIBC_2.27 getpayloadf32 F
+GLIBC_2.27 getpayloadf32x F
+GLIBC_2.27 getpayloadf64 F
+GLIBC_2.27 getpayloadf64x F
+GLIBC_2.27 hypotf128 F
+GLIBC_2.27 hypotf32 F
+GLIBC_2.27 hypotf32x F
+GLIBC_2.27 hypotf64 F
+GLIBC_2.27 hypotf64x F
+GLIBC_2.27 ilogbf128 F
+GLIBC_2.27 ilogbf32 F
+GLIBC_2.27 ilogbf32x F
+GLIBC_2.27 ilogbf64 F
+GLIBC_2.27 ilogbf64x F
+GLIBC_2.27 j0f128 F
+GLIBC_2.27 j0f32 F
+GLIBC_2.27 j0f32x F
+GLIBC_2.27 j0f64 F
+GLIBC_2.27 j0f64x F
+GLIBC_2.27 j1f128 F
+GLIBC_2.27 j1f32 F
+GLIBC_2.27 j1f32x F
+GLIBC_2.27 j1f64 F
+GLIBC_2.27 j1f64x F
+GLIBC_2.27 jnf128 F
+GLIBC_2.27 jnf32 F
+GLIBC_2.27 jnf32x F
+GLIBC_2.27 jnf64 F
+GLIBC_2.27 jnf64x F
+GLIBC_2.27 ldexpf128 F
+GLIBC_2.27 ldexpf32 F
+GLIBC_2.27 ldexpf32x F
+GLIBC_2.27 ldexpf64 F
+GLIBC_2.27 ldexpf64x F
+GLIBC_2.27 lgammaf128 F
+GLIBC_2.27 lgammaf128_r F
+GLIBC_2.27 lgammaf32 F
+GLIBC_2.27 lgammaf32_r F
+GLIBC_2.27 lgammaf32x F
+GLIBC_2.27 lgammaf32x_r F
+GLIBC_2.27 lgammaf64 F
+GLIBC_2.27 lgammaf64_r F
+GLIBC_2.27 lgammaf64x F
+GLIBC_2.27 lgammaf64x_r F
+GLIBC_2.27 llogbf128 F
+GLIBC_2.27 llogbf32 F
+GLIBC_2.27 llogbf32x F
+GLIBC_2.27 llogbf64 F
+GLIBC_2.27 llogbf64x F
+GLIBC_2.27 llrintf128 F
+GLIBC_2.27 llrintf32 F
+GLIBC_2.27 llrintf32x F
+GLIBC_2.27 llrintf64 F
+GLIBC_2.27 llrintf64x F
+GLIBC_2.27 llroundf128 F
+GLIBC_2.27 llroundf32 F
+GLIBC_2.27 llroundf32x F
+GLIBC_2.27 llroundf64 F
+GLIBC_2.27 llroundf64x F
+GLIBC_2.27 log10f128 F
+GLIBC_2.27 log10f32 F
+GLIBC_2.27 log10f32x F
+GLIBC_2.27 log10f64 F
+GLIBC_2.27 log10f64x F
+GLIBC_2.27 log1pf128 F
+GLIBC_2.27 log1pf32 F
+GLIBC_2.27 log1pf32x F
+GLIBC_2.27 log1pf64 F
+GLIBC_2.27 log1pf64x F
+GLIBC_2.27 log2f F
+GLIBC_2.27 log2f128 F
+GLIBC_2.27 log2f32 F
+GLIBC_2.27 log2f32x F
+GLIBC_2.27 log2f64 F
+GLIBC_2.27 log2f64x F
+GLIBC_2.27 logbf128 F
+GLIBC_2.27 logbf32 F
+GLIBC_2.27 logbf32x F
+GLIBC_2.27 logbf64 F
+GLIBC_2.27 logbf64x F
+GLIBC_2.27 logf F
+GLIBC_2.27 logf128 F
+GLIBC_2.27 logf32 F
+GLIBC_2.27 logf32x F
+GLIBC_2.27 logf64 F
+GLIBC_2.27 logf64x F
+GLIBC_2.27 lrintf128 F
+GLIBC_2.27 lrintf32 F
+GLIBC_2.27 lrintf32x F
+GLIBC_2.27 lrintf64 F
+GLIBC_2.27 lrintf64x F
+GLIBC_2.27 lroundf128 F
+GLIBC_2.27 lroundf32 F
+GLIBC_2.27 lroundf32x F
+GLIBC_2.27 lroundf64 F
+GLIBC_2.27 lroundf64x F
+GLIBC_2.27 modff128 F
+GLIBC_2.27 modff32 F
+GLIBC_2.27 modff32x F
+GLIBC_2.27 modff64 F
+GLIBC_2.27 modff64x F
+GLIBC_2.27 nanf128 F
+GLIBC_2.27 nanf32 F
+GLIBC_2.27 nanf32x F
+GLIBC_2.27 nanf64 F
+GLIBC_2.27 nanf64x F
+GLIBC_2.27 nearbyintf128 F
+GLIBC_2.27 nearbyintf32 F
+GLIBC_2.27 nearbyintf32x F
+GLIBC_2.27 nearbyintf64 F
+GLIBC_2.27 nearbyintf64x F
+GLIBC_2.27 nextafterf128 F
+GLIBC_2.27 nextafterf32 F
+GLIBC_2.27 nextafterf32x F
+GLIBC_2.27 nextafterf64 F
+GLIBC_2.27 nextafterf64x F
+GLIBC_2.27 nextdownf128 F
+GLIBC_2.27 nextdownf32 F
+GLIBC_2.27 nextdownf32x F
+GLIBC_2.27 nextdownf64 F
+GLIBC_2.27 nextdownf64x F
+GLIBC_2.27 nextupf128 F
+GLIBC_2.27 nextupf32 F
+GLIBC_2.27 nextupf32x F
+GLIBC_2.27 nextupf64 F
+GLIBC_2.27 nextupf64x F
+GLIBC_2.27 powf F
+GLIBC_2.27 powf128 F
+GLIBC_2.27 powf32 F
+GLIBC_2.27 powf32x F
+GLIBC_2.27 powf64 F
+GLIBC_2.27 powf64x F
+GLIBC_2.27 remainderf128 F
+GLIBC_2.27 remainderf32 F
+GLIBC_2.27 remainderf32x F
+GLIBC_2.27 remainderf64 F
+GLIBC_2.27 remainderf64x F
+GLIBC_2.27 remquof128 F
+GLIBC_2.27 remquof32 F
+GLIBC_2.27 remquof32x F
+GLIBC_2.27 remquof64 F
+GLIBC_2.27 remquof64x F
+GLIBC_2.27 rintf128 F
+GLIBC_2.27 rintf32 F
+GLIBC_2.27 rintf32x F
+GLIBC_2.27 rintf64 F
+GLIBC_2.27 rintf64x F
+GLIBC_2.27 roundevenf128 F
+GLIBC_2.27 roundevenf32 F
+GLIBC_2.27 roundevenf32x F
+GLIBC_2.27 roundevenf64 F
+GLIBC_2.27 roundevenf64x F
+GLIBC_2.27 roundf128 F
+GLIBC_2.27 roundf32 F
+GLIBC_2.27 roundf32x F
+GLIBC_2.27 roundf64 F
+GLIBC_2.27 roundf64x F
+GLIBC_2.27 scalblnf128 F
+GLIBC_2.27 scalblnf32 F
+GLIBC_2.27 scalblnf32x F
+GLIBC_2.27 scalblnf64 F
+GLIBC_2.27 scalblnf64x F
+GLIBC_2.27 scalbnf128 F
+GLIBC_2.27 scalbnf32 F
+GLIBC_2.27 scalbnf32x F
+GLIBC_2.27 scalbnf64 F
+GLIBC_2.27 scalbnf64x F
+GLIBC_2.27 setpayloadf128 F
+GLIBC_2.27 setpayloadf32 F
+GLIBC_2.27 setpayloadf32x F
+GLIBC_2.27 setpayloadf64 F
+GLIBC_2.27 setpayloadf64x F
+GLIBC_2.27 setpayloadsigf128 F
+GLIBC_2.27 setpayloadsigf32 F
+GLIBC_2.27 setpayloadsigf32x F
+GLIBC_2.27 setpayloadsigf64 F
+GLIBC_2.27 setpayloadsigf64x F
+GLIBC_2.27 sincosf128 F
+GLIBC_2.27 sincosf32 F
+GLIBC_2.27 sincosf32x F
+GLIBC_2.27 sincosf64 F
+GLIBC_2.27 sincosf64x F
+GLIBC_2.27 sinf128 F
+GLIBC_2.27 sinf32 F
+GLIBC_2.27 sinf32x F
+GLIBC_2.27 sinf64 F
+GLIBC_2.27 sinf64x F
+GLIBC_2.27 sinhf128 F
+GLIBC_2.27 sinhf32 F
+GLIBC_2.27 sinhf32x F
+GLIBC_2.27 sinhf64 F
+GLIBC_2.27 sinhf64x F
+GLIBC_2.27 sqrtf128 F
+GLIBC_2.27 sqrtf32 F
+GLIBC_2.27 sqrtf32x F
+GLIBC_2.27 sqrtf64 F
+GLIBC_2.27 sqrtf64x F
+GLIBC_2.27 tanf128 F
+GLIBC_2.27 tanf32 F
+GLIBC_2.27 tanf32x F
+GLIBC_2.27 tanf64 F
+GLIBC_2.27 tanf64x F
+GLIBC_2.27 tanhf128 F
+GLIBC_2.27 tanhf32 F
+GLIBC_2.27 tanhf32x F
+GLIBC_2.27 tanhf64 F
+GLIBC_2.27 tanhf64x F
+GLIBC_2.27 tgammaf128 F
+GLIBC_2.27 tgammaf32 F
+GLIBC_2.27 tgammaf32x F
+GLIBC_2.27 tgammaf64 F
+GLIBC_2.27 tgammaf64x F
+GLIBC_2.27 totalorderf128 F
+GLIBC_2.27 totalorderf32 F
+GLIBC_2.27 totalorderf32x F
+GLIBC_2.27 totalorderf64 F
+GLIBC_2.27 totalorderf64x F
+GLIBC_2.27 totalordermagf128 F
+GLIBC_2.27 totalordermagf32 F
+GLIBC_2.27 totalordermagf32x F
+GLIBC_2.27 totalordermagf64 F
+GLIBC_2.27 totalordermagf64x F
+GLIBC_2.27 truncf128 F
+GLIBC_2.27 truncf32 F
+GLIBC_2.27 truncf32x F
+GLIBC_2.27 truncf64 F
+GLIBC_2.27 truncf64x F
+GLIBC_2.27 ufromfpf128 F
+GLIBC_2.27 ufromfpf32 F
+GLIBC_2.27 ufromfpf32x F
+GLIBC_2.27 ufromfpf64 F
+GLIBC_2.27 ufromfpf64x F
+GLIBC_2.27 ufromfpxf128 F
+GLIBC_2.27 ufromfpxf32 F
+GLIBC_2.27 ufromfpxf32x F
+GLIBC_2.27 ufromfpxf64 F
+GLIBC_2.27 ufromfpxf64x F
+GLIBC_2.27 y0f128 F
+GLIBC_2.27 y0f32 F
+GLIBC_2.27 y0f32x F
+GLIBC_2.27 y0f64 F
+GLIBC_2.27 y0f64x F
+GLIBC_2.27 y1f128 F
+GLIBC_2.27 y1f32 F
+GLIBC_2.27 y1f32x F
+GLIBC_2.27 y1f64 F
+GLIBC_2.27 y1f64x F
+GLIBC_2.27 ynf128 F
+GLIBC_2.27 ynf32 F
+GLIBC_2.27 ynf32x F
+GLIBC_2.27 ynf64 F
+GLIBC_2.27 ynf64x F
+GLIBC_2.28 __nldbl_daddl F
+GLIBC_2.28 __nldbl_ddivl F
+GLIBC_2.28 __nldbl_dmull F
+GLIBC_2.28 __nldbl_dsubl F
+GLIBC_2.28 daddl F
+GLIBC_2.28 ddivl F
+GLIBC_2.28 dmull F
+GLIBC_2.28 dsubl F
+GLIBC_2.28 f32addf128 F
+GLIBC_2.28 f32addf32x F
+GLIBC_2.28 f32addf64 F
+GLIBC_2.28 f32addf64x F
+GLIBC_2.28 f32divf128 F
+GLIBC_2.28 f32divf32x F
+GLIBC_2.28 f32divf64 F
+GLIBC_2.28 f32divf64x F
+GLIBC_2.28 f32mulf128 F
+GLIBC_2.28 f32mulf32x F
+GLIBC_2.28 f32mulf64 F
+GLIBC_2.28 f32mulf64x F
+GLIBC_2.28 f32subf128 F
+GLIBC_2.28 f32subf32x F
+GLIBC_2.28 f32subf64 F
+GLIBC_2.28 f32subf64x F
+GLIBC_2.28 f32xaddf128 F
+GLIBC_2.28 f32xaddf64 F
+GLIBC_2.28 f32xaddf64x F
+GLIBC_2.28 f32xdivf128 F
+GLIBC_2.28 f32xdivf64 F
+GLIBC_2.28 f32xdivf64x F
+GLIBC_2.28 f32xmulf128 F
+GLIBC_2.28 f32xmulf64 F
+GLIBC_2.28 f32xmulf64x F
+GLIBC_2.28 f32xsubf128 F
+GLIBC_2.28 f32xsubf64 F
+GLIBC_2.28 f32xsubf64x F
+GLIBC_2.28 f64addf128 F
+GLIBC_2.28 f64addf64x F
+GLIBC_2.28 f64divf128 F
+GLIBC_2.28 f64divf64x F
+GLIBC_2.28 f64mulf128 F
+GLIBC_2.28 f64mulf64x F
+GLIBC_2.28 f64subf128 F
+GLIBC_2.28 f64subf64x F
+GLIBC_2.28 f64xaddf128 F
+GLIBC_2.28 f64xdivf128 F
+GLIBC_2.28 f64xmulf128 F
+GLIBC_2.28 f64xsubf128 F
+GLIBC_2.28 fadd F
+GLIBC_2.28 faddl F
+GLIBC_2.28 fdiv F
+GLIBC_2.28 fdivl F
+GLIBC_2.28 fmul F
+GLIBC_2.28 fmull F
+GLIBC_2.28 fsub F
+GLIBC_2.28 fsubl F
+GLIBC_2.29 exp F
+GLIBC_2.29 exp2 F
+GLIBC_2.29 log F
+GLIBC_2.29 log2 F
+GLIBC_2.29 pow F
+GLIBC_2.3.4 __c1_cabsf F
+GLIBC_2.3.4 __c1_cacosf F
+GLIBC_2.3.4 __c1_cacoshf F
+GLIBC_2.3.4 __c1_cargf F
+GLIBC_2.3.4 __c1_casinf F
+GLIBC_2.3.4 __c1_casinhf F
+GLIBC_2.3.4 __c1_catanf F
+GLIBC_2.3.4 __c1_catanhf F
+GLIBC_2.3.4 __c1_ccosf F
+GLIBC_2.3.4 __c1_ccoshf F
+GLIBC_2.3.4 __c1_cexpf F
+GLIBC_2.3.4 __c1_cimagf F
+GLIBC_2.3.4 __c1_clog10f F
+GLIBC_2.3.4 __c1_clogf F
+GLIBC_2.3.4 __c1_conjf F
+GLIBC_2.3.4 __c1_cpowf F
+GLIBC_2.3.4 __c1_cprojf F
+GLIBC_2.3.4 __c1_crealf F
+GLIBC_2.3.4 __c1_csinf F
+GLIBC_2.3.4 __c1_csinhf F
+GLIBC_2.3.4 __c1_csqrtf F
+GLIBC_2.3.4 __c1_ctanf F
+GLIBC_2.3.4 __c1_ctanhf F
+GLIBC_2.3.4 cabsf F
+GLIBC_2.3.4 cacosf F
+GLIBC_2.3.4 cacoshf F
+GLIBC_2.3.4 cargf F
+GLIBC_2.3.4 casinf F
+GLIBC_2.3.4 casinhf F
+GLIBC_2.3.4 catanf F
+GLIBC_2.3.4 catanhf F
+GLIBC_2.3.4 ccosf F
+GLIBC_2.3.4 ccoshf F
+GLIBC_2.3.4 cexpf F
+GLIBC_2.3.4 cimagf F
+GLIBC_2.3.4 clog10f F
+GLIBC_2.3.4 clogf F
+GLIBC_2.3.4 conjf F
+GLIBC_2.3.4 cpowf F
+GLIBC_2.3.4 cprojf F
+GLIBC_2.3.4 crealf F
+GLIBC_2.3.4 csinf F
+GLIBC_2.3.4 csinhf F
+GLIBC_2.3.4 csqrtf F
+GLIBC_2.3.4 ctanf F
+GLIBC_2.3.4 ctanhf F
+GLIBC_2.31 totalorder F
+GLIBC_2.31 totalorderf F
+GLIBC_2.31 totalorderf128 F
+GLIBC_2.31 totalorderf32 F
+GLIBC_2.31 totalorderf32x F
+GLIBC_2.31 totalorderf64 F
+GLIBC_2.31 totalorderf64x F
+GLIBC_2.31 totalorderl F
+GLIBC_2.31 totalordermag F
+GLIBC_2.31 totalordermagf F
+GLIBC_2.31 totalordermagf128 F
+GLIBC_2.31 totalordermagf32 F
+GLIBC_2.31 totalordermagf32x F
+GLIBC_2.31 totalordermagf64 F
+GLIBC_2.31 totalordermagf64x F
+GLIBC_2.31 totalordermagl F
+GLIBC_2.32 exp10f F
+GLIBC_2.35 dfmal F
+GLIBC_2.35 dsqrtl F
+GLIBC_2.35 f32fmaf128 F
+GLIBC_2.35 f32fmaf32x F
+GLIBC_2.35 f32fmaf64 F
+GLIBC_2.35 f32fmaf64x F
+GLIBC_2.35 f32sqrtf128 F
+GLIBC_2.35 f32sqrtf32x F
+GLIBC_2.35 f32sqrtf64 F
+GLIBC_2.35 f32sqrtf64x F
+GLIBC_2.35 f32xfmaf128 F
+GLIBC_2.35 f32xfmaf64 F
+GLIBC_2.35 f32xfmaf64x F
+GLIBC_2.35 f32xsqrtf128 F
+GLIBC_2.35 f32xsqrtf64 F
+GLIBC_2.35 f32xsqrtf64x F
+GLIBC_2.35 f64fmaf128 F
+GLIBC_2.35 f64fmaf64x F
+GLIBC_2.35 f64sqrtf128 F
+GLIBC_2.35 f64sqrtf64x F
+GLIBC_2.35 f64xfmaf128 F
+GLIBC_2.35 f64xsqrtf128 F
+GLIBC_2.35 ffma F
+GLIBC_2.35 ffmal F
+GLIBC_2.35 fmaximum F
+GLIBC_2.35 fmaximum_mag F
+GLIBC_2.35 fmaximum_mag_num F
+GLIBC_2.35 fmaximum_mag_numf F
+GLIBC_2.35 fmaximum_mag_numf128 F
+GLIBC_2.35 fmaximum_mag_numf32 F
+GLIBC_2.35 fmaximum_mag_numf32x F
+GLIBC_2.35 fmaximum_mag_numf64 F
+GLIBC_2.35 fmaximum_mag_numf64x F
+GLIBC_2.35 fmaximum_mag_numl F
+GLIBC_2.35 fmaximum_magf F
+GLIBC_2.35 fmaximum_magf128 F
+GLIBC_2.35 fmaximum_magf32 F
+GLIBC_2.35 fmaximum_magf32x F
+GLIBC_2.35 fmaximum_magf64 F
+GLIBC_2.35 fmaximum_magf64x F
+GLIBC_2.35 fmaximum_magl F
+GLIBC_2.35 fmaximum_num F
+GLIBC_2.35 fmaximum_numf F
+GLIBC_2.35 fmaximum_numf128 F
+GLIBC_2.35 fmaximum_numf32 F
+GLIBC_2.35 fmaximum_numf32x F
+GLIBC_2.35 fmaximum_numf64 F
+GLIBC_2.35 fmaximum_numf64x F
+GLIBC_2.35 fmaximum_numl F
+GLIBC_2.35 fmaximumf F
+GLIBC_2.35 fmaximumf128 F
+GLIBC_2.35 fmaximumf32 F
+GLIBC_2.35 fmaximumf32x F
+GLIBC_2.35 fmaximumf64 F
+GLIBC_2.35 fmaximumf64x F
+GLIBC_2.35 fmaximuml F
+GLIBC_2.35 fminimum F
+GLIBC_2.35 fminimum_mag F
+GLIBC_2.35 fminimum_mag_num F
+GLIBC_2.35 fminimum_mag_numf F
+GLIBC_2.35 fminimum_mag_numf128 F
+GLIBC_2.35 fminimum_mag_numf32 F
+GLIBC_2.35 fminimum_mag_numf32x F
+GLIBC_2.35 fminimum_mag_numf64 F
+GLIBC_2.35 fminimum_mag_numf64x F
+GLIBC_2.35 fminimum_mag_numl F
+GLIBC_2.35 fminimum_magf F
+GLIBC_2.35 fminimum_magf128 F
+GLIBC_2.35 fminimum_magf32 F
+GLIBC_2.35 fminimum_magf32x F
+GLIBC_2.35 fminimum_magf64 F
+GLIBC_2.35 fminimum_magf64x F
+GLIBC_2.35 fminimum_magl F
+GLIBC_2.35 fminimum_num F
+GLIBC_2.35 fminimum_numf F
+GLIBC_2.35 fminimum_numf128 F
+GLIBC_2.35 fminimum_numf32 F
+GLIBC_2.35 fminimum_numf32x F
+GLIBC_2.35 fminimum_numf64 F
+GLIBC_2.35 fminimum_numf64x F
+GLIBC_2.35 fminimum_numl F
+GLIBC_2.35 fminimumf F
+GLIBC_2.35 fminimumf128 F
+GLIBC_2.35 fminimumf32 F
+GLIBC_2.35 fminimumf32x F
+GLIBC_2.35 fminimumf64 F
+GLIBC_2.35 fminimumf64x F
+GLIBC_2.35 fminimuml F
+GLIBC_2.35 fsqrt F
+GLIBC_2.35 fsqrtl F
+GLIBC_2.35 hypot F
+GLIBC_2.35 hypotf F
+GLIBC_2.38 fmod F
+GLIBC_2.38 fmodf F
+GLIBC_2.4 __clog10l F
+GLIBC_2.4 __finitel F
+GLIBC_2.4 __fpclassifyl F
+GLIBC_2.4 __nldbl_nexttowardf F
+GLIBC_2.4 __signbitl F
+GLIBC_2.4 acoshl F
+GLIBC_2.4 acosl F
+GLIBC_2.4 asinhl F
+GLIBC_2.4 asinl F
+GLIBC_2.4 atan2l F
+GLIBC_2.4 atanhl F
+GLIBC_2.4 atanl F
+GLIBC_2.4 cabsl F
+GLIBC_2.4 cacoshl F
+GLIBC_2.4 cacosl F
+GLIBC_2.4 cargl F
+GLIBC_2.4 casinhl F
+GLIBC_2.4 casinl F
+GLIBC_2.4 catanhl F
+GLIBC_2.4 catanl F
+GLIBC_2.4 cbrtl F
+GLIBC_2.4 ccoshl F
+GLIBC_2.4 ccosl F
+GLIBC_2.4 ceill F
+GLIBC_2.4 cexpl F
+GLIBC_2.4 cimagl F
+GLIBC_2.4 clog10l F
+GLIBC_2.4 clogl F
+GLIBC_2.4 conjl F
+GLIBC_2.4 copysignl F
+GLIBC_2.4 coshl F
+GLIBC_2.4 cosl F
+GLIBC_2.4 cpowl F
+GLIBC_2.4 cprojl F
+GLIBC_2.4 creall F
+GLIBC_2.4 csinhl F
+GLIBC_2.4 csinl F
+GLIBC_2.4 csqrtl F
+GLIBC_2.4 ctanhl F
+GLIBC_2.4 ctanl F
+GLIBC_2.4 dreml F
+GLIBC_2.4 erfcl F
+GLIBC_2.4 erfl F
+GLIBC_2.4 exp10l F
+GLIBC_2.4 exp2l F
+GLIBC_2.4 expl F
+GLIBC_2.4 expm1l F
+GLIBC_2.4 fabsl F
+GLIBC_2.4 fdiml F
+GLIBC_2.4 finitel F
+GLIBC_2.4 floorl F
+GLIBC_2.4 fmal F
+GLIBC_2.4 fmaxl F
+GLIBC_2.4 fminl F
+GLIBC_2.4 fmodl F
+GLIBC_2.4 frexpl F
+GLIBC_2.4 gammal F
+GLIBC_2.4 hypotl F
+GLIBC_2.4 ilogbl F
+GLIBC_2.4 j0l F
+GLIBC_2.4 j1l F
+GLIBC_2.4 jnl F
+GLIBC_2.4 ldexpl F
+GLIBC_2.4 lgammal F
+GLIBC_2.4 lgammal_r F
+GLIBC_2.4 llrintl F
+GLIBC_2.4 llroundl F
+GLIBC_2.4 log10l F
+GLIBC_2.4 log1pl F
+GLIBC_2.4 log2l F
+GLIBC_2.4 logbl F
+GLIBC_2.4 logl F
+GLIBC_2.4 lrintl F
+GLIBC_2.4 lroundl F
+GLIBC_2.4 modfl F
+GLIBC_2.4 nanl F
+GLIBC_2.4 nearbyintl F
+GLIBC_2.4 nextafterl F
+GLIBC_2.4 nexttoward F
+GLIBC_2.4 nexttowardf F
+GLIBC_2.4 nexttowardl F
+GLIBC_2.4 pow10l F
+GLIBC_2.4 powl F
+GLIBC_2.4 remainderl F
+GLIBC_2.4 remquol F
+GLIBC_2.4 rintl F
+GLIBC_2.4 roundl F
+GLIBC_2.4 scalbl F
+GLIBC_2.4 scalblnl F
+GLIBC_2.4 scalbnl F
+GLIBC_2.4 significandl F
+GLIBC_2.4 sincosl F
+GLIBC_2.4 sinhl F
+GLIBC_2.4 sinl F
+GLIBC_2.4 sqrtl F
+GLIBC_2.4 tanhl F
+GLIBC_2.4 tanl F
+GLIBC_2.4 tgammal F
+GLIBC_2.4 truncl F
+GLIBC_2.4 y0l F
+GLIBC_2.4 y1l F
+GLIBC_2.4 ynl F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libnsl.abilist b/sysdeps/unix/sysv/linux/sw_64/libnsl.abilist
new file mode 100644
index 00000000..add3d66a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libnsl.abilist
@@ -0,0 +1,121 @@
+GLIBC_2.0 __yp_check F
+GLIBC_2.0 xdr_domainname F
+GLIBC_2.0 xdr_keydat F
+GLIBC_2.0 xdr_mapname F
+GLIBC_2.0 xdr_peername F
+GLIBC_2.0 xdr_valdat F
+GLIBC_2.0 xdr_yp_buf F
+GLIBC_2.0 xdr_ypbind_binding F
+GLIBC_2.0 xdr_ypbind_resp F
+GLIBC_2.0 xdr_ypbind_resptype F
+GLIBC_2.0 xdr_ypbind_setdom F
+GLIBC_2.0 xdr_ypdelete_args F
+GLIBC_2.0 xdr_ypmap_parms F
+GLIBC_2.0 xdr_ypmaplist F
+GLIBC_2.0 xdr_yppush_status F
+GLIBC_2.0 xdr_yppushresp_xfr F
+GLIBC_2.0 xdr_ypreq_key F
+GLIBC_2.0 xdr_ypreq_nokey F
+GLIBC_2.0 xdr_ypreq_xfr F
+GLIBC_2.0 xdr_ypresp_all F
+GLIBC_2.0 xdr_ypresp_key_val F
+GLIBC_2.0 xdr_ypresp_maplist F
+GLIBC_2.0 xdr_ypresp_master F
+GLIBC_2.0 xdr_ypresp_order F
+GLIBC_2.0 xdr_ypresp_val F
+GLIBC_2.0 xdr_ypresp_xfr F
+GLIBC_2.0 xdr_ypstat F
+GLIBC_2.0 xdr_ypupdate_args F
+GLIBC_2.0 xdr_ypxfrstat F
+GLIBC_2.0 yp_all F
+GLIBC_2.0 yp_bind F
+GLIBC_2.0 yp_first F
+GLIBC_2.0 yp_get_default_domain F
+GLIBC_2.0 yp_maplist F
+GLIBC_2.0 yp_master F
+GLIBC_2.0 yp_match F
+GLIBC_2.0 yp_next F
+GLIBC_2.0 yp_order F
+GLIBC_2.0 yp_unbind F
+GLIBC_2.0 yp_update F
+GLIBC_2.0 ypbinderr_string F
+GLIBC_2.0 yperr_string F
+GLIBC_2.0 ypprot_err F
+GLIBC_2.1 __free_fdresult F
+GLIBC_2.1 __nis_default_access F
+GLIBC_2.1 __nis_default_group F
+GLIBC_2.1 __nis_default_owner F
+GLIBC_2.1 __nis_default_ttl F
+GLIBC_2.1 __nis_finddirectory F
+GLIBC_2.1 __nis_hash F
+GLIBC_2.1 __nisbind_connect F
+GLIBC_2.1 __nisbind_create F
+GLIBC_2.1 __nisbind_destroy F
+GLIBC_2.1 __nisbind_next F
+GLIBC_2.1 nis_add F
+GLIBC_2.1 nis_add_entry F
+GLIBC_2.1 nis_addmember F
+GLIBC_2.1 nis_checkpoint F
+GLIBC_2.1 nis_clone_directory F
+GLIBC_2.1 nis_clone_object F
+GLIBC_2.1 nis_clone_result F
+GLIBC_2.1 nis_creategroup F
+GLIBC_2.1 nis_destroy_object F
+GLIBC_2.1 nis_destroygroup F
+GLIBC_2.1 nis_dir_cmp F
+GLIBC_2.1 nis_domain_of F
+GLIBC_2.1 nis_domain_of_r F
+GLIBC_2.1 nis_first_entry F
+GLIBC_2.1 nis_free_directory F
+GLIBC_2.1 nis_free_object F
+GLIBC_2.1 nis_free_request F
+GLIBC_2.1 nis_freenames F
+GLIBC_2.1 nis_freeresult F
+GLIBC_2.1 nis_freeservlist F
+GLIBC_2.1 nis_freetags F
+GLIBC_2.1 nis_getnames F
+GLIBC_2.1 nis_getservlist F
+GLIBC_2.1 nis_ismember F
+GLIBC_2.1 nis_leaf_of F
+GLIBC_2.1 nis_leaf_of_r F
+GLIBC_2.1 nis_lerror F
+GLIBC_2.1 nis_list F
+GLIBC_2.1 nis_local_directory F
+GLIBC_2.1 nis_local_group F
+GLIBC_2.1 nis_local_host F
+GLIBC_2.1 nis_local_principal F
+GLIBC_2.1 nis_lookup F
+GLIBC_2.1 nis_mkdir F
+GLIBC_2.1 nis_modify F
+GLIBC_2.1 nis_modify_entry F
+GLIBC_2.1 nis_name_of F
+GLIBC_2.1 nis_name_of_r F
+GLIBC_2.1 nis_next_entry F
+GLIBC_2.1 nis_perror F
+GLIBC_2.1 nis_ping F
+GLIBC_2.1 nis_print_directory F
+GLIBC_2.1 nis_print_entry F
+GLIBC_2.1 nis_print_group F
+GLIBC_2.1 nis_print_group_entry F
+GLIBC_2.1 nis_print_link F
+GLIBC_2.1 nis_print_object F
+GLIBC_2.1 nis_print_result F
+GLIBC_2.1 nis_print_rights F
+GLIBC_2.1 nis_print_table F
+GLIBC_2.1 nis_read_obj F
+GLIBC_2.1 nis_remove F
+GLIBC_2.1 nis_remove_entry F
+GLIBC_2.1 nis_removemember F
+GLIBC_2.1 nis_rmdir F
+GLIBC_2.1 nis_servstate F
+GLIBC_2.1 nis_sperrno F
+GLIBC_2.1 nis_sperror F
+GLIBC_2.1 nis_sperror_r F
+GLIBC_2.1 nis_stats F
+GLIBC_2.1 nis_verifygroup F
+GLIBC_2.1 nis_write_obj F
+GLIBC_2.1 readColdStartFile F
+GLIBC_2.1 writeColdStartFile F
+GLIBC_2.1 xdr_cback_data F
+GLIBC_2.1 xdr_obj_p F
+GLIBC_2.2 xdr_ypall F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libpthread.abilist b/sysdeps/unix/sysv/linux/sw_64/libpthread.abilist
new file mode 100644
index 00000000..051caff7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libpthread.abilist
@@ -0,0 +1,17 @@
+GLIBC_2.0 __libpthread_version_placeholder F
+GLIBC_2.1 __libpthread_version_placeholder F
+GLIBC_2.1.1 __libpthread_version_placeholder F
+GLIBC_2.1.2 __libpthread_version_placeholder F
+GLIBC_2.11 __libpthread_version_placeholder F
+GLIBC_2.12 __libpthread_version_placeholder F
+GLIBC_2.18 __libpthread_version_placeholder F
+GLIBC_2.2 __libpthread_version_placeholder F
+GLIBC_2.2.3 __libpthread_version_placeholder F
+GLIBC_2.2.6 __libpthread_version_placeholder F
+GLIBC_2.28 __libpthread_version_placeholder F
+GLIBC_2.3.2 __libpthread_version_placeholder F
+GLIBC_2.3.3 __libpthread_version_placeholder F
+GLIBC_2.3.4 __libpthread_version_placeholder F
+GLIBC_2.30 __libpthread_version_placeholder F
+GLIBC_2.31 __libpthread_version_placeholder F
+GLIBC_2.4 __libpthread_version_placeholder F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libresolv.abilist b/sysdeps/unix/sysv/linux/sw_64/libresolv.abilist
new file mode 100644
index 00000000..8325eae8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libresolv.abilist
@@ -0,0 +1,67 @@
+GLIBC_2.0 __b64_ntop F
+GLIBC_2.0 __b64_pton F
+GLIBC_2.0 __dn_count_labels F
+GLIBC_2.0 __fp_nquery F
+GLIBC_2.0 __fp_query F
+GLIBC_2.0 __fp_resstat F
+GLIBC_2.0 __hostalias F
+GLIBC_2.0 __loc_aton F
+GLIBC_2.0 __loc_ntoa F
+GLIBC_2.0 __p_cdname F
+GLIBC_2.0 __p_cdnname F
+GLIBC_2.0 __p_class F
+GLIBC_2.0 __p_class_syms D 0xa8
+GLIBC_2.0 __p_fqname F
+GLIBC_2.0 __p_fqnname F
+GLIBC_2.0 __p_option F
+GLIBC_2.0 __p_query F
+GLIBC_2.0 __p_secstodate F
+GLIBC_2.0 __p_time F
+GLIBC_2.0 __p_type F
+GLIBC_2.0 __p_type_syms D 0x450
+GLIBC_2.0 __putlong F
+GLIBC_2.0 __putshort F
+GLIBC_2.0 __res_close F
+GLIBC_2.0 __res_isourserver F
+GLIBC_2.0 __res_nameinquery F
+GLIBC_2.0 __res_queriesmatch F
+GLIBC_2.0 __sym_ntop F
+GLIBC_2.0 __sym_ntos F
+GLIBC_2.0 __sym_ston F
+GLIBC_2.0 _gethtbyaddr F
+GLIBC_2.0 _gethtbyname F
+GLIBC_2.0 _gethtbyname2 F
+GLIBC_2.0 _gethtent F
+GLIBC_2.0 _getlong F
+GLIBC_2.0 _getshort F
+GLIBC_2.0 _res_opcodes D 0x80
+GLIBC_2.0 _sethtent F
+GLIBC_2.0 inet_net_ntop F
+GLIBC_2.0 inet_net_pton F
+GLIBC_2.0 inet_neta F
+GLIBC_2.0 res_gethostbyaddr F
+GLIBC_2.0 res_gethostbyname F
+GLIBC_2.0 res_gethostbyname2 F
+GLIBC_2.0 res_send_setqhook F
+GLIBC_2.0 res_send_setrhook F
+GLIBC_2.2 __res_hostalias F
+GLIBC_2.3.2 __p_rcode F
+GLIBC_2.9 ns_datetosecs F
+GLIBC_2.9 ns_format_ttl F
+GLIBC_2.9 ns_get16 F
+GLIBC_2.9 ns_get32 F
+GLIBC_2.9 ns_initparse F
+GLIBC_2.9 ns_makecanon F
+GLIBC_2.9 ns_msg_getflag F
+GLIBC_2.9 ns_name_ntol F
+GLIBC_2.9 ns_name_rollback F
+GLIBC_2.9 ns_parse_ttl F
+GLIBC_2.9 ns_parserr F
+GLIBC_2.9 ns_put16 F
+GLIBC_2.9 ns_put32 F
+GLIBC_2.9 ns_samedomain F
+GLIBC_2.9 ns_samename F
+GLIBC_2.9 ns_skiprr F
+GLIBC_2.9 ns_sprintrr F
+GLIBC_2.9 ns_sprintrrf F
+GLIBC_2.9 ns_subdomain F
diff --git a/sysdeps/unix/sysv/linux/sw_64/librt-compat.c b/sysdeps/unix/sysv/linux/sw_64/librt-compat.c
new file mode 100644
index 00000000..00fe783c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/librt-compat.c
@@ -0,0 +1,24 @@
+/* Placeholder definitions to pull in removed symbol versions.  sw_64 version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/unix/sysv/linux/librt-compat.c>
+
+#if SHLIB_COMPAT (librt, GLIBC_2_3, GLIBC_2_34)
+compat_symbol (librt, __librt_version_placeholder_1,
+               __librt_version_placeholder, GLIBC_2_3);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/librt.abilist b/sysdeps/unix/sysv/linux/sw_64/librt.abilist
new file mode 100644
index 00000000..f68e03df
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/librt.abilist
@@ -0,0 +1,7 @@
+GLIBC_2.1 __librt_version_placeholder F
+GLIBC_2.2 __librt_version_placeholder F
+GLIBC_2.3 __librt_version_placeholder F
+GLIBC_2.3.3 __librt_version_placeholder F
+GLIBC_2.3.4 __librt_version_placeholder F
+GLIBC_2.4 __librt_version_placeholder F
+GLIBC_2.7 __librt_version_placeholder F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libthread_db.abilist b/sysdeps/unix/sysv/linux/sw_64/libthread_db.abilist
new file mode 100644
index 00000000..2db09927
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libthread_db.abilist
@@ -0,0 +1,40 @@
+GLIBC_2.1.3 td_init F
+GLIBC_2.1.3 td_log F
+GLIBC_2.1.3 td_ta_clear_event F
+GLIBC_2.1.3 td_ta_delete F
+GLIBC_2.1.3 td_ta_enable_stats F
+GLIBC_2.1.3 td_ta_event_addr F
+GLIBC_2.1.3 td_ta_event_getmsg F
+GLIBC_2.1.3 td_ta_get_nthreads F
+GLIBC_2.1.3 td_ta_get_ph F
+GLIBC_2.1.3 td_ta_get_stats F
+GLIBC_2.1.3 td_ta_map_id2thr F
+GLIBC_2.1.3 td_ta_map_lwp2thr F
+GLIBC_2.1.3 td_ta_new F
+GLIBC_2.1.3 td_ta_reset_stats F
+GLIBC_2.1.3 td_ta_set_event F
+GLIBC_2.1.3 td_ta_setconcurrency F
+GLIBC_2.1.3 td_ta_thr_iter F
+GLIBC_2.1.3 td_ta_tsd_iter F
+GLIBC_2.1.3 td_thr_clear_event F
+GLIBC_2.1.3 td_thr_dbresume F
+GLIBC_2.1.3 td_thr_dbsuspend F
+GLIBC_2.1.3 td_thr_event_enable F
+GLIBC_2.1.3 td_thr_event_getmsg F
+GLIBC_2.1.3 td_thr_get_info F
+GLIBC_2.1.3 td_thr_getfpregs F
+GLIBC_2.1.3 td_thr_getgregs F
+GLIBC_2.1.3 td_thr_getxregs F
+GLIBC_2.1.3 td_thr_getxregsize F
+GLIBC_2.1.3 td_thr_set_event F
+GLIBC_2.1.3 td_thr_setfpregs F
+GLIBC_2.1.3 td_thr_setgregs F
+GLIBC_2.1.3 td_thr_setprio F
+GLIBC_2.1.3 td_thr_setsigpending F
+GLIBC_2.1.3 td_thr_setxregs F
+GLIBC_2.1.3 td_thr_sigsetmask F
+GLIBC_2.1.3 td_thr_tsd F
+GLIBC_2.1.3 td_thr_validate F
+GLIBC_2.2.3 td_symbol_list F
+GLIBC_2.3 td_thr_tls_get_addr F
+GLIBC_2.3.3 td_thr_tlsbase F
diff --git a/sysdeps/unix/sysv/linux/sw_64/libutil.abilist b/sysdeps/unix/sysv/linux/sw_64/libutil.abilist
new file mode 100644
index 00000000..3d511414
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/libutil.abilist
@@ -0,0 +1 @@
+GLIBC_2.0 __libutil_version_placeholder F
diff --git a/sysdeps/unix/sysv/linux/sw_64/localplt.data b/sysdeps/unix/sysv/linux/sw_64/localplt.data
new file mode 100644
index 00000000..9dfd3f9b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/localplt.data
@@ -0,0 +1,33 @@
+libc.so: _OtsAddX ?
+libc.so: _OtsConvertFloatTX ?
+libc.so: _OtsConvertFloatXT ?
+libc.so: _OtsCvtQUX ?
+libc.so: _OtsCvtQX ?
+libc.so: _OtsCvtXQ ?
+libc.so: _OtsDivX ?
+libc.so: _OtsEqlX ?
+libc.so: _OtsGeqX ?
+libc.so: _OtsGtrX ?
+libc.so: _OtsLeqX ?
+libc.so: _OtsLssX ?
+libc.so: _OtsMulX ?
+libc.so: _OtsNeqX ?
+libc.so: _OtsNintXQ ?
+libc.so: _OtsSubX ?
+libc.so: _Unwind_Find_FDE
+libc.so: calloc + RELA R_SW_64_GLOB_DAT
+libc.so: free + RELA R_SW_64_GLOB_DAT
+libc.so: malloc + RELA R_SW_64_GLOB_DAT
+libc.so: realloc + RELA R_SW_64_GLOB_DAT
+libm.so: matherr + RELA R_SW_64_GLOB_DAT
+# We used to offer inline functions that used this, so it must be exported.
+# Ought to reorg things such that carg isn't thus forced to use a plt.
+libm.so: __atan2
+#libm.so: lround
+#libm.so: pow
+#libm.so: scalbln
+#libm.so: rint
+#libm.so: lrint
+#libm.so: remainder
+# The dynamic loader needs __tls_get_addr for TLS.
+ld.so: __tls_get_addr ?
diff --git a/sysdeps/unix/sysv/linux/sw_64/lxstat64.c b/sysdeps/unix/sysv/linux/sw_64/lxstat64.c
new file mode 100644
index 00000000..a9114347
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/lxstat64.c
@@ -0,0 +1,46 @@
+/* lxstat using old-style Unix stat system call.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __lxstat __redirect___lxstat
+#include <sys/stat.h>
+#undef __lxstat
+#include <fcntl.h>
+#include <kernel_stat.h>
+#include <sysdep.h>
+#include <xstatconv.h>
+
+/* Get information about the file NAME in BUF.  */
+int
+__lxstat64 (int vers, const char *name, struct stat64 *buf)
+{
+  switch (vers)
+    {
+    case _STAT_VER_KERNEL64:
+      return INLINE_SYSCALL_CALL (lstat64, name, buf);
+
+    default:
+      {
+        struct kernel_stat kbuf;
+	int r = INTERNAL_SYSCALL_CALL (lstat, name, &kbuf);
+	if (r == 0)
+	  return __xstat_conv (vers, &kbuf, buf);
+	return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
+      }
+    }
+}
+weak_alias (__lxstat64, __lxstat);
diff --git a/sysdeps/unix/sysv/linux/sw_64/makecontext.S b/sysdeps/unix/sysv/linux/sw_64/makecontext.S
new file mode 100644
index 00000000..75996804
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/makecontext.S
@@ -0,0 +1,164 @@
+/* Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <ucontext-offsets.h>
+
+
+ENTRY(__makecontext)
+	ldgp	$29, 0($27)
+#ifdef PROF
+	.set noat
+	ldi     AT, _mcount
+	call     AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	/* Compute top of stack, including arguments.  */
+	ldl	$1, UC_STACK+SS_SP($16)
+	ldl	$2, UC_STACK+SS_SIZE($16)
+	addl	$1, $2, $8
+	subl	$18, 6, $1
+	sellt	$1, 0, $1, $1
+	s8addl	$1, 0, $2
+	subl	$8, $2, $8
+        bic     $8,0xf,$8 /* Keep the stack aligned ,mod by zhangf  */
+
+	/* Copy all parameters.  Switch statement header here.  */
+	ldih	$3, $jumptable($29)	!gprelhigh
+	cmple	$18, 6, $1
+	mov	$18, $2
+	seleq	$1, 7, $2, $2
+	s4addl	$2, $3, $3
+	ldw	$4, $jumptable($3)	!gprellow
+	addl	$4, $29, $4
+	jmp	$31, ($4), $args1
+
+	.section .rodata
+	.align	2
+$jumptable:
+	.gprel32  $args0
+	.gprel32  $args1
+	.gprel32  $args2
+	.gprel32  $args3
+	.gprel32  $args4
+	.gprel32  $args5
+	.gprel32  $args6
+	.gprel32  $argsN
+	.text
+
+	/* Here we process arguments 7 through N.  This is a straight
+	   stack-to-stack copy.  */
+	.align	4
+$argsN:
+	subl	$18, 6, $1
+	ldi	$2, 0($8)
+	ldi	$3, 3*8($30)
+	.align	4
+1:
+	ldl	$0, 0($3)
+	subl	$1, 1, $1
+	ldi	$3, 8($3)
+	stl	$0, 0($2)
+	ldi	$2, 8($2)
+	bne	$1, 1b
+
+	/* Here we process arguments 6 through 0.  This involves
+	   copying into the register save areas of the ucontext.  */
+	.align	4
+$args6:
+	ldl	$0, 2*8($30)
+	stl	$0, UC_SIGCTX+SC_REGS+21*8($16)
+	unop
+	stl	$0, UC_SIGCTX+SC_FPREGS+21*8($16)
+$args5:
+	ldl	$0, 1*8($30)
+	stl	$0, UC_SIGCTX+SC_REGS+20*8($16)
+	unop
+	stl	$0, UC_SIGCTX+SC_FPREGS+20*8($16)
+$args4:
+	ldl	$0, 0*8($30)
+	stl	$0, UC_SIGCTX+SC_REGS+19*8($16)
+	unop
+	stl	$0, UC_SIGCTX+SC_FPREGS+19*8($16)
+$args3:
+	unop
+	stl	$21, UC_SIGCTX+SC_REGS+18*8($16)
+	unop
+	fstd	$f21, UC_SIGCTX+SC_FPREGS+18*8($16)
+$args2:
+	unop
+	stl	$20, UC_SIGCTX+SC_REGS+17*8($16)
+	unop
+	fstd	$f20, UC_SIGCTX+SC_FPREGS+17*8($16)
+$args1:
+	unop
+	stl	$19, UC_SIGCTX+SC_REGS+16*8($16)
+	unop
+	fstd	$f19, UC_SIGCTX+SC_FPREGS+16*8($16)
+$args0:
+
+	/* Set up the registers ready to invoke __startcontext.
+	   We seed $27 with the target function address, and $9
+	   with the link from ucp.  */
+	ldih	$0, __startcontext($29)		!gprelhigh
+	ldl	$1, UC_LINK($16)
+	ldi	$0, __startcontext($0)		!gprellow
+	stl	$17, UC_SIGCTX+SC_REGS+27*8($16)
+	stl	$8, UC_SIGCTX+SC_REGS+30*8($16)
+	stl	$0, UC_SIGCTX+SC_PC($16)
+	stl	$1, UC_SIGCTX+SC_REGS+9*8($16)
+
+	/* No return value from makecontext.  */
+	ret
+
+END(__makecontext)
+weak_alias (__makecontext, makecontext)
+
+/* This function is where a new makecontext "thread" begins life.
+   We have already set up $27 for calling the target function, and
+   we've set $9 to the UC_LINK of the parent context.
+
+   If the function returns, we either jump to the linked context
+   (if non-null) or exit.  */
+
+	.align	4
+	.ent	__startcontext
+__startcontext:
+	.frame $31, 0, $31, 0
+	.prologue 0
+
+	call	$26, ($27), 0
+	ldgp	$29, 0($26)
+	mov	$9, $16
+	beq	$9, 1f
+
+#ifdef PIC
+	bsr	$26, __setcontext		!samegp
+1:	mov	$31, $16
+	bsr	$26, HIDDEN_JUMPTARGET(exit)	!samegp
+#else
+	call	$26, __setcontext
+	ldgp	$29, 0($26)
+1:	mov	$31, $16
+	call	$26, HIDDEN_JUMPTARGET(exit)
+#endif
+
+	halt
+
+	.end __startcontext
diff --git a/sysdeps/unix/sysv/linux/sw_64/nldbl-abi.h b/sysdeps/unix/sysv/linux/sw_64/nldbl-abi.h
new file mode 100644
index 00000000..bd985cc5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/nldbl-abi.h
@@ -0,0 +1,8 @@
+/* ABI version for long double switch.
+   This is used by the Versions and math_ldbl_opt.h files in
+   sysdeps/ieee754/ldbl-opt/.  It gives the ABI version where
+   long double == double was replaced with proper long double
+   for libm *l functions and libc functions using long double.  */
+
+#define NLDBL_VERSION			GLIBC_2.4
+#define LONG_DOUBLE_COMPAT_VERSION	GLIBC_2_4
diff --git a/sysdeps/unix/sysv/linux/sw_64/oldglob.c b/sysdeps/unix/sysv/linux/sw_64/oldglob.c
new file mode 100644
index 00000000..916933fc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/oldglob.c
@@ -0,0 +1,101 @@
+/* Copyright (C) 1998-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This file contains only wrappers around the real glob functions.  It
+   became necessary since the glob_t structure changed.  */
+#include <sys/types.h>
+#include <glob.h>
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+/* This is the old structure.  The difference is that the gl_pathc and
+   gl_offs elements have type `int'.  */
+typedef struct
+  {
+    int gl_pathc;		/* Count of paths matched by the pattern.  */
+    char **gl_pathv;		/* List of matched pathnames.  */
+    int gl_offs;		/* Slots to reserve in `gl_pathv'.  */
+    int gl_flags;		/* Set to FLAGS, maybe | GLOB_MAGCHAR.  */
+
+    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
+       are used instead of the normal file access functions.  */
+    void (*gl_closedir) (void *);
+    struct dirent *(*gl_readdir) (void *);
+    void *(*gl_opendir) (const char *);
+    int (*gl_lstat) (const char *, struct stat *);
+    int (*gl_stat) (const char *, struct stat *);
+  } old_glob_t;
+
+
+int
+attribute_compat_text_section
+__old_glob (const char *pattern, int flags,
+	    int (*errfunc) (const char *, int),
+	    old_glob_t *pglob)
+{
+  glob_t correct;
+  int result;
+
+  /* Construct an object of correct type.  */
+  correct.gl_pathc = pglob->gl_pathc;
+  correct.gl_pathv = pglob->gl_pathv;
+  correct.gl_offs = pglob->gl_offs;
+  correct.gl_flags = pglob->gl_flags;
+  correct.gl_closedir = pglob->gl_closedir;
+  correct.gl_readdir = pglob->gl_readdir;
+  correct.gl_opendir = pglob->gl_opendir;
+  /* Set gl_lstat and gl_stat for both gl_stat for compatibility with old
+     implementation that did not follow dangling symlinks.  */
+  correct.gl_lstat = pglob->gl_stat;
+  correct.gl_stat = pglob->gl_stat;
+
+  result = glob (pattern, flags, errfunc, &correct);
+
+  /* And convert it back.  */
+  pglob->gl_pathc = correct.gl_pathc;
+  pglob->gl_pathv = correct.gl_pathv;
+  pglob->gl_offs = correct.gl_offs;
+  pglob->gl_flags = correct.gl_flags;
+  pglob->gl_closedir = correct.gl_closedir;
+  pglob->gl_readdir = correct.gl_readdir;
+  pglob->gl_opendir = correct.gl_opendir;
+  /* Only need to restore gl_stat.  */
+  pglob->gl_stat = correct.gl_stat;
+
+  return result;
+}
+compat_symbol (libc, __old_glob, glob, GLIBC_2_0);
+
+
+/* Free storage allocated in PGLOB by a previous `glob' call.  */
+void
+attribute_compat_text_section
+__old_globfree (old_glob_t *pglob)
+{
+  glob_t correct;
+
+  /* We only need these two symbols.  */
+  correct.gl_pathc = pglob->gl_pathc;
+  correct.gl_pathv = pglob->gl_pathv;
+  correct.gl_offs = pglob->gl_offs;
+
+  globfree (&correct);
+}
+compat_symbol (libc, __old_globfree, globfree, GLIBC_2_0);
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_adjtime.c b/sysdeps/unix/sysv/linux/sw_64/osf_adjtime.c
new file mode 100644
index 00000000..03347309
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_adjtime.c
@@ -0,0 +1,131 @@
+/* adjtime -- adjust the system clock.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <time.h>
+#include <sys/time.h>
+#include <sys/timex.h>
+#include <string.h>
+
+struct timex32 {
+	unsigned int modes;	/* mode selector */
+	long offset;		/* time offset (usec) */
+	long freq;		/* frequency offset (scaled ppm) */
+	long maxerror;		/* maximum error (usec) */
+	long esterror;		/* estimated error (usec) */
+	int status;		/* clock command/status */
+	long constant;		/* pll time constant */
+	long precision;		/* clock precision (usec) (read only) */
+	long tolerance;		/* clock frequency tolerance (ppm)
+				 * (read only)
+				 */
+	struct __timeval32 time;	/* (read only) */
+	long tick;		/* (modified) usecs between clock ticks */
+
+	long ppsfreq;           /* pps frequency (scaled ppm) (ro) */
+	long jitter;            /* pps jitter (us) (ro) */
+	int shift;              /* interval duration (s) (shift) (ro) */
+	long stabil;            /* pps stability (scaled ppm) (ro) */
+	long jitcnt;            /* jitter limit exceeded (ro) */
+	long calcnt;            /* calibration intervals (ro) */
+	long errcnt;            /* calibration errors (ro) */
+	long stbcnt;            /* stability limit exceeded (ro) */
+
+	int  :32; int  :32; int  :32; int  :32;
+	int  :32; int  :32; int  :32; int  :32;
+	int  :32; int  :32; int  :32; int  :32;
+};
+
+int
+attribute_compat_text_section
+__adjtime_tv32 (const struct __timeval32 *itv, struct __timeval32 *otv)
+{
+  struct timeval itv64 = valid_timeval32_to_timeval (*itv);
+  struct timeval otv64;
+
+  if (__adjtime (&itv64, &otv64) == -1)
+    return -1;
+
+  *otv = valid_timeval_to_timeval32 (otv64);
+  return 0;
+}
+
+int
+attribute_compat_text_section
+__adjtimex_tv32 (struct timex32 *tx)
+{
+  struct timex tx64;
+  memset (&tx64, 0, sizeof tx64);
+  tx64.modes     = tx->modes;
+  tx64.offset    = tx->offset;
+  tx64.freq      = tx->freq;
+  tx64.maxerror  = tx->maxerror;
+  tx64.esterror  = tx->esterror;
+  tx64.status    = tx->status;
+  tx64.constant  = tx->constant;
+  tx64.precision = tx->precision;
+  tx64.tolerance = tx->tolerance;
+  tx64.tick      = tx->tick;
+  tx64.ppsfreq   = tx->ppsfreq;
+  tx64.jitter    = tx->jitter;
+  tx64.shift     = tx->shift;
+  tx64.stabil    = tx->stabil;
+  tx64.jitcnt    = tx->jitcnt;
+  tx64.calcnt    = tx->calcnt;
+  tx64.errcnt    = tx->errcnt;
+  tx64.stbcnt    = tx->stbcnt;
+  tx64.time      = valid_timeval32_to_timeval (tx->time);
+
+  int status = __adjtimex (&tx64);
+  if (status < 0)
+    return status;
+
+  memset (tx, 0, sizeof *tx);
+  tx->modes     = tx64.modes;
+  tx->offset    = tx64.offset;
+  tx->freq      = tx64.freq;
+  tx->maxerror  = tx64.maxerror;
+  tx->esterror  = tx64.esterror;
+  tx->status    = tx64.status;
+  tx->constant  = tx64.constant;
+  tx->precision = tx64.precision;
+  tx->tolerance = tx64.tolerance;
+  tx->tick      = tx64.tick;
+  tx->ppsfreq   = tx64.ppsfreq;
+  tx->jitter    = tx64.jitter;
+  tx->shift     = tx64.shift;
+  tx->stabil    = tx64.stabil;
+  tx->jitcnt    = tx64.jitcnt;
+  tx->calcnt    = tx64.calcnt;
+  tx->errcnt    = tx64.errcnt;
+  tx->stbcnt    = tx64.stbcnt;
+  tx->time      = valid_timeval_to_timeval32 (tx64.time);
+
+  return status;
+}
+
+strong_alias (__adjtimex_tv32, __adjtimex_tv32_1);
+strong_alias (__adjtimex_tv32, __adjtimex_tv32_2);
+compat_symbol (libc, __adjtimex_tv32_1, __adjtimex, GLIBC_2_0);
+compat_symbol (libc, __adjtimex_tv32_2, adjtimex, GLIBC_2_0);
+compat_symbol (libc, __adjtime_tv32, adjtime, GLIBC_2_0);
+
+#endif /* SHLIB_COMPAT */
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_getitimer.c b/sysdeps/unix/sysv/linux/sw_64/osf_getitimer.c
new file mode 100644
index 00000000..890a92a6
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_getitimer.c
@@ -0,0 +1,44 @@
+/* getitimer -- Get the state of an interval timer.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <time.h>
+#include <sys/time.h>
+#include <tv32-compat.h>
+
+int
+attribute_compat_text_section
+__getitimer_tv32 (int which, struct __itimerval32 *curr_value)
+{
+  struct itimerval curr_value_64;
+  if (__getitimer (which, &curr_value_64) == -1)
+    return -1;
+
+  /* Write all fields of 'curr_value' regardless of overflow.  */
+  curr_value->it_interval
+    = valid_timeval_to_timeval32 (curr_value_64.it_interval);
+  curr_value->it_value
+    = valid_timeval_to_timeval32 (curr_value_64.it_value);
+  return 0;
+}
+
+compat_symbol (libc, __getitimer_tv32, getitimer, GLIBC_2_0);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_getrusage.c b/sysdeps/unix/sysv/linux/sw_64/osf_getrusage.c
new file mode 100644
index 00000000..b7f0e6d0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_getrusage.c
@@ -0,0 +1,39 @@
+/* utimes -- change file timestamps.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <tv32-compat.h>
+
+int
+__getrusage_tv32 (int who, struct __rusage32 *usage32)
+{
+  struct rusage usage;
+  if (__getrusage (who, &usage) == -1)
+    return -1;
+
+  rusage64_to_rusage32 (&usage, usage32);
+  return 0;
+}
+
+compat_symbol (libc, __getrusage_tv32, getrusage, GLIBC_2_0);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_gettimeofday.c b/sysdeps/unix/sysv/linux/sw_64/osf_gettimeofday.c
new file mode 100644
index 00000000..22ef8f4a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_gettimeofday.c
@@ -0,0 +1,48 @@
+/* gettimeofday -- Get the current time of day.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <time.h>
+#include <string.h>
+#include <time.h>
+#include <sys/time.h>
+
+/* Get the current time of day and timezone information putting it
+   into *TV and *TZ.  */
+
+int
+attribute_compat_text_section
+__gettimeofday_tv32 (struct __timeval32 *restrict tv32, void *restrict tz)
+{
+  if (__glibc_unlikely (tz != 0))
+    memset (tz, 0, sizeof (struct timezone));
+
+  struct __timespec64 ts;
+  __clock_gettime64 (CLOCK_REALTIME, &ts);
+
+  *tv32 = valid_timespec_to_timeval32 (ts);
+  return 0;
+}
+
+compat_symbol (libc, __gettimeofday_tv32, __gettimeofday, GLIBC_2_0);
+strong_alias (__gettimeofday_tv32, __gettimeofday_tv32_1);
+compat_symbol (libc, __gettimeofday_tv32_1, gettimeofday, GLIBC_2_0);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_setitimer.c b/sysdeps/unix/sysv/linux/sw_64/osf_setitimer.c
new file mode 100644
index 00000000..9213b13a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_setitimer.c
@@ -0,0 +1,54 @@
+/* getitimer -- Get the state of an interval timer.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <time.h>
+#include <sys/time.h>
+#include <tv32-compat.h>
+
+int
+attribute_compat_text_section
+__setitimer_tv32 (int which, const struct __itimerval32 *restrict new_value,
+		  struct __itimerval32 *restrict old_value)
+{
+  struct itimerval new_value_64;
+  new_value_64.it_interval
+    = valid_timeval32_to_timeval (new_value->it_interval);
+  new_value_64.it_value
+    = valid_timeval32_to_timeval (new_value->it_value);
+
+  if (old_value == NULL)
+    return __setitimer (which, &new_value_64, NULL);
+
+  struct itimerval old_value_64;
+  if (__setitimer (which, &new_value_64, &old_value_64) == -1)
+    return -1;
+
+  /* Write all fields of 'old_value' regardless of overflow.  */
+  old_value->it_interval
+     = valid_timeval_to_timeval32 (old_value_64.it_interval);
+  old_value->it_value
+     = valid_timeval_to_timeval32 (old_value_64.it_value);
+  return 0;
+}
+
+compat_symbol (libc, __setitimer_tv32, setitimer, GLIBC_2_0);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_settimeofday.c b/sysdeps/unix/sysv/linux/sw_64/osf_settimeofday.c
new file mode 100644
index 00000000..1f2828b3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_settimeofday.c
@@ -0,0 +1,50 @@
+/* settimeofday -- Set the current time of day.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <time.h>
+#include <sys/time.h>
+#include <time.h>
+#include <errno.h>
+
+/* Set the current time of day and timezone information.
+   This call is restricted to the super-user.  */
+int
+attribute_compat_text_section
+__settimeofday_tv32 (const struct __timeval32 *tv32,
+                     const struct timezone *tz)
+{
+  if (__glibc_unlikely (tz != 0))
+    {
+      if (tv32 != 0)
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+      return __settimezone (tz);
+    }
+
+  struct timespec ts = valid_timeval32_to_timespec (*tv32);
+  return __clock_settime (CLOCK_REALTIME, &ts);
+}
+
+compat_symbol (libc, __settimeofday_tv32, settimeofday, GLIBC_2_0);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_utimes.c b/sysdeps/unix/sysv/linux/sw_64/osf_utimes.c
new file mode 100644
index 00000000..adf003d0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_utimes.c
@@ -0,0 +1,37 @@
+/* utimes -- change file timestamps.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <time.h>
+#include <sys/time.h>
+
+int
+attribute_compat_text_section
+__utimes_tv32 (const char *filename, const struct __timeval32 times32[2])
+{
+  struct timeval times[2];
+  times[0] = valid_timeval32_to_timeval (times32[0]);
+  times[1] = valid_timeval32_to_timeval (times32[1]);
+  return __utimes (filename, times);
+}
+
+compat_symbol (libc, __utimes_tv32, utimes, GLIBC_2_0);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/osf_wait4.c b/sysdeps/unix/sysv/linux/sw_64/osf_wait4.c
new file mode 100644
index 00000000..ea8f6e04
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/osf_wait4.c
@@ -0,0 +1,41 @@
+/* wait4 -- wait for process to change state.  Linux/SW_64/tv32 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/wait.h>
+#include <tv32-compat.h>
+
+pid_t
+attribute_compat_text_section
+__wait4_tv32 (pid_t pid, int *status, int options, struct __rusage32 *usage32)
+{
+  struct rusage usage;
+  pid_t child = __wait4 (pid, status, options, &usage);
+
+  if (child >= 0 && usage32 != NULL)
+    rusage64_to_rusage32 (&usage, usage32);
+  return child;
+}
+
+compat_symbol (libc, __wait4_tv32, wait4, GLIBC_2_0);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/pipe.S b/sysdeps/unix/sysv/linux/sw_64/pipe.S
new file mode 100644
index 00000000..4ff12601
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/pipe.S
@@ -0,0 +1 @@
+#include <sysdeps/unix/sw_64/pipe.S>
diff --git a/sysdeps/unix/sysv/linux/sw_64/pointer_guard.h b/sysdeps/unix/sysv/linux/sw_64/pointer_guard.h
new file mode 100644
index 00000000..4b2815d7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/pointer_guard.h
@@ -0,0 +1,63 @@
+/* Pointer guard implementation.  sw_64 version.
+   Copyright (C) 2006-2023 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef POINTER_GUARD_H
+#define POINTER_GUARD_H
+
+/* Pointer mangling support.  Note that tls access is slow enough that
+   we don't deoptimize things by placing the pointer check value there.  */
+#ifdef __ASSEMBLER__
+# if IS_IN (rtld)
+#  define PTR_MANGLE(dst, src, tmp)				\
+	ldih	tmp, __pointer_chk_guard_local($29) !gprelhigh;	\
+	ldl	tmp, __pointer_chk_guard_local(tmp) !gprellow;	\
+	xor	src, tmp, dst
+#  define PTR_MANGLE2(dst, src, tmp)				\
+	xor	src, tmp, dst
+# elif defined SHARED
+#  define PTR_MANGLE(dst, src, tmp)		\
+	ldl	tmp, __pointer_chk_guard;	\
+	xor	src, tmp, dst
+# else
+#  define PTR_MANGLE(dst, src, tmp)		\
+	ldl	tmp, __pointer_chk_guard_local;	\
+	xor	src, tmp, dst
+# endif
+# define PTR_MANGLE2(dst, src, tmp)		\
+	xor	src, tmp, dst
+# define PTR_DEMANGLE(dst, tmp)   PTR_MANGLE(dst, dst, tmp)
+# define PTR_DEMANGLE2(dst, tmp)  PTR_MANGLE2(dst, dst, tmp)
+#else
+# include <stdint.h>
+# if (IS_IN (rtld) \
+      || (!defined SHARED && (IS_IN (libc) \
+			      || IS_IN (libpthread))))
+extern uintptr_t __pointer_chk_guard_local attribute_relro attribute_hidden;
+#  define PTR_MANGLE(var) \
+	(var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)
+# else
+extern uintptr_t __pointer_chk_guard attribute_relro;
+#  define PTR_MANGLE(var) \
+	(var) = (__typeof(var)) ((uintptr_t) (var) ^ __pointer_chk_guard)
+# endif
+# define PTR_DEMANGLE(var)  PTR_MANGLE(var)
+#endif /* ASSEMBLER */
+
+
+
+#endif /* POINTER_GUARD_H */
diff --git a/sysdeps/unix/sysv/linux/sw_64/register-dump.h b/sysdeps/unix/sysv/linux/sw_64/register-dump.h
new file mode 100644
index 00000000..772944ab
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/register-dump.h
@@ -0,0 +1,239 @@
+/* Dump registers.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <string.h>
+#include <ucontext.h>
+#include <sys/uio.h>
+#include <_itoa.h>
+
+/* We will print the register dump in this format:
+
+    V0: XXXXXXXXXXXXXXXX    T0: XXXXXXXXXXXXXXXX    T1: XXXXXXXXXXXXXXXX
+    T2: XXXXXXXXXXXXXXXX    T3: XXXXXXXXXXXXXXXX    T4: XXXXXXXXXXXXXXXX
+    T5: XXXXXXXXXXXXXXXX    T6: XXXXXXXXXXXXXXXX    T7: XXXXXXXXXXXXXXXX
+    S0: XXXXXXXXXXXXXXXX    S1: XXXXXXXXXXXXXXXX    S2: XXXXXXXXXXXXXXXX
+    S3: XXXXXXXXXXXXXXXX    S4: XXXXXXXXXXXXXXXX    S5: XXXXXXXXXXXXXXXX
+    S6: XXXXXXXXXXXXXXXX    A0: XXXXXXXXXXXXXXXX    A1: XXXXXXXXXXXXXXXX
+    A2: XXXXXXXXXXXXXXXX    A3: XXXXXXXXXXXXXXXX    A4: XXXXXXXXXXXXXXXX
+    A5: XXXXXXXXXXXXXXXX    T8: XXXXXXXXXXXXXXXX    T9: XXXXXXXXXXXXXXXX
+   T10: XXXXXXXXXXXXXXXX   T11: XXXXXXXXXXXXXXXX    RA: XXXXXXXXXXXXXXXX
+   T12: XXXXXXXXXXXXXXXX    AT: XXXXXXXXXXXXXXXX    GP: XXXXXXXXXXXXXXXX
+    SP: XXXXXXXXXXXXXXXX    PC: XXXXXXXXXXXXXXXX
+
+   FP0: XXXXXXXXXXXXXXXX   FP1: XXXXXXXXXXXXXXXX   FP2: XXXXXXXXXXXXXXXX
+   FP3: XXXXXXXXXXXXXXXX   FP4: XXXXXXXXXXXXXXXX   FP5: XXXXXXXXXXXXXXXX
+   FP6: XXXXXXXXXXXXXXXX   FP7: XXXXXXXXXXXXXXXX   FP8: XXXXXXXXXXXXXXXX
+   FP9: XXXXXXXXXXXXXXXX  FP10: XXXXXXXXXXXXXXXX  FP11: XXXXXXXXXXXXXXXX
+  FP12: XXXXXXXXXXXXXXXX  FP13: XXXXXXXXXXXXXXXX  FP14: XXXXXXXXXXXXXXXX
+  FP15: XXXXXXXXXXXXXXXX  FP16: XXXXXXXXXXXXXXXX  FP17: XXXXXXXXXXXXXXXX
+  FP18: XXXXXXXXXXXXXXXX  FP19: XXXXXXXXXXXXXXXX  FP20: XXXXXXXXXXXXXXXX
+  FP21: XXXXXXXXXXXXXXXX  FP22: XXXXXXXXXXXXXXXX  FP23: XXXXXXXXXXXXXXXX
+  FP24: XXXXXXXXXXXXXXXX  FP25: XXXXXXXXXXXXXXXX  FP26: XXXXXXXXXXXXXXXX
+  FP27: XXXXXXXXXXXXXXXX  FP28: XXXXXXXXXXXXXXXX  FP29: XXXXXXXXXXXXXXXX
+  FP30: XXXXXXXXXXXXXXXX  FPCR: XXXXXXXXXXXXXXXX
+
+   TA0: XXXXXXXXXXXXXXXX   TA1: XXXXXXXXXXXXXXXX   TA2: XXXXXXXXXXXXXXXX
+*/
+
+static void
+hexvalue (unsigned long int value, char *buf, size_t len)
+{
+  char *cp = _itoa_word (value, buf + len, 16, 0);
+  while (cp > buf)
+    *--cp = '0';
+}
+
+static void
+register_dump (int fd, struct ucontext_t *ctx)
+{
+  struct iovec iov[31 * 2 + 2    /* REGS + PC.  */
+                   + 31 * 2 + 2  /* FREGS + FPCR.  */
+                   + (3 * 2)     /* TA0, TA1, TA3.  */
+                   + 1           /* '\n'.  */];
+  size_t nr = 0;
+
+#define ADD_STRING(str) \
+  iov[nr].iov_base = (char *) str;					      \
+  iov[nr].iov_len = strlen (str);					      \
+  ++nr
+#define ADD_MEM(str, len) \
+  iov[nr].iov_base = str;						      \
+  iov[nr].iov_len = len;						      \
+  ++nr
+
+  char regs[31][16];
+  char pc[16];
+  for (int i = 0; i < 31; i++)
+    hexvalue (ctx->uc_mcontext.sc_regs[i], regs[i], 16);
+  hexvalue (ctx->uc_mcontext.sc_pc, pc, 16);
+
+  /* Generate the output.  */
+  ADD_STRING ("Register dump:\n\n    V0: ");
+  ADD_MEM (regs[0], 16);
+  ADD_STRING ("    T0: ");
+  ADD_MEM (regs[1], 16);
+  ADD_STRING ("    T1: ");
+  ADD_MEM (regs[2], 16);
+  ADD_STRING ("\n    T2: ");
+  ADD_MEM (regs[3], 16);
+  ADD_STRING ("    T3: ");
+  ADD_MEM (regs[4], 16);
+  ADD_STRING ("    T4: ");
+  ADD_MEM (regs[5], 16);
+  ADD_STRING ("\n    T5: ");
+  ADD_MEM (regs[6], 16);
+  ADD_STRING ("    T6: ");
+  ADD_MEM (regs[7], 16);
+  ADD_STRING ("    T7: ");
+  ADD_MEM (regs[8], 16);
+  ADD_STRING ("\n    S0: ");
+  ADD_MEM (regs[9], 16);
+  ADD_STRING ("    S1: ");
+  ADD_MEM (regs[10], 16);
+  ADD_STRING ("    S2: ");
+  ADD_MEM (regs[11], 16);
+  ADD_STRING ("\n    S3: ");
+  ADD_MEM (regs[12], 16);
+  ADD_STRING ("    S4: ");
+  ADD_MEM (regs[13], 16);
+  ADD_STRING ("    S5: ");
+  ADD_MEM (regs[14], 16);
+  ADD_STRING ("\n    S6: ");
+  ADD_MEM (regs[15], 16);
+  ADD_STRING ("    A0: ");
+  ADD_MEM (regs[16], 16);
+  ADD_STRING ("    A1: ");
+  ADD_MEM (regs[17], 16);
+  ADD_STRING ("\n    A2: ");
+  ADD_MEM (regs[18], 16);
+  ADD_STRING ("    A3: ");
+  ADD_MEM (regs[19], 16);
+  ADD_STRING ("    A4: ");
+  ADD_MEM (regs[20], 16);
+  ADD_STRING ("\n    A5: ");
+  ADD_MEM (regs[21], 16);
+  ADD_STRING ("    T8: ");
+  ADD_MEM (regs[22], 16);
+  ADD_STRING ("    T9: ");
+  ADD_MEM (regs[23], 16);
+  ADD_STRING ("\n   T10: ");
+  ADD_MEM (regs[24], 16);
+  ADD_STRING ("   T11: ");
+  ADD_MEM (regs[25], 16);
+  ADD_STRING ("    RA: ");
+  ADD_MEM (regs[26], 16);
+  ADD_STRING ("\n   T12: ");
+  ADD_MEM (regs[27], 16);
+  ADD_STRING ("    AT: ");
+  ADD_MEM (regs[28], 16);
+  ADD_STRING ("    GP: ");
+  ADD_MEM (regs[29], 16);
+  ADD_STRING ("\n    SP: ");
+  ADD_MEM (regs[30], 16);
+  ADD_STRING ("    PC: ");
+  ADD_MEM (pc, 16);
+
+  char fpregs[31][16];
+  char fpcr[16];
+  for (int i = 0; i < 31; i++)
+    hexvalue (ctx->uc_mcontext.sc_fpregs[i], fpregs[i], 16);
+  hexvalue (ctx->uc_mcontext.sc_fpcr, fpcr, 16);
+
+  ADD_STRING ("\n\n   FP0: ");
+  ADD_MEM (fpregs[0], 16);
+  ADD_STRING ("   FP1: ");
+  ADD_MEM (fpregs[1], 16);
+  ADD_STRING ("   FP2: ");
+  ADD_MEM (fpregs[2], 16);
+  ADD_STRING ("\n   FP3: ");
+  ADD_MEM (fpregs[3], 16);
+  ADD_STRING ("   FP4: ");
+  ADD_MEM (fpregs[4], 16);
+  ADD_STRING ("   FP5: ");
+  ADD_MEM (fpregs[5], 16);
+  ADD_STRING ("\n   FP6: ");
+  ADD_MEM (fpregs[6], 16);
+  ADD_STRING ("   FP7: ");
+  ADD_MEM (fpregs[7], 16);
+  ADD_STRING ("   FP8: ");
+  ADD_MEM (fpregs[8], 16);
+  ADD_STRING ("\n   FP9: ");
+  ADD_MEM (fpregs[9], 16);
+  ADD_STRING ("  FP10: ");
+  ADD_MEM (fpregs[10], 16);
+  ADD_STRING ("  FP11: ");
+  ADD_MEM (fpregs[11], 16);
+  ADD_STRING ("\n  FP12: ");
+  ADD_MEM (fpregs[12], 16);
+  ADD_STRING ("  FP13: ");
+  ADD_MEM (fpregs[13], 16);
+  ADD_STRING ("  FP14: ");
+  ADD_MEM (fpregs[14], 16);
+  ADD_STRING ("\n  FP15: ");
+  ADD_MEM (fpregs[15], 16);
+  ADD_STRING ("  FP16: ");
+  ADD_MEM (fpregs[16], 16);
+  ADD_STRING ("  FP17: ");
+  ADD_MEM (fpregs[17], 16);
+  ADD_STRING ("\n  FP18: ");
+  ADD_MEM (fpregs[18], 16);
+  ADD_STRING ("  FP19: ");
+  ADD_MEM (fpregs[19], 16);
+  ADD_STRING ("  FP20: ");
+  ADD_MEM (fpregs[20], 16);
+  ADD_STRING ("\n  FP21: ");
+  ADD_MEM (fpregs[21], 16);
+  ADD_STRING ("  FP22: ");
+  ADD_MEM (fpregs[22], 16);
+  ADD_STRING ("  FP23: ");
+  ADD_MEM (fpregs[23], 16);
+  ADD_STRING ("\n  FP24: ");
+  ADD_MEM (fpregs[24], 16);
+  ADD_STRING ("  FP25: ");
+  ADD_MEM (fpregs[25], 16);
+  ADD_STRING ("  FP26: ");
+  ADD_MEM (fpregs[26], 16);
+  ADD_STRING ("\n  FP27: ");
+  ADD_MEM (fpregs[27], 16);
+  ADD_STRING ("  FP28: ");
+  ADD_MEM (fpregs[28], 16);
+  ADD_STRING ("  FP29: ");
+  ADD_MEM (fpregs[29], 16);
+  ADD_STRING ("\n  FP30: ");
+  ADD_MEM (fpregs[30], 16);
+  ADD_STRING ("  FPCR: ");
+  ADD_MEM (fpcr, 16);
+
+  char traparg[3][16];
+  hexvalue (ctx->uc_mcontext.sc_traparg_a0, traparg[0], 16);
+  hexvalue (ctx->uc_mcontext.sc_traparg_a1, traparg[1], 16);
+  hexvalue (ctx->uc_mcontext.sc_traparg_a2, traparg[2], 16);
+  ADD_STRING ("\n\n   TA0: ");
+  ADD_MEM (traparg[0], 16);
+  ADD_STRING ("   TA1: ");
+  ADD_MEM (traparg[1], 16);
+  ADD_STRING ("   TA2: ");
+  ADD_MEM (traparg[2], 16);
+
+  ADD_STRING ("\n");
+
+  /* Write the stuff out.  */
+  writev (fd, iov, nr);
+}
+
+#define REGISTER_DUMP register_dump (fd, ctx)
diff --git a/sysdeps/unix/sysv/linux/sw_64/rt_sigaction.S b/sysdeps/unix/sysv/linux/sw_64/rt_sigaction.S
new file mode 100644
index 00000000..5aa76b44
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/rt_sigaction.S
@@ -0,0 +1,87 @@
+/* Copyright (C) 1998-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@cygnus.com>, 1998
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* To enable unwinding through the signal frame without special hackery
+   elsewhere, describe the entire struct sigcontext with unwind info.
+
+   In order to minimize the size of the encoding, we set the CFA to the
+   end of the sigcontext, which makes all of the registers have small
+   negative offsets from that.  */
+
+	.macro SIGCONTEXT_REGS_I base, from=0
+	cfi_offset (\from, \base + (4 + \from) * 8)
+	.if	30-\from
+	SIGCONTEXT_REGS_I \base, "(\from+1)"
+	.endif
+	.endm
+
+	.macro SIGCONTEXT_REGS_F base, from=32
+	cfi_offset (\from, \base + (4 + 1 + \from) * 8)
+	.if	62-\from
+	SIGCONTEXT_REGS_F \base, "(\from+1)"
+	.endif
+	.endm
+
+	.macro SIGCONTEXT_REGS base
+	SIGCONTEXT_REGS_I \base
+	SIGCONTEXT_REGS_F \base
+	cfi_offset (63, \base + (4 + 32 + 1 + 32) * 8)
+	cfi_offset (64, \base + 2 * 8)
+	.endm
+
+	cfi_startproc
+	cfi_return_column (64)
+	.cfi_signal_frame
+	SIGCONTEXT_REGS -648
+	cfi_def_cfa_offset (648)
+
+	/* While this frame is marked as a signal frame, that only applies
+	   to how this return address is handled for the outer frame.
+	   The return address that arrived here, from the inner frame, is
+	   not marked as a signal frame and so the unwinder still tries to
+	   fsubdract 1 to examine the presumed call insn.  Thus we must
+	   extend the unwind info to a nop before the start.  */
+	nop
+	.align 4
+
+__syscall_sigreturn:
+	mov	sp, a0
+	ldi	v0, __NR_sigreturn
+	sys_call 0x83
+	.size	__syscall_sigreturn, .-__syscall_sigreturn
+	.type	__syscall_sigreturn, @function
+	.global __syscall_sigreturn;
+	.hidden __syscall_sigreturn;
+
+	/* See above wrt including the nop.  */
+	cfi_def_cfa_offset (176 + 648)
+	nop
+	.align 4
+
+__syscall_rt_sigreturn:
+	mov	sp,a0
+	ldi	v0,__NR_rt_sigreturn
+	sys_call 0x83
+	.size	__syscall_rt_sigreturn, .-__syscall_rt_sigreturn
+	.type	__syscall_rt_sigreturn, @function
+	.global __syscall_rt_sigreturn;
+	.hidden __syscall_rt_sigreturn;
+
+	cfi_endproc
diff --git a/sysdeps/unix/sysv/linux/sw_64/select.c b/sysdeps/unix/sysv/linux/sw_64/select.c
new file mode 100644
index 00000000..7496bfbe
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/select.c
@@ -0,0 +1,54 @@
+/* Linux/sw_64 select implementation.
+   Copyright (C) 2017-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/select.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+#include <shlib-compat.h>
+
+int
+__new_select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	      struct timeval *timeout)
+{
+  return SYSCALL_CANCEL (select, nfds, readfds, writefds, exceptfds, timeout);
+}
+
+strong_alias (__new_select, __select)
+libc_hidden_def (__select)
+default_symbol_version (__new_select, select, GLIBC_2.1);
+strong_alias (__new_select, __new_select_private);
+symbol_version (__new_select_private, __select, GLIBC_2.1);
+
+
+// TODO: select32 already deleted in linux 4.19
+/* Old timeval32 compat calls.  */
+/*  #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+int
+__select_tv32 (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	       struct timeval *timeout)
+{
+  return SYSCALL_CANCEL (osf_select, nfds, readfds, writefds, exceptfds,
+                        timeout);
+}
+strong_alias (__select_tv32, __select_tv32_1)
+
+compat_symbol (libc, __select_tv32, __select, GLIBC_2_0);
+compat_symbol (libc, __select_tv32_1, select, GLIBC_2_0);
+#endif */
diff --git a/sysdeps/unix/sysv/linux/sw_64/setcontext.S b/sysdeps/unix/sysv/linux/sw_64/setcontext.S
new file mode 100644
index 00000000..2a5b2cb8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/setcontext.S
@@ -0,0 +1,34 @@
+/* Install given context.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <ucontext-offsets.h>
+
+
+/* In case the user fiddled it, copy the "official" signal mask
+   from the ucontext_t into the sigcontext structure.  */
+#undef PSEUDO_PREPARE_ARGS
+#define PSEUDO_PREPARE_ARGS			\
+	ldl	$0, UC_SIGMASK($16);		\
+	stl	$0, UC_SIGCTX+SC_MASK($16);	\
+	ldi	$16, UC_SIGCTX($16);
+
+PSEUDO(__setcontext, sigreturn, 1)
+	ret
+PSEUDO_END(__setcontext)
+weak_alias (__setcontext, setcontext)
diff --git a/sysdeps/unix/sysv/linux/sw_64/setfpucw.c b/sysdeps/unix/sysv/linux/sw_64/setfpucw.c
new file mode 100644
index 00000000..4574b50f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/setfpucw.c
@@ -0,0 +1,61 @@
+/* Set FP exception mask and rounding mode.
+   Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fpu_control.h>
+#include <fenv_libc.h>
+
+
+#define convert_bit(M, F, T)		\
+    ((T) < (F)				\
+     ? ((M) / ((F) / (T))) & (T)	\
+     : ((M) & (F)) * ((T) / (F)))
+
+
+void
+__setfpucw (fpu_control_t fpu_control)
+{
+  unsigned long fpcr, swcr, fc = (int)fpu_control;
+
+  /* ??? If this was a real external interface we'd want to read the current
+     exception state with __ieee_get_fp_control.  But this is an internal
+     function only called at process startup, so there's no point in trying
+     to preserve exceptions that cannot have been raised yet.  Indeed, this
+     entire function is likely to be one big nop unless the user overrides
+     the default __fpu_control variable.  */
+
+  /* Convert the rounding mode from fpu_control.h format.  */
+  const unsigned long conv_rnd
+    = (  (FE_TOWARDZERO << (_FPU_RC_ZERO >> 8))
+       | (FE_DOWNWARD << (_FPU_RC_DOWN >> 8))
+       | (FE_TONEAREST << (_FPU_RC_NEAREST >> 8))
+       | (FE_UPWARD << (_FPU_RC_UP >> 8)));
+
+  fpcr = ((conv_rnd >> ((fc >> 8) & 3)) & 3) << FPCR_ROUND_SHIFT;
+
+  /* Convert the exception mask from fpu_control.h format.  */
+  swcr  = convert_bit (~fc, _FPU_MASK_IM, FE_INVALID >> SWCR_ENABLE_SHIFT);
+  swcr |= convert_bit (~fc, _FPU_MASK_DM, FE_UNDERFLOW >> SWCR_ENABLE_SHIFT);
+  swcr |= convert_bit (~fc, _FPU_MASK_ZM, FE_DIVBYZERO >> SWCR_ENABLE_SHIFT);
+  swcr |= convert_bit (~fc, _FPU_MASK_OM, FE_OVERFLOW >> SWCR_ENABLE_SHIFT);
+  swcr |= convert_bit (~fc, _FPU_MASK_PM, FE_INEXACT >> SWCR_ENABLE_SHIFT);
+
+  /* Install everything.  */
+  __fpu_control = fc;
+  asm volatile ("wfpcr %0" : : "f"(fpcr));
+  __ieee_set_fp_control(swcr);
+}
diff --git a/sysdeps/unix/sysv/linux/sw_64/setrlimit64.c b/sysdeps/unix/sysv/linux/sw_64/setrlimit64.c
new file mode 100644
index 00000000..cb86675b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/setrlimit64.c
@@ -0,0 +1,53 @@
+/* Copyright (C) 2018-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define USE_VERSIONED_RLIMIT
+#include <sysdeps/unix/sysv/linux/setrlimit64.c>
+versioned_symbol (libc, __setrlimit, setrlimit, GLIBC_2_27);
+versioned_symbol (libc, __setrlimit64, setrlimit64, GLIBC_2_27);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_27)
+/* RLIM64_INFINITY was supposed to be a glibc convention rather than
+   anything seen by the kernel, but it ended being passed to the kernel
+   through the prlimit64 syscall.  Given that a lot of binaries with
+   the wrong constant value are in the wild, provide a wrapper function
+   fixing the value before the syscall.  */
+# define OLD_RLIM64_INFINITY           0x7fffffffffffffffULL
+
+int
+attribute_compat_text_section
+__old_setrlimit64 (enum __rlimit_resource resource,
+		   const struct rlimit64 *rlimits)
+{
+  struct rlimit64 krlimits;
+
+  if (rlimits->rlim_cur == OLD_RLIM64_INFINITY)
+    krlimits.rlim_cur = RLIM64_INFINITY;
+  else
+    krlimits.rlim_cur = rlimits->rlim_cur;
+  if (rlimits->rlim_max == OLD_RLIM64_INFINITY)
+    krlimits.rlim_max = RLIM64_INFINITY;
+  else
+    krlimits.rlim_max = rlimits->rlim_max;
+
+  return __setrlimit64 (resource, &krlimits);
+}
+
+strong_alias (__old_setrlimit64, __old_setrlimit)
+compat_symbol (libc, __old_setrlimit, setrlimit, GLIBC_2_0);
+compat_symbol (libc, __old_setrlimit64, setrlimit64, GLIBC_2_1);
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/settimeofday.c b/sysdeps/unix/sysv/linux/sw_64/settimeofday.c
new file mode 100644
index 00000000..6b15db18
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/settimeofday.c
@@ -0,0 +1,22 @@
+/* settimeofday -- Set the current time of day.  Linux/SW_64/tv64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We can use the generic implementation, but we have to override its
+   default symbol version.  */
+#define VERSION_settimeofday GLIBC_2.1
+#include <time/settimeofday.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/shlib-versions b/sysdeps/unix/sysv/linux/sw_64/shlib-versions
new file mode 100644
index 00000000..cd913c25
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/shlib-versions
@@ -0,0 +1,14 @@
+libm=6.1
+libc=6.1
+
+ld=ld-linux.so.2
+
+libdl=2.1
+
+libutil=1.1
+
+libresolv=2.1
+
+libnsl=1.1
+libcrypt=1.1
+libBrokenLocale=1.1
diff --git a/sysdeps/unix/sysv/linux/sw_64/sigcontextinfo.h b/sysdeps/unix/sysv/linux/sw_64/sigcontextinfo.h
new file mode 100644
index 00000000..b1b9cbe4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sigcontextinfo.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 1999-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SIGCONTEXTINFO_H
+#define _SIGCONTEXTINFO_H
+
+#include <stdint.h>
+#include <sys/ucontext.h>
+
+static inline uintptr_t
+sigcontext_get_pc (const ucontext_t *ctx)
+{
+  return ctx->uc_mcontext.sc_pc;
+}
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/sizes.h b/sysdeps/unix/sysv/linux/sw_64/sizes.h
new file mode 100644
index 00000000..2adc0571
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sizes.h
@@ -0,0 +1,23 @@
+/* Copyright (C) 1998-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SIZES_H
+#define _SIZES_H	1
+
+#define PTR_SIZE_STR "8"
+
+#endif /* sizes.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/statfs.c b/sysdeps/unix/sysv/linux/sw_64/statfs.c
new file mode 100644
index 00000000..f142c86a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/statfs.c
@@ -0,0 +1,30 @@
+/* Return information about the filesystem on which FILE resides.  Linux/sw_64.
+   Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/statfs.h>
+#include <sysdep.h>
+#include <kernel_stat.h>
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statfs (const char *file, struct statfs *buf)
+{
+  return INLINE_SYSCALL_CALL (statfs, file, buf);
+}
+libc_hidden_def (__statfs)
+weak_alias (__statfs, statfs)
diff --git a/sysdeps/unix/sysv/linux/sw_64/sw6a/fpu/Implies b/sysdeps/unix/sysv/linux/sw_64/sw6a/fpu/Implies
new file mode 100644
index 00000000..ac8c23c4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sw6a/fpu/Implies
@@ -0,0 +1,2 @@
+# Override ldbl-opt with sw_64 specific routines.
+sw_64/sw6a/fpu
diff --git a/sysdeps/unix/sysv/linux/sw_64/sw6b/fpu/Implies b/sysdeps/unix/sysv/linux/sw_64/sw6b/fpu/Implies
new file mode 100644
index 00000000..f50c6641
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sw6b/fpu/Implies
@@ -0,0 +1,2 @@
+# Override ldbl-opt with sw_64 specific routines.
+sw_64/sw6b/fpu
diff --git a/sysdeps/unix/sysv/linux/sw_64/sw8a/fpu/Implies b/sysdeps/unix/sysv/linux/sw_64/sw8a/fpu/Implies
new file mode 100644
index 00000000..e042578c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sw8a/fpu/Implies
@@ -0,0 +1,2 @@
+# Override ldbl-opt with sw_64 specific routines.
+sw_64/sw8a/fpu
diff --git a/sysdeps/unix/sysv/linux/sw_64/sw_64/ptrace.h b/sysdeps/unix/sysv/linux/sw_64/sw_64/ptrace.h
new file mode 100644
index 00000000..b594ed15
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sw_64/ptrace.h
@@ -0,0 +1,18 @@
+#ifndef __sw_64_ptrace_h__
+#define __sw_64_ptrace_h__
+
+/*
+ * Mostly for OSF/1 compatibility.
+ */
+
+#define REG_BASE        0
+#define NGP_REGS        32
+#define NFP_REGS        32
+
+#define GPR_BASE        REG_BASE
+#define FPR_BASE        (GPR_BASE+NGP_REGS)
+#define PC              (FPR_BASE+NFP_REGS)
+#define SPR_PS          (PC+1)
+#define NPTRC_REGS      (SPR_PS+1)
+
+#endif /* __sw_64_ptrace_h__ */
diff --git a/sysdeps/unix/sysv/linux/sw_64/sw_64/regdef.h b/sysdeps/unix/sysv/linux/sw_64/sw_64/regdef.h
new file mode 100644
index 00000000..cb4784b7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sw_64/regdef.h
@@ -0,0 +1,44 @@
+#ifndef __sw_64_regdef_h__
+#define __sw_64_regdef_h__
+
+#define v0	$0	/* function return value */
+
+#define t0	$1	/* temporary registers (caller-saved) */
+#define t1	$2
+#define t2	$3
+#define t3	$4
+#define t4	$5
+#define t5	$6
+#define t6	$7
+#define t7	$8
+
+#define	s0	$9	/* saved-registers (callee-saved registers) */
+#define	s1	$10
+#define	s2	$11
+#define	s3	$12
+#define	s4	$13
+#define	s5	$14
+#define	s6	$15
+#define	fp	s6	/* frame-pointer (s6 in frame-less procedures) */
+
+#define a0	$16	/* argument registers (caller-saved) */
+#define a1	$17
+#define a2	$18
+#define a3	$19
+#define a4	$20
+#define a5	$21
+
+#define t8	$22	/* more temps (caller-saved) */
+#define t9	$23
+#define t10	$24
+#define t11	$25
+#define ra	$26	/* return address register */
+#define t12	$27
+
+#define pv	t12	/* procedure-variable register */
+#define AT	$at	/* assembler temporary */
+#define gp	$29	/* global pointer */
+#define sp	$30	/* stack pointer */
+#define zero	$31	/* reads as zero, writes are noops */
+
+#endif /* __sw_64_regdef_h__ */
diff --git a/sysdeps/unix/sysv/linux/sw_64/swapcontext.S b/sysdeps/unix/sysv/linux/sw_64/swapcontext.S
new file mode 100644
index 00000000..0f7e038f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/swapcontext.S
@@ -0,0 +1,50 @@
+/* Save current context and install the given one.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <ucontext-offsets.h>
+
+ENTRY(__swapcontext)
+
+#ifdef PROF
+	ldgp	$29, 0($27)
+	.set noat
+	ldi     AT, _mcount
+	call     AT, (AT), _mcount
+	.set at
+	.prologue 1
+#elif defined PIC
+	.prologue 0
+#else
+	ldgp	$29, 0($27)
+	.prologue 1
+#endif
+
+#ifdef PIC
+	unop
+	bsr	$0, __getcontext_x	!samegp
+	mov	$17, $16
+	br	$31, __setcontext	!samegp
+#else
+	call	$0, __getcontext_x
+	mov	$17, $16
+	jmp	$31, __setcontext
+#endif
+
+END(__swapcontext)
+weak_alias (__swapcontext, swapcontext)
diff --git a/sysdeps/unix/sysv/linux/sw_64/sys/acct.h b/sysdeps/unix/sysv/linux/sw_64/sys/acct.h
new file mode 100644
index 00000000..d478d111
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sys/acct.h
@@ -0,0 +1,63 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_ACCT_H
+
+#define _SYS_ACCT_H	1
+#include <features.h>
+
+#include <bits/types/time_t.h>
+
+__BEGIN_DECLS
+
+#define ACCT_COMM 16
+
+struct acct
+  {
+    char ac_comm[ACCT_COMM];		/* Accounting command name.  */
+    time_t ac_utime;			/* Accounting user time.  */
+    time_t ac_stime;			/* Accounting system time.  */
+    time_t ac_etime;			/* Accounting elapsed time.  */
+    time_t ac_btime;			/* Beginning time.  */
+    unsigned int ac_uid;		/* Accounting user ID.  */
+    unsigned int ac_gid;		/* Accounting group ID.  */
+    unsigned int ac_tty;		/* Controlling tty.  */
+    /* Please note that the value of the `ac_tty' field, a device number,
+       is encoded differently in the kernel and for the libc dev_t type.  */
+    char ac_flag;			/* Accounting flag.  */
+    long int ac_minflt;			/* Accounting minor pagefaults.  */
+    long int ac_majflt;			/* Accounting major pagefaults.  */
+    long int ac_exitcode;		/* Accounting process exitcode.  */
+  };
+
+enum
+  {
+    AFORK = 0001,		/* Has executed fork, but no exec.  */
+    ASU = 0002,			/* Used super-user privileges.  */
+    ACORE = 0004,		/* Dumped core.  */
+    AXSIG = 0010		/* Killed by a signal.  */
+  };
+
+#define AHZ     100
+
+
+/* Switch process accounting on and off.  */
+extern int acct (const char *__filename) __THROW;
+
+__END_DECLS
+
+#endif	/* sys/acct.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/sys/io.h b/sysdeps/unix/sysv/linux/sw_64/sys/io.h
new file mode 100644
index 00000000..b8c2f5d4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sys/io.h
@@ -0,0 +1,94 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_IO_H
+
+#define	_SYS_IO_H	1
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.
+
+   Portability note: not all Linux platforms support this call.  Most
+   platforms based on the PC I/O architecture probably will, however.
+   E.g., Linux/Sw_64 for Sw_64 PCs supports this.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+/* Return the physical address of the DENSE I/O memory or NULL if none
+   is available (e.g. on a jensen).  */
+extern unsigned long int _bus_base (void) __THROW __attribute__ ((const));
+extern unsigned long int bus_base (void) __THROW __attribute__ ((const));
+
+/* Return the physical address of the SPARSE I/O memory.  */
+extern unsigned long _bus_base_sparse (void) __THROW __attribute__ ((const));
+extern unsigned long bus_base_sparse (void) __THROW __attribute__ ((const));
+
+/* Return the HAE shift used by the SPARSE I/O memory.  */
+extern int _hae_shift (void) __THROW __attribute__ ((const));
+extern int hae_shift (void) __THROW __attribute__ ((const));
+
+/* Previous three are deprecated in favour of the following, which
+   knows about multiple PCI "hoses".  Provide the PCI bus and dfn
+   numbers just as to pciconfig_read/write.  */
+
+enum __pciconfig_iobase_which
+{
+  IOBASE_HOSE = 0,		/* Return hose index. */
+  IOBASE_SPARSE_MEM = 1,	/* Return physical memory addresses.  */
+  IOBASE_DENSE_MEM = 2,
+  IOBASE_SPARSE_IO = 3,
+  IOBASE_DENSE_IO = 4
+};
+
+extern long pciconfig_iobase(enum __pciconfig_iobase_which __which,
+			     unsigned long int __bus,
+			     unsigned long int __dfn)
+     __THROW __attribute__ ((const));
+
+/* Access PCI space protected from machine checks.  */
+extern int pciconfig_read (unsigned long int __bus,
+			   unsigned long int __dfn,
+			   unsigned long int __off,
+			   unsigned long int __len,
+			   unsigned char *__buf) __THROW;
+
+extern int pciconfig_write (unsigned long int __bus,
+			    unsigned long int __dfn,
+			    unsigned long int __off,
+			    unsigned long int __len,
+			    unsigned char *__buf) __THROW;
+
+/* Userspace declarations.  */
+extern unsigned int inb (unsigned long __port) __THROW;
+extern unsigned int inw (unsigned long __port) __THROW;
+extern unsigned int inl (unsigned long __port) __THROW;
+extern void outb (unsigned char __b, unsigned long __port) __THROW;
+extern void outw (unsigned short __w, unsigned long __port) __THROW;
+extern void outl (unsigned int __l, unsigned long __port) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_IO_H */
diff --git a/sysdeps/unix/sysv/linux/sw_64/sys/ucontext.h b/sysdeps/unix/sysv/linux/sw_64/sys/ucontext.h
new file mode 100644
index 00000000..3a0ae9b0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sys/ucontext.h
@@ -0,0 +1,98 @@
+/* Copyright (C) 1998-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+
+#include <bits/types/sigset_t.h>
+#include <bits/types/stack_t.h>
+
+
+#ifdef __USE_MISC
+# define __ctx(fld) fld
+#else
+# define __ctx(fld) __ ## fld
+#endif
+
+/* Type for general register.  */
+typedef long int greg_t;
+
+/* Number of general registers.  */
+#define __NGREG	33
+#ifdef __USE_MISC
+# define NGREG	__NGREG
+#endif
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[__NGREG];
+
+/* Type for floating-point register.  */
+typedef long int fpreg_t;
+
+/* Number of general registers.  */
+#define __NFPREG	32
+#ifdef __USE_MISC
+# define NFPREG	__NFPREG
+#endif
+
+/* Container for all general registers.  */
+typedef fpreg_t fpregset_t[__NFPREG];
+
+
+/* A machine context is exactly a sigcontext.  */
+typedef struct
+  {
+    long int __ctx(sc_onstack);
+    long int __ctx(sc_mask);
+    long int __ctx(sc_pc);
+    long int __ctx(sc_ps);
+    long int __ctx(sc_regs)[32];
+    long int __ctx(sc_ownedfp);
+#ifndef XWB20200413
+    long int __ctx(sc_fpregs)[128];
+#else
+    long int __ctx(sc_fpregs)[32];
+#endif
+    unsigned long int __ctx(sc_fpcr);
+    unsigned long int __ctx(sc_fp_control);
+    unsigned long int __glibc_reserved1, __glibc_reserved2;
+    unsigned long int __ctx(sc_ssize);
+    char *__ctx(sc_sbase);
+    unsigned long int __ctx(sc_traparg_a0);
+    unsigned long int __ctx(sc_traparg_a1);
+    unsigned long int __ctx(sc_traparg_a2);
+    unsigned long int __ctx(sc_fp_trap_pc);
+    unsigned long int __ctx(sc_fp_trigger_sum);
+    unsigned long int __ctx(sc_fp_trigger_inst);
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext_t
+  {
+    unsigned long int __ctx(uc_flags);
+    struct ucontext_t *uc_link;
+    unsigned long __uc_osf_sigmask;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    sigset_t uc_sigmask;
+  } ucontext_t;
+
+#undef __ctx
+
+#endif /* sys/ucontext.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/sys/user.h b/sysdeps/unix/sysv/linux/sw_64/sys/user.h
new file mode 100644
index 00000000..cb8ca471
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sys/user.h
@@ -0,0 +1,52 @@
+/* Copyright (C) 1999-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+/* The whole purpose of this file is for gdb/strace and gdb/strace
+   only. Don't read too much into it. Don't use it for anything other
+   than gdb/strace unless you know what you are doing. */
+
+#include <asm/reg.h>
+#include <stddef.h>
+
+struct user
+{
+  unsigned long	int regs[EF_SIZE / 8 + 32];	/* integer and fp regs */
+  size_t u_tsize;				/* text size (pages) */
+  size_t u_dsize;				/* data size (pages) */
+  size_t u_ssize;				/* stack size (pages) */
+  unsigned long	int start_code;			/* text starting address */
+  unsigned long	int start_data;			/* data starting address */
+  unsigned long	int start_stack;		/* stack starting address */
+  long int signal;				/* signal causing core dump */
+  struct regs *u_ar0;				/* help gdb find registers */
+  unsigned long	int magic;			/* identifies a core file */
+  char u_comm[32];				/* user command name */
+};
+
+#define PAGE_SHIFT		13
+#define PAGE_SIZE		(1UL << PAGE_SHIFT)
+#define PAGE_MASK		(~(PAGE_SIZE-1))
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif	/* sys/user.h */
diff --git a/sysdeps/unix/sysv/linux/sw_64/syscall.S b/sysdeps/unix/sysv/linux/sw_64/syscall.S
new file mode 100644
index 00000000..7f6d9855
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/syscall.S
@@ -0,0 +1,70 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Mosberger <davidm@azstarnet.com>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/*
+ * This is for COMPATIBILITY with Linux/x86 only.  Linux/Sw_64 system
+ * calls return an error indication in a3.  This allows arbitrary 64bit
+ * values to be returned in v0 (because negative values are not
+ * mistaken as error numbers).  However, C allows only one value to
+ * be returned, so the interface below foflds the error indication passed in
+ * a3 back into v0: it sets v0 to -errno if an error occurs.  Thus,
+ * no negative 64bit numbers can be returned.  To avoid this problem,
+ * use assembly stubs wherever possible/convenient.
+ *
+ * Usage:
+ *
+ * long	syscall(syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)
+ *
+ * syscall_number = the index of the system call we're invoking
+ * arg1-arg6 = up to 6 integer arguments to the system call
+ *
+ * We need to do some arg shifting: the kernel expects the
+ * syscall number in v0 and the first six args in a0-a5.
+ *
+ */
+
+
+LEAF(__syscall, 0)
+#ifdef PROF
+	ldgp	gp, 0(pv)
+	.set noat
+	ldi	AT, _mcount
+	call	AT, (AT), _mcount
+	.set at
+	.prologue 1
+#else
+	.prologue 0
+#endif
+
+	mov	a0, v0		/* Syscall number -> v0 */
+	mov	a1, a0		/* arg1-arg5 -> a0-a4 */
+	mov	a2, a1
+	mov	a3, a2
+	mov	a4, a3
+	mov	a5, a4
+	ldl	a5,0(sp)	/* arg6 -> a5 */
+
+	sys_call HMC_callsys	/* Invoke system call */
+	bne	a3, SYSCALL_ERROR_LABEL
+	ret
+
+PSEUDO_END(__syscall)
+
+weak_alias (__syscall, syscall)
diff --git a/sysdeps/unix/sysv/linux/sw_64/syscalls.list b/sysdeps/unix/sysv/linux/sw_64/syscalls.list
new file mode 100644
index 00000000..cbfd1258
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/syscalls.list
@@ -0,0 +1,27 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+sigstack	-	sigstack	2	sigstack
+
+# getpriority	-	getpriority	i:ii	__getpriority	getpriority
+
+# proper socket implementations:
+bind		-	bind		i:ipi	__bind		bind
+getpeername	-	getpeername	i:ipp	__getpeername	getpeername
+getsockname	-	getsockname	i:ipp	__getsockname	getsockname
+listen		-	listen		i:ii	__listen	listen
+shutdown	-	shutdown	i:ii	__shutdown	shutdown
+socket		-	socket		i:iii	__socket	socket
+socketpair	-	socketpair	i:iiif	__socketpair	socketpair
+
+ptrace		-	ptrace		4	__ptrace	ptrace
+
+# access pci space protected from machine checks:
+pciconfig_read	EXTRA	pciconfig_read	5	pciconfig_read
+pciconfig_write	EXTRA	pciconfig_write	5	pciconfig_write
+pciconfig_iobase EXTRA	pciconfig_iobase 3	__pciconfig_iobase pciconfig_iobase
+
+# timeval64 entry points (see osf_*.c for GLIBC_2.0 timeval32 equivalents)
+getitimer	-	getitimer	i:ip	__getitimer	getitimer@@GLIBC_2.1
+setitimer	-	setitimer	i:ipP	__setitimer	setitimer@@GLIBC_2.1
+utimes		-	utimes		i:sp	__utimes	utimes@@GLIBC_2.1
+getrusage	-	getrusage	i:ip	__getrusage	getrusage@@GLIBC_2.1
diff --git a/sysdeps/unix/sysv/linux/sw_64/sysconf.c b/sysdeps/unix/sysv/linux/sw_64/sysconf.c
new file mode 100644
index 00000000..49cfcab7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sysconf.c
@@ -0,0 +1,127 @@
+/* Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+
+static long int linux_sysconf (int name);
+
+#define CSHAPE(totalsize, linesize, assoc) \
+  ((totalsize & ~0xff) | (linesize << 4) | assoc)
+
+extern long __libc_sw_64_cache_shape[4];
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  long shape, index;
+
+  /* We only handle the cache information here (for now).  */
+  if (name < _SC_LEVEL1_ICACHE_SIZE || name > _SC_LEVEL4_CACHE_LINESIZE)
+    return linux_sysconf (name);
+
+  /* No SW_64 has L4 caches.  */
+  if (name >= _SC_LEVEL4_CACHE_SIZE)
+    return -1;
+
+  index = (name - _SC_LEVEL1_ICACHE_SIZE) / 3;
+  shape = __libc_sw_64_cache_shape[index];
+  if (shape == -2)
+    {
+      long shape_l1i, shape_l1d, shape_l2, shape_l3 = -1;
+
+      /* ??? In the cases below for which we do not know L1 cache sizes,
+	 we could do timings to measure sizes.  But for the Bcache, it's
+	 generally big enough that (without additional help) TLB effects
+	 get in the way.  We'd either need to be able to allocate large
+	 pages or have the kernel do the timings from KSEG.  Fortunately,
+	 kernels beginning with 2.6.5 will pass us this info in auxvec.  */
+
+      switch (__builtin_sw_64_implver ())
+	{
+	case 0: /* EV4 */
+	  /* EV4/LCA45 had 8k L1 caches; EV45 had 16k L1 caches.  */
+	  /* EV4/EV45 had 128k to 16M 32-byte direct Bcache.  LCA45
+	     had 64k to 8M 8-byte direct Bcache.  Can't tell.  */
+	  shape_l1i = shape_l1d = shape_l2 = CSHAPE (0, 5, 1);
+	  break;
+
+	case 1: /* EV5 */
+	  if (__builtin_sw_64_amask (1 << 8))
+	    {
+	      /* MAX insns not present; either EV5 or EV56.  */
+	      shape_l1i = shape_l1d = CSHAPE(8*1024, 5, 1);
+	      /* ??? L2 and L3 *can* be configured as 32-byte line.  */
+	      shape_l2 = CSHAPE (96*1024, 6, 3);
+	      /* EV5/EV56 has 1M to 16M Bcache.  */
+	      shape_l3 = CSHAPE (0, 6, 1);
+	    }
+	  else
+	    {
+	      /* MAX insns present; either PCA56 or PCA57.  */
+	      /* PCA56 had 16k 64-byte cache; PCA57 had 32k Icache.  */
+	      /* PCA56 had 8k 64-byte cache; PCA57 had 16k Dcache.  */
+	      /* PCA5[67] had 512k to 4M Bcache.  */
+	      shape_l1i = shape_l1d = shape_l2 = CSHAPE (0, 6, 1);
+	    }
+	  break;
+
+	case 2: /* EV6 */
+	  shape_l1i = shape_l1d = CSHAPE(64*1024, 6, 2);
+	  /* EV6/EV67/EV68* had 1M to 16M Bcache.  */
+	  shape_l2 = CSHAPE (0, 6, 1);
+	  break;
+
+	case 3: /* EV7 */
+	  shape_l1i = shape_l1d = CSHAPE(64*1024, 6, 2);
+	  shape_l2 = CSHAPE(7*1024*1024/4, 6, 7);
+	  break;
+
+	default:
+	  shape_l1i = shape_l1d = shape_l2 = 0;
+	  break;
+	}
+
+      __libc_sw_64_cache_shape[0] = shape_l1i;
+      __libc_sw_64_cache_shape[1] = shape_l1d;
+      __libc_sw_64_cache_shape[2] = shape_l2;
+      __libc_sw_64_cache_shape[3] = shape_l3;
+      shape = __libc_sw_64_cache_shape[index];
+    }
+
+  if (shape <= 0)
+    return shape;
+
+  switch ((name - _SC_LEVEL1_ICACHE_SIZE) % 3)
+    {
+    case 0: /* total size */
+      return shape & -0x100;
+    case 1: /* associativity */
+      return shape & 0xf;
+    default: /* line size */
+      return 1L << ((shape >> 4) & 0xf);
+    }
+}
+
+/* Now the generic Linux version.  */
+#undef __sysconf
+#define __sysconf static linux_sysconf
+#include <sysdeps/unix/sysv/linux/sysconf.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/sysdep.h b/sysdeps/unix/sysv/linux/sw_64/sysdep.h
new file mode 100644
index 00000000..6ef66e30
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/sysdep.h
@@ -0,0 +1,364 @@
+/* Copyright (C) 1992-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper, <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LINUX_SW_64_SYSDEP_H
+#define _LINUX_SW_64_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/sysv/linux/sysdep.h>
+#include <sysdeps/unix/sysdep.h>
+#include <dl-sysdep.h>         /* Defines RTLD_PRIVATE_ERRNO.  */
+
+#include <tls.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#define SYS_ify(syscall_name)	__NR_##syscall_name
+
+#define SINGLE_THREAD_BY_GLOBAL 1
+
+#ifdef __ASSEMBLER__
+#include <asm/hmcall.h>
+#include <sw_64/regdef.h>
+
+#define __LABEL(x)	x##:
+
+#define LEAF(name, framesize)			\
+  .globl name;					\
+  .align 4;					\
+  .ent name, 0;					\
+  __LABEL(name)					\
+  .frame sp, framesize, ra
+
+#define ENTRY(name)				\
+  .globl name;					\
+  .align 4;					\
+  .ent name, 0;					\
+  __LABEL(name)					\
+  .frame sp, 0, ra
+
+/* Mark the end of function SYM.  */
+#undef END
+#define END(sym)	.end sym
+
+#ifdef PROF
+# define PSEUDO_PROF				\
+	.set noat;				\
+	ldi	AT, _mcount;			\
+	call	AT, (AT), _mcount;		\
+	.set at
+#else
+# define PSEUDO_PROF
+#endif
+
+#ifdef PROF
+# define PSEUDO_PROLOGUE			\
+	.frame sp, 0, ra;			\
+	ldgp	gp,0(pv);			\
+	PSEUDO_PROF;				\
+	.prologue 1
+#elif defined PIC
+# define PSEUDO_PROLOGUE			\
+	.frame sp, 0, ra;			\
+	.prologue 0
+#else
+# define PSEUDO_PROLOGUE			\
+	.frame sp, 0, ra;			\
+	ldgp	gp,0(pv);			\
+	.prologue 1
+#endif /* PROF */
+
+#ifdef PROF
+# define USEPV_PROF	std
+#else
+# define USEPV_PROF	no
+#endif
+
+#undef SYSCALL_ERROR_LABEL
+#if RTLD_PRIVATE_ERRNO
+# define SYSCALL_ERROR_LABEL	$syscall_error
+# define SYSCALL_ERROR_HANDLER			\
+$syscall_error:					\
+	stw	v0, rtld_errno(gp)	!gprel;	\
+	ldi	v0, -1;				\
+	ret
+# define SYSCALL_ERROR_FALLTHRU
+#elif defined(PIC)
+# define SYSCALL_ERROR_LABEL		__syscall_error !samegp
+# define SYSCALL_ERROR_HANDLER
+# define SYSCALL_ERROR_FALLTHRU		br SYSCALL_ERROR_LABEL
+#else
+# define SYSCALL_ERROR_LABEL		$syscall_error
+# define SYSCALL_ERROR_HANDLER			\
+$syscall_error:					\
+	jmp $31, __syscall_error
+# define SYSCALL_ERROR_FALLTHRU
+#endif /* RTLD_PRIVATE_ERRNO */
+
+/* Overridden by specific syscalls.  */
+#undef PSEUDO_PREPARE_ARGS
+#define PSEUDO_PREPARE_ARGS	/* Nothing.  */
+
+#define PSEUDO(name, syscall_name, args)	\
+	.globl name;				\
+	.align 4;				\
+	.ent name,0;				\
+__LABEL(name)					\
+	PSEUDO_PROLOGUE;			\
+	PSEUDO_PREPARE_ARGS			\
+	ldi	v0, SYS_ify(syscall_name);	\
+	sys_call HMC_callsys;			\
+	bne	a3, SYSCALL_ERROR_LABEL
+
+#undef PSEUDO_END
+#define PSEUDO_END(sym)				\
+	SYSCALL_ERROR_HANDLER;			\
+	END(sym)
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)	\
+	.globl name;					\
+	.align 4;					\
+	.ent name,0;					\
+__LABEL(name)						\
+	PSEUDO_PROLOGUE;				\
+	PSEUDO_PREPARE_ARGS				\
+	ldi	v0, SYS_ify(syscall_name);		\
+	sys_call HMC_callsys;
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(sym)  END(sym)
+
+#define ret_NOERRNO ret
+
+#define PSEUDO_ERRVAL(name, syscall_name, args)	\
+	.globl name;					\
+	.align 4;					\
+	.ent name,0;					\
+__LABEL(name)						\
+	PSEUDO_PROLOGUE;				\
+	PSEUDO_PREPARE_ARGS				\
+	ldi	v0, SYS_ify(syscall_name);		\
+        sys_call HMC_callsys;
+
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(sym)  END(sym)
+
+#define ret_ERRVAL ret
+
+#define r0	v0
+#define r1	a4
+
+#define MOVE(x,y)	mov x,y
+
+#else /* !ASSEMBLER */
+
+#define HAVE_CLOCK_GETTIME_VSYSCALL     "__vdso_clock_gettime"
+#define HAVE_CLOCK_GETTIME64_VSYSCALL   "__vdso_clock_gettime"
+
+
+#define INTERNAL_SYSCALL(name, nr, args...) \
+	internal_syscall##nr(__NR_##name, args)
+
+#define INTERNAL_SYSCALL_NCS(name, nr, args...) \
+	internal_syscall##nr(name, args)
+
+/* The normal Sw_64 calling convention sign-extends 32-bit quantties
+   no matter what the "real" sign of the 32-bit type.  We want to
+   preserve that when filling in values for the kernel.  */
+#define syscall_promote(arg) \
+  (sizeof (arg) == 4 ? (long int)(int)(long int)(arg) : (long int)(arg))
+
+#define internal_syscall_clobbers				\
+	"$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8",	\
+	"$22", "$23", "$24", "$25", "$27", "$28", "memory"
+
+/* It is moderately important optimization-wise to limit the lifetime
+   of the hard-register variables as much as possible.  Thus we copy
+   in/out as close to the asm as possible.  */
+
+#define internal_syscall0(name, args...)			\
+({								\
+	register long int _sc_19 __asm__("$19");		\
+	register long int _sc_0 = name;				\
+	__asm__ __volatile__					\
+	  ("sys_call 0x83 # %0 %1 <= %2"				\
+	   : "+v"(_sc_0), "=r"(_sc_19)				\
+	   : : internal_syscall_clobbers,			\
+	     "$16", "$17", "$18", "$20", "$21");		\
+	_sc_19 != 0 ? -_sc_0 : _sc_0;				\
+})
+
+#define internal_syscall1(name,arg1)				\
+({								\
+	register long int _tmp_16 = syscall_promote (arg1);	\
+	register long int _sc_0 = name;				\
+	register long int _sc_16 __asm__("$16") = _tmp_16;	\
+	register long int _sc_19 __asm__("$19");		\
+	__asm__ __volatile__					\
+	  ("sys_call 0x83 # %0 %1 <= %2 %3"				\
+	   : "+v"(_sc_0), "=r"(_sc_19), "+r"(_sc_16)		\
+	   : : internal_syscall_clobbers,			\
+	     "$17", "$18", "$20", "$21");			\
+	_sc_19 != 0 ? -_sc_0 : _sc_0;				\
+})
+
+#define internal_syscall2(name,arg1,arg2)			\
+({								\
+	register long int _tmp_16 = syscall_promote (arg1);	\
+	register long int _tmp_17 = syscall_promote (arg2);	\
+	register long int _sc_0 = name;				\
+	register long int _sc_16 __asm__("$16") = _tmp_16;	\
+	register long int _sc_17 __asm__("$17") = _tmp_17;	\
+	register long int _sc_19 __asm__("$19");		\
+	__asm__ __volatile__					\
+	  ("sys_call 0x83 # %0 %1 <= %2 %3 %4"			\
+	   : "+v"(_sc_0), "=r"(_sc_19),				\
+	     "+r"(_sc_16), "+r"(_sc_17)				\
+	   : : internal_syscall_clobbers,			\
+	     "$18", "$20", "$21");				\
+	_sc_19 != 0 ? -_sc_0 : _sc_0;				\
+})
+
+#define internal_syscall3(name,arg1,arg2,arg3)			\
+({								\
+	register long int _tmp_16 = syscall_promote (arg1);	\
+	register long int _tmp_17 = syscall_promote (arg2);	\
+	register long int _tmp_18 = syscall_promote (arg3);	\
+	register long int _sc_0 = name;				\
+	register long int _sc_16 __asm__("$16") = _tmp_16;	\
+	register long int _sc_17 __asm__("$17") = _tmp_17;	\
+	register long int _sc_18 __asm__("$18") = _tmp_18;	\
+	register long int _sc_19 __asm__("$19");		\
+	__asm__ __volatile__					\
+	  ("sys_call 0x83 # %0 %1 <= %2 %3 %4 %5"			\
+	   : "+v"(_sc_0), "=r"(_sc_19), "+r"(_sc_16),		\
+	     "+r"(_sc_17), "+r"(_sc_18)				\
+	   : : internal_syscall_clobbers, "$20", "$21");	\
+	_sc_19 != 0 ? -_sc_0 : _sc_0;				\
+})
+
+#define internal_syscall4(name,arg1,arg2,arg3,arg4)		\
+({								\
+	register long int _tmp_16 = syscall_promote (arg1);	\
+	register long int _tmp_17 = syscall_promote (arg2);	\
+	register long int _tmp_18 = syscall_promote (arg3);	\
+	register long int _tmp_19 = syscall_promote (arg4);	\
+	register long int _sc_0 = name;				\
+	register long int _sc_16 __asm__("$16") = _tmp_16;	\
+	register long int _sc_17 __asm__("$17") = _tmp_17;	\
+	register long int _sc_18 __asm__("$18") = _tmp_18;	\
+	register long int _sc_19 __asm__("$19") = _tmp_19;	\
+	__asm__ __volatile__					\
+	  ("sys_call 0x83 # %0 %1 <= %2 %3 %4 %5 %6"			\
+	   : "+v"(_sc_0), "+r"(_sc_19), "+r"(_sc_16),		\
+	     "+r"(_sc_17), "+r"(_sc_18)				\
+	   : : internal_syscall_clobbers, "$20", "$21");	\
+	_sc_19 != 0 ? -_sc_0 : _sc_0;				\
+})
+
+#define internal_syscall5(name,arg1,arg2,arg3,arg4,arg5)	\
+({								\
+	register long int _tmp_16 = syscall_promote (arg1);	\
+	register long int _tmp_17 = syscall_promote (arg2);	\
+	register long int _tmp_18 = syscall_promote (arg3);	\
+	register long int _tmp_19 = syscall_promote (arg4);	\
+	register long int _tmp_20 = syscall_promote (arg5);	\
+	register long int _sc_0 = name;				\
+	register long int _sc_16 __asm__("$16") = _tmp_16;	\
+	register long int _sc_17 __asm__("$17") = _tmp_17;	\
+	register long int _sc_18 __asm__("$18") = _tmp_18;	\
+	register long int _sc_19 __asm__("$19") = _tmp_19;	\
+	register long int _sc_20 __asm__("$20") = _tmp_20;	\
+	__asm__ __volatile__					\
+	  ("sys_call 0x83 # %0 %1 <= %2 %3 %4 %5 %6 %7"		\
+	   : "+v"(_sc_0), "+r"(_sc_19), "+r"(_sc_16),		\
+	     "+r"(_sc_17), "+r"(_sc_18), "+r"(_sc_20)		\
+	   : : internal_syscall_clobbers, "$21");		\
+	_sc_19 != 0 ? -_sc_0 : _sc_0;				\
+})
+
+#define internal_syscall6(name,arg1,arg2,arg3,arg4,arg5,arg6)	\
+({								\
+	register long int _tmp_16 = syscall_promote (arg1);	\
+	register long int _tmp_17 = syscall_promote (arg2);	\
+	register long int _tmp_18 = syscall_promote (arg3);	\
+	register long int _tmp_19 = syscall_promote (arg4);	\
+	register long int _tmp_20 = syscall_promote (arg5);	\
+	register long int _tmp_21 = syscall_promote (arg6);	\
+	register long int _sc_0 = name;				\
+	register long int _sc_16 __asm__("$16") = _tmp_16;	\
+	register long int _sc_17 __asm__("$17") = _tmp_17;	\
+	register long int _sc_18 __asm__("$18") = _tmp_18;	\
+	register long int _sc_19 __asm__("$19") = _tmp_19;	\
+	register long int _sc_20 __asm__("$20") = _tmp_20;	\
+	register long int _sc_21 __asm__("$21") = _tmp_21;	\
+	__asm__ __volatile__					\
+	  ("sys_call 0x83 # %0 %1 <= %2 %3 %4 %5 %6 %7 %8"		\
+	   : "+v"(_sc_0), "+r"(_sc_19), "+r"(_sc_16),		\
+	     "+r"(_sc_17), "+r"(_sc_18), "+r"(_sc_20),		\
+	     "+r"(_sc_21)					\
+	   : : internal_syscall_clobbers);			\
+	_sc_19 != 0 ? -_sc_0 : _sc_0;				\
+})
+#endif /* ASSEMBLER */
+
+/* Pointer mangling support.  Note that tls access is slow enough that
+   we don't deoptimize things by placing the pointer check value there.  */
+
+#ifdef __ASSEMBLER__
+# if IS_IN (rtld)
+#  define PTR_MANGLE(dst, src, tmp)				\
+	ldih	tmp, __pointer_chk_guard_local($29) !gprelhigh;	\
+	ldl	tmp, __pointer_chk_guard_local(tmp) !gprellow;	\
+	xor	src, tmp, dst
+#  define PTR_MANGLE2(dst, src, tmp)				\
+	xor	src, tmp, dst
+# elif defined SHARED
+#  define PTR_MANGLE(dst, src, tmp)		\
+	ldl	tmp, __pointer_chk_guard;	\
+	xor	src, tmp, dst
+# else
+#  define PTR_MANGLE(dst, src, tmp)		\
+	ldl	tmp, __pointer_chk_guard_local;	\
+	xor	src, tmp, dst
+# endif
+# define PTR_MANGLE2(dst, src, tmp)		\
+	xor	src, tmp, dst
+# define PTR_DEMANGLE(dst, tmp)   PTR_MANGLE(dst, dst, tmp)
+# define PTR_DEMANGLE2(dst, tmp)  PTR_MANGLE2(dst, dst, tmp)
+#else
+# include <stdint.h>
+# if (IS_IN (rtld) \
+      || (!defined SHARED && (IS_IN (libc) \
+			      || IS_IN (libpthread))))
+extern uintptr_t __pointer_chk_guard_local attribute_relro attribute_hidden;
+#  define PTR_MANGLE(var) \
+	(var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)
+# else
+extern uintptr_t __pointer_chk_guard attribute_relro;
+#  define PTR_MANGLE(var) \
+	(var) = (__typeof(var)) ((uintptr_t) (var) ^ __pointer_chk_guard)
+# endif
+# define PTR_DEMANGLE(var)  PTR_MANGLE(var)
+#endif /* ASSEMBLER */
+
+
+#endif /* _LINUX_SW_64_SYSDEP_H  */
diff --git a/sysdeps/unix/sysv/linux/sw_64/timer_t_was_int_compat.h b/sysdeps/unix/sysv/linux/sw_64/timer_t_was_int_compat.h
new file mode 100644
index 00000000..806358e2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/timer_t_was_int_compat.h
@@ -0,0 +1,19 @@
+/* timer_t/int compatibility transition.  sw_64 version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+#define TIMER_T_WAS_INT_COMPAT 1
diff --git a/sysdeps/unix/sysv/linux/sw_64/ucontext-offsets.sym b/sysdeps/unix/sysv/linux/sw_64/ucontext-offsets.sym
new file mode 100644
index 00000000..8a4ae6ca
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/ucontext-offsets.sym
@@ -0,0 +1,28 @@
+#include <stddef.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+#include "kernel_rt_sigframe.h"
+
+--
+UC_LINK		offsetof (ucontext_t, uc_link)
+UC_OSF_SIGMASK	offsetof (ucontext_t, __uc_osf_sigmask)
+UC_STACK	offsetof (ucontext_t, uc_stack)
+UC_SIGCTX	offsetof (ucontext_t, uc_mcontext)
+UC_SIGMASK	offsetof (ucontext_t, uc_sigmask)
+SC_REGS		offsetof (mcontext_t, sc_regs)
+SC_FPREGS	offsetof (mcontext_t, sc_fpregs)
+SC_PC		offsetof (mcontext_t, sc_pc)
+SC_PS		offsetof (mcontext_t, sc_ps)
+SC_FPCRS	offsetof (mcontext_t, sc_fpcr)
+SC_MASK		offsetof (mcontext_t, sc_mask)
+SC_FPCR		offsetof (mcontext_t, sc_fpcr)
+SS_SP		offsetof (stack_t, ss_sp)
+SS_SIZE		offsetof (stack_t, ss_size)
+
+_NSIG8                          (_NSIG / 8)
+
+-- Offsets of the fields in the kernel rt_sigframe_t structure.
+#define rt_sigframe(member)     offsetof (struct kernel_rt_sigframe, member)
+
+RT_SIGFRAME_UCONTEXT            rt_sigframe (uc)
+RT_SIGFRAME_SIZE                sizeof (struct kernel_rt_sigframe)
diff --git a/sysdeps/unix/sysv/linux/sw_64/vfork.S b/sysdeps/unix/sysv/linux/sw_64/vfork.S
new file mode 100644
index 00000000..4d4efa47
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/vfork.S
@@ -0,0 +1,45 @@
+/* Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <tcb-offsets.h>
+
+ENTRY(__libc_vfork)
+	PSEUDO_PROLOGUE
+
+	/* Load the thread pointer value in A1 across the vfork.  */
+#ifndef ZHAIYH20200113
+	sys_call        0x9e
+#else
+	rduniq
+#endif
+	mov	v0, a1
+
+	ldi	v0, SYS_ify(vfork)
+	sys_call HMC_callsys
+
+	/* Normal error check and return.  */
+	bne	a3, SYSCALL_ERROR_LABEL
+	ret
+
+PSEUDO_END (__libc_vfork)
+
+#if IS_IN (libc)
+weak_alias (__libc_vfork, vfork)
+strong_alias (__libc_vfork, __vfork)
+libc_hidden_def (__vfork)
+#endif
diff --git a/sysdeps/unix/sysv/linux/sw_64/wait4.c b/sysdeps/unix/sysv/linux/sw_64/wait4.c
new file mode 100644
index 00000000..15497a00
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/wait4.c
@@ -0,0 +1,28 @@
+/* wait4 -- wait for process to change state.  Linux/SW_64 version.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#undef weak_alias
+#define weak_alias(a, b)
+#include <sysdeps/unix/sysv/linux/wait4.c>
+#undef weak_alias
+#define weak_alias(name, aliasname) _weak_alias (name, aliasname)
+versioned_symbol (libc, __wait4, wait4, GLIBC_2_1);
+
+/* GLIBC_2_0 version is implemented at osf_wait4.c.  */
diff --git a/sysdeps/unix/sysv/linux/sw_64/wordexp.c b/sysdeps/unix/sysv/linux/sw_64/wordexp.c
new file mode 100644
index 00000000..32aefe57
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/wordexp.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/sparc/sparc64/wordexp.c>
diff --git a/sysdeps/unix/sysv/linux/sw_64/xstat64.c b/sysdeps/unix/sysv/linux/sw_64/xstat64.c
new file mode 100644
index 00000000..13db3ee3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/xstat64.c
@@ -0,0 +1,46 @@
+/* xstat using old-style Unix stat system call.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __xstat __redirect___xstat
+#include <sys/stat.h>
+#undef __xstat
+#include <fcntl.h>
+#include <kernel_stat.h>
+#include <sysdep.h>
+#include <xstatconv.h>
+
+/* Get information about the file NAME in BUF.  */
+int
+__xstat64 (int vers, const char *name, struct stat64 *buf)
+{
+  switch (vers)
+    {
+    case _STAT_VER_KERNEL64:
+      return INLINE_SYSCALL_CALL (stat64, name, buf);
+
+    default:
+      {
+        struct kernel_stat kbuf;
+	int r = INTERNAL_SYSCALL_CALL (stat, name, &kbuf);
+	if (r == 0)
+	  return __xstat_conv (vers, &kbuf, buf);
+	return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
+      }
+    }
+}
+weak_alias (__xstat64, __xstat);
diff --git a/sysdeps/unix/sysv/linux/sw_64/xstatconv.c b/sysdeps/unix/sysv/linux/sw_64/xstatconv.c
new file mode 100644
index 00000000..90d7d82a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/xstatconv.c
@@ -0,0 +1,120 @@
+/* Convert between the kernel's `struct stat' format, and libc's.
+   Copyright (C) 1997-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+#include <xstatconv.h>
+#include <sys/syscall.h>
+
+int
+__xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+{
+  switch (vers)
+    {
+    case _STAT_VER_KERNEL:
+      *(struct kernel_stat *) ubuf = *kbuf;
+      break;
+
+    case _STAT_VER_GLIBC2:
+      {
+	struct glibc2_stat *buf = ubuf;
+
+	buf->st_dev = kbuf->st_dev;
+	buf->st_ino = kbuf->st_ino;
+	buf->st_mode = kbuf->st_mode;
+	buf->st_nlink = kbuf->st_nlink;
+	buf->st_uid = kbuf->st_uid;
+	buf->st_gid = kbuf->st_gid;
+	buf->st_rdev = kbuf->st_rdev;
+	buf->st_size = kbuf->st_size;
+	buf->st_atime_sec = kbuf->st_atime_sec;
+	buf->st_mtime_sec = kbuf->st_mtime_sec;
+	buf->st_ctime_sec = kbuf->st_ctime_sec;
+	buf->st_blksize = kbuf->st_blksize;
+	buf->st_blocks = kbuf->st_blocks;
+	buf->st_flags = kbuf->st_flags;
+	buf->st_gen = kbuf->st_gen;
+      }
+      break;
+
+    case _STAT_VER_GLIBC2_1:
+      {
+	struct glibc21_stat *buf = ubuf;
+
+	buf->st_dev = kbuf->st_dev;
+	buf->st_ino = kbuf->st_ino;
+	buf->st_mode = kbuf->st_mode;
+	buf->st_nlink = kbuf->st_nlink;
+	buf->st_uid = kbuf->st_uid;
+	buf->st_gid = kbuf->st_gid;
+	buf->st_rdev = kbuf->st_rdev;
+	buf->st_size = kbuf->st_size;
+	buf->st_atime_sec = kbuf->st_atime_sec;
+	buf->st_mtime_sec = kbuf->st_mtime_sec;
+	buf->st_ctime_sec = kbuf->st_ctime_sec;
+	buf->st_blocks = kbuf->st_blocks;
+	buf->st_blksize = kbuf->st_blksize;
+	buf->st_flags = kbuf->st_flags;
+	buf->st_gen = kbuf->st_gen;
+	buf->__pad3 = 0;
+	buf->__glibc_reserved[0] = 0;
+	buf->__glibc_reserved[1] = 0;
+	buf->__glibc_reserved[2] = 0;
+	buf->__glibc_reserved[3] = 0;
+      }
+      break;
+
+    case _STAT_VER_GLIBC2_3_4:
+      {
+	struct stat64 *buf = ubuf;
+
+	buf->st_dev = kbuf->st_dev;
+	buf->st_ino = kbuf->st_ino;
+	buf->st_rdev = kbuf->st_rdev;
+	buf->st_size = kbuf->st_size;
+	buf->st_blocks = kbuf->st_blocks;
+
+	buf->st_mode = kbuf->st_mode;
+	buf->st_uid = kbuf->st_uid;
+	buf->st_gid = kbuf->st_gid;
+	buf->st_blksize = kbuf->st_blksize;
+	buf->st_nlink = kbuf->st_nlink;
+	buf->__pad0 = 0;
+
+	buf->st_atim.tv_sec = kbuf->st_atime_sec;
+	buf->st_atim.tv_nsec = 0;
+	buf->st_mtim.tv_sec = kbuf->st_mtime_sec;
+	buf->st_mtim.tv_nsec = 0;
+	buf->st_ctim.tv_sec = kbuf->st_ctime_sec;
+	buf->st_ctim.tv_nsec = 0;
+
+	buf->__glibc_reserved[0] = 0;
+	buf->__glibc_reserved[1] = 0;
+	buf->__glibc_reserved[2] = 0;
+      }
+      break;
+
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return 0;
+}
diff --git a/sysdeps/unix/sysv/linux/sw_64/xstatconv.h b/sysdeps/unix/sysv/linux/sw_64/xstatconv.h
new file mode 100644
index 00000000..921017ab
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/xstatconv.h
@@ -0,0 +1,22 @@
+/* Convert between the kernel's `struct stat' format, and libc's.
+   Copyright (C) 2004-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/syscall.h>
+
+extern int __xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+  attribute_hidden;
diff --git a/sysdeps/unix/sysv/linux/sw_64/xstatver.h b/sysdeps/unix/sysv/linux/sw_64/xstatver.h
new file mode 100644
index 00000000..1cb5d26b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sw_64/xstatver.h
@@ -0,0 +1,14 @@
+/* Versions of the 'struct stat' data structure used in compatibility xstat
+   functions.  */
+#define _STAT_VER_KERNEL	0
+#define _STAT_VER_GLIBC2	1
+#define _STAT_VER_GLIBC2_1	2
+#define _STAT_VER_KERNEL64	3
+#define _STAT_VER_GLIBC2_3_4	3
+#define _STAT_VER_LINUX		3
+#define _STAT_VER		_STAT_VER_LINUX
+
+/* Versions of the 'xmknod' interface used in compatibility xmknod
+   functions.  */
+#define _MKNOD_VER_LINUX	0
+#define _MKNOD_VER		_MKNOD_VER_LINUX
diff --git a/sysdeps/unix/sysv/linux/syscall-names.list b/sysdeps/unix/sysv/linux/syscall-names.list
index cf6f70ec..3f3211f0 100644
--- a/sysdeps/unix/sysv/linux/syscall-names.list
+++ b/sysdeps/unix/sysv/linux/syscall-names.list
@@ -117,6 +117,7 @@ fanotify_mark
 fchdir
 fchmod
 fchmodat
+fchmodat2
 fchown
 fchown32
 fchownat
@@ -188,6 +189,7 @@ getrusage
 getsid
 getsockname
 getsockopt
+getsysinfo
 gettid
 gettimeofday
 getuid
@@ -293,6 +295,8 @@ newfstatat
 nfsservctl
 ni_syscall
 nice
+odd_getpriority
+odd_sigprocmask
 old_adjtimex
 old_getpagesize
 oldfstat
@@ -425,6 +429,7 @@ perf_event_open
 perfctr
 perfmonctl
 personality
+pfh_ops
 pidfd_getfd
 pidfd_open
 pidfd_send_signal
@@ -558,6 +563,7 @@ setreuid32
 setrlimit
 setsid
 setsockopt
+setsysinfo
 settimeofday
 setuid
 setuid32
-- 
2.20.1

